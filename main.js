/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  var version = "1.7.1";
  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */
  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.

  function extend(dest) {
    var i, j, len, src;

    for (j = 1, len = arguments.length; j < len; j++) {
      src = arguments[j];

      for (i in src) {
        dest[i] = src[i];
      }
    }

    return dest;
  } // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)


  var create = Object.create || function () {
    function F() {}

    return function (proto) {
      F.prototype = proto;
      return new F();
    };
  }(); // @function bind(fn: Function, …): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.


  function bind(fn, obj) {
    var slice = Array.prototype.slice;

    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1));
    }

    var args = slice.call(arguments, 2);
    return function () {
      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
    };
  } // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)


  var lastId = 0; // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.

  function stamp(obj) {
    /*eslint-disable */
    obj._leaflet_id = obj._leaflet_id || ++lastId;
    return obj._leaflet_id;
    /* eslint-enable */
  } // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.


  function throttle(fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
      // reset lock and call if queued
      lock = false;

      if (args) {
        wrapperFn.apply(context, args);
        args = false;
      }
    };

    wrapperFn = function () {
      if (lock) {
        // called too soon, queue to call later
        args = arguments;
      } else {
        // call and lock until later
        fn.apply(context, arguments);
        setTimeout(later, time);
        lock = true;
      }
    };

    return wrapperFn;
  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.


  function wrapNum(x, range, includeMax) {
    var max = range[1],
        min = range[0],
        d = max - min;
    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  } // @function falseFn(): Function
  // Returns a function which always returns `false`.


  function falseFn() {
    return false;
  } // @function formatNum(num: Number, digits?: Number): Number
  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.


  function formatNum(num, digits) {
    var pow = Math.pow(10, digits === undefined ? 6 : digits);
    return Math.round(num * pow) / pow;
  } // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)


  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  } // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.


  function splitWords(str) {
    return trim(str).split(/\s+/);
  } // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.


  function setOptions(obj, options) {
    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
      obj.options = obj.options ? create(obj.options) : {};
    }

    for (var i in options) {
      obj.options[i] = options[i];
    }

    return obj.options;
  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)


  function getParamString(obj, existingUrl, uppercase) {
    var params = [];

    for (var i in obj) {
      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
    }

    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_-]+) *\}/g; // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values — they will be evaluated passing `data` as an argument.

  function template(str, data) {
    return str.replace(templateRe, function (str, key) {
      var value = data[key];

      if (value === undefined) {
        throw new Error('No value provided for variable ' + str);
      } else if (typeof value === 'function') {
        value = value(data);
      }

      return value;
    });
  } // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)


  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }; // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)


  function indexOf(array, el) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === el) {
        return i;
      }
    }

    return -1;
  } // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).


  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0; // fallback for IE 7-8

  function timeoutDefer(fn) {
    var time = +new Date(),
        timeToCall = Math.max(0, 16 - (time - lastTime));
    lastTime = time + timeToCall;
    return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;

  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
    window.clearTimeout(id);
  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.


  function requestAnimFrame(fn, context, immediate) {
    if (immediate && requestFn === timeoutDefer) {
      fn.call(context);
    } else {
      return requestFn.call(window, bind(fn, context));
    }
  } // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).


  function cancelAnimFrame(id) {
    if (id) {
      cancelFn.call(window, id);
    }
  }

  var Util = {
    extend: extend,
    create: create,
    bind: bind,
    lastId: lastId,
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  }; // @class Class
  // @aka L.Class
  // @section
  // @uninheritable
  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {
    // @function extend(props: Object): Function
    // [Extends the current class](#class-inheritance) given the properties to be included.
    // Returns a Javascript function that is a class constructor (to be called with `new`).
    var NewClass = function () {
      // call the constructor
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      } // call all constructor hooks


      this.callInitHooks();
    };

    var parentProto = NewClass.__super__ = this.prototype;
    var proto = create(parentProto);
    proto.constructor = NewClass;
    NewClass.prototype = proto; // inherit parent's statics

    for (var i in this) {
      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
        NewClass[i] = this[i];
      }
    } // mix static properties into the class


    if (props.statics) {
      extend(NewClass, props.statics);
      delete props.statics;
    } // mix includes into the prototype


    if (props.includes) {
      checkDeprecatedMixinEvents(props.includes);
      extend.apply(null, [proto].concat(props.includes));
      delete props.includes;
    } // merge options


    if (proto.options) {
      props.options = extend(create(proto.options), props.options);
    } // mix given properties into the prototype


    extend(proto, props);
    proto._initHooks = []; // add method for calling all hooks

    proto.callInitHooks = function () {
      if (this._initHooksCalled) {
        return;
      }

      if (parentProto.callInitHooks) {
        parentProto.callInitHooks.call(this);
      }

      this._initHooksCalled = true;

      for (var i = 0, len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };

    return NewClass;
  }; // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.


  Class.include = function (props) {
    extend(this.prototype, props);
    return this;
  }; // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.


  Class.mergeOptions = function (options) {
    extend(this.prototype.options, options);
    return this;
  }; // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.


  Class.addInitHook = function (fn) {
    // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);
    var init = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    this.prototype._initHooks = this.prototype._initHooks || [];

    this.prototype._initHooks.push(init);

    return this;
  };

  function checkDeprecatedMixinEvents(includes) {
    if (typeof L === 'undefined' || !L || !L.Mixin) {
      return;
    }

    includes = isArray(includes) ? includes : [includes];

    for (var i = 0; i < includes.length; i++) {
      if (includes[i] === L.Mixin.Events) {
        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
      }
    }
  }
  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */


  var Events = {
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
    on: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === 'object') {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }

      return this;
    },

    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object. This includes implicitly attached events.
     */
    off: function (types, fn, context) {
      if (!types) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (typeof types === 'object') {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      }

      return this;
    },
    // attach listener (without syntactic sugar now)
    _on: function (type, fn, context) {
      this._events = this._events || {};
      /* get/init listeners for type */

      var typeListeners = this._events[type];

      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }

      var newListener = {
        fn: fn,
        ctx: context
      },
          listeners = typeListeners; // check if fn already there

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return;
        }
      }

      listeners.push(newListener);
    },
    _off: function (type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];

      if (!listeners) {
        return;
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        } // clear all listeners for a type if function isn't specified


        delete this._events[type];
        return;
      }

      if (context === this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];

          if (l.ctx !== context) {
            continue;
          }

          if (l.fn === fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }

            listeners.splice(i, 1);
            return;
          }
        }
      }
    },
    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide an data
    // object — the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.
    fire: function (type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });

      if (this._events) {
        var listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;

          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    },
    // @method listens(type: String): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.
    listens: function (type, propagate) {
      var listeners = this._events && this._events[type];

      if (listeners && listeners.length) {
        return true;
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true;
          }
        }
      }

      return false;
    },
    // @method once(…): this
    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
    once: function (types, fn, context) {
      if (typeof types === 'object') {
        for (var type in types) {
          this.once(type, types[type], fn);
        }

        return this;
      }

      var handler = bind(function () {
        this.off(types, fn, context).off(types, handler, context);
      }, this); // add a listener that's executed once and removed after that

      return this.on(types, fn, context).on(types, handler, context);
    },
    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events
    addEventParent: function (obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    },
    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events
    removeEventParent: function (obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }

      return this;
    },
    _propagateEvent: function (e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  }; // aliases; we should ditch those eventually
  // @method addEventListener(…): this
  // Alias to [`on(…)`](#evented-on)

  Events.addEventListener = Events.on; // @method removeEventListener(…): this
  // Alias to [`off(…)`](#evented-off)
  // @method clearAllEventListeners(…): this
  // Alias to [`off()`](#evented-off)

  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this
  // Alias to [`once(…)`](#evented-once)

  Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this
  // Alias to [`fire(…)`](#evented-fire)

  Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean
  // Alias to [`listens(…)`](#evented-listens)

  Events.hasEventListeners = Events.listens;
  var Evented = Class.extend(Events);
  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
    // @property x: Number; The `x` coordinate of the point
    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point

    this.y = round ? Math.round(y) : y;
  }

  var trunc = Math.trunc || function (v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {
    // @method clone(): Point
    // Returns a copy of the current point.
    clone: function () {
      return new Point(this.x, this.y);
    },
    // @method add(otherPoint: Point): Point
    // Returns the result of addition of the current and the given points.
    add: function (point) {
      // non-destructive, returns a new point
      return this.clone()._add(toPoint(point));
    },
    _add: function (point) {
      // destructive, used directly for performance in situations where it's safe to modify existing point
      this.x += point.x;
      this.y += point.y;
      return this;
    },
    // @method subtract(otherPoint: Point): Point
    // Returns the result of subtraction of the given point from the current.
    subtract: function (point) {
      return this.clone()._subtract(toPoint(point));
    },
    _subtract: function (point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },
    // @method divideBy(num: Number): Point
    // Returns the result of division of the current point by the given number.
    divideBy: function (num) {
      return this.clone()._divideBy(num);
    },
    _divideBy: function (num) {
      this.x /= num;
      this.y /= num;
      return this;
    },
    // @method multiplyBy(num: Number): Point
    // Returns the result of multiplication of the current point by the given number.
    multiplyBy: function (num) {
      return this.clone()._multiplyBy(num);
    },
    _multiplyBy: function (num) {
      this.x *= num;
      this.y *= num;
      return this;
    },
    // @method scaleBy(scale: Point): Point
    // Multiply each coordinate of the current point by each coordinate of
    // `scale`. In linear algebra terms, multiply the point by the
    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
    // defined by `scale`.
    scaleBy: function (point) {
      return new Point(this.x * point.x, this.y * point.y);
    },
    // @method unscaleBy(scale: Point): Point
    // Inverse of `scaleBy`. Divide each coordinate of the current point by
    // each coordinate of `scale`.
    unscaleBy: function (point) {
      return new Point(this.x / point.x, this.y / point.y);
    },
    // @method round(): Point
    // Returns a copy of the current point with rounded coordinates.
    round: function () {
      return this.clone()._round();
    },
    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    // @method floor(): Point
    // Returns a copy of the current point with floored coordinates (rounded down).
    floor: function () {
      return this.clone()._floor();
    },
    _floor: function () {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    // @method ceil(): Point
    // Returns a copy of the current point with ceiled coordinates (rounded up).
    ceil: function () {
      return this.clone()._ceil();
    },
    _ceil: function () {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    // @method trunc(): Point
    // Returns a copy of the current point with truncated coordinates (rounded towards zero).
    trunc: function () {
      return this.clone()._trunc();
    },
    _trunc: function () {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    },
    // @method distanceTo(otherPoint: Point): Number
    // Returns the cartesian distance between the current and the given points.
    distanceTo: function (point) {
      point = toPoint(point);
      var x = point.x - this.x,
          y = point.y - this.y;
      return Math.sqrt(x * x + y * y);
    },
    // @method equals(otherPoint: Point): Boolean
    // Returns `true` if the given point has the same coordinates.
    equals: function (point) {
      point = toPoint(point);
      return point.x === this.x && point.y === this.y;
    },
    // @method contains(otherPoint: Point): Boolean
    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
    contains: function (point) {
      point = toPoint(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    },
    // @method toString(): String
    // Returns a string representation of the point for debugging purposes.
    toString: function () {
      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
    }
  }; // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.
  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.
  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.

  function toPoint(x, y, round) {
    if (x instanceof Point) {
      return x;
    }

    if (isArray(x)) {
      return new Point(x[0], x[1]);
    }

    if (x === undefined || x === null) {
      return x;
    }

    if (typeof x === 'object' && 'x' in x && 'y' in x) {
      return new Point(x.x, x.y);
    }

    return new Point(x, y, round);
  }
  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function Bounds(a, b) {
    if (!a) {
      return;
    }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  }

  Bounds.prototype = {
    // @method extend(point: Point): this
    // Extends the bounds to contain the given point.
    extend: function (point) {
      // (Point)
      point = toPoint(point); // @property min: Point
      // The top left corner of the rectangle.
      // @property max: Point
      // The bottom right corner of the rectangle.

      if (!this.min && !this.max) {
        this.min = point.clone();
        this.max = point.clone();
      } else {
        this.min.x = Math.min(point.x, this.min.x);
        this.max.x = Math.max(point.x, this.max.x);
        this.min.y = Math.min(point.y, this.min.y);
        this.max.y = Math.max(point.y, this.max.y);
      }

      return this;
    },
    // @method getCenter(round?: Boolean): Point
    // Returns the center point of the bounds.
    getCenter: function (round) {
      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    },
    // @method getBottomLeft(): Point
    // Returns the bottom-left point of the bounds.
    getBottomLeft: function () {
      return new Point(this.min.x, this.max.y);
    },
    // @method getTopRight(): Point
    // Returns the top-right point of the bounds.
    getTopRight: function () {
      // -> Point
      return new Point(this.max.x, this.min.y);
    },
    // @method getTopLeft(): Point
    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
    getTopLeft: function () {
      return this.min; // left, top
    },
    // @method getBottomRight(): Point
    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
    getBottomRight: function () {
      return this.max; // right, bottom
    },
    // @method getSize(): Point
    // Returns the size of the given bounds
    getSize: function () {
      return this.max.subtract(this.min);
    },
    // @method contains(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains(point: Point): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      var min, max;

      if (typeof obj[0] === 'number' || obj instanceof Point) {
        obj = toPoint(obj);
      } else {
        obj = toBounds(obj);
      }

      if (obj instanceof Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }

      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
    },
    // @method intersects(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds
    // intersect if they have at least one point in common.
    intersects: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xIntersects = max2.x >= min.x && min2.x <= max.x,
          yIntersects = max2.y >= min.y && min2.y <= max.y;
      return xIntersects && yIntersects;
    },
    // @method overlaps(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds
    // overlap if their intersection is an area.
    overlaps: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xOverlaps = max2.x > min.x && min2.x < max.x,
          yOverlaps = max2.y > min.y && min2.y < max.y;
      return xOverlaps && yOverlaps;
    },
    isValid: function () {
      return !!(this.min && this.max);
    }
  }; // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.

  function toBounds(a, b) {
    if (!a || a instanceof Bounds) {
      return a;
    }

    return new Bounds(a, b);
  }
  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLngBounds(corner1, corner2) {
    // (LatLng, LatLng) or (LatLng[])
    if (!corner1) {
      return;
    }

    var latlngs = corner2 ? [corner1, corner2] : corner1;

    for (var i = 0, len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  }

  LatLngBounds.prototype = {
    // @method extend(latlng: LatLng): this
    // Extend the bounds to contain the given point
    // @alternative
    // @method extend(otherBounds: LatLngBounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLng) {
        sw2 = obj;
        ne2 = obj;
      } else if (obj instanceof LatLngBounds) {
        sw2 = obj._southWest;
        ne2 = obj._northEast;

        if (!sw2 || !ne2) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }

      if (!sw && !ne) {
        this._southWest = new LatLng(sw2.lat, sw2.lng);
        this._northEast = new LatLng(ne2.lat, ne2.lng);
      } else {
        sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
      }

      return this;
    },
    // @method pad(bufferRatio: Number): LatLngBounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var sw = this._southWest,
          ne = this._northEast,
          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
    },
    // @method getCenter(): LatLng
    // Returns the center point of the bounds.
    getCenter: function () {
      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    },
    // @method getSouthWest(): LatLng
    // Returns the south-west point of the bounds.
    getSouthWest: function () {
      return this._southWest;
    },
    // @method getNorthEast(): LatLng
    // Returns the north-east point of the bounds.
    getNorthEast: function () {
      return this._northEast;
    },
    // @method getNorthWest(): LatLng
    // Returns the north-west point of the bounds.
    getNorthWest: function () {
      return new LatLng(this.getNorth(), this.getWest());
    },
    // @method getSouthEast(): LatLng
    // Returns the south-east point of the bounds.
    getSouthEast: function () {
      return new LatLng(this.getSouth(), this.getEast());
    },
    // @method getWest(): Number
    // Returns the west longitude of the bounds
    getWest: function () {
      return this._southWest.lng;
    },
    // @method getSouth(): Number
    // Returns the south latitude of the bounds
    getSouth: function () {
      return this._southWest.lat;
    },
    // @method getEast(): Number
    // Returns the east longitude of the bounds
    getEast: function () {
      return this._northEast.lng;
    },
    // @method getNorth(): Number
    // Returns the north latitude of the bounds
    getNorth: function () {
      return this._northEast.lat;
    },
    // @method contains(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains (latlng: LatLng): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      // (LatLngBounds) or (LatLng) -> Boolean
      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
        obj = toLatLng(obj);
      } else {
        obj = toLatLngBounds(obj);
      }

      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }

      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
    },
    // @method intersects(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
    intersects: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
      return latIntersects && lngIntersects;
    },
    // @method overlaps(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
    overlaps: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
      return latOverlaps && lngOverlaps;
    },
    // @method toBBoxString(): String
    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
    toBBoxString: function () {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
    },
    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (bounds, maxMargin) {
      if (!bounds) {
        return false;
      }

      bounds = toLatLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
    },
    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this._southWest && this._northEast);
    }
  }; // TODO International date line?
  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.
  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).

  function toLatLngBounds(a, b) {
    if (a instanceof LatLngBounds) {
      return a;
    }

    return new LatLngBounds(a, b);
  }
  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLng(lat, lng, alt) {
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    } // @property lat: Number
    // Latitude in degrees


    this.lat = +lat; // @property lng: Number
    // Longitude in degrees

    this.lng = +lng; // @property alt: Number
    // Altitude in meters (optional)

    if (alt !== undefined) {
      this.alt = +alt;
    }
  }

  LatLng.prototype = {
    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (obj, maxMargin) {
      if (!obj) {
        return false;
      }

      obj = toLatLng(obj);
      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
    },
    // @method toString(): String
    // Returns a string representation of the point (for debugging purposes).
    toString: function (precision) {
      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
    },
    // @method distanceTo(otherLatLng: LatLng): Number
    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
    distanceTo: function (other) {
      return Earth.distance(this, toLatLng(other));
    },
    // @method wrap(): LatLng
    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
    wrap: function () {
      return Earth.wrapLatLng(this);
    },
    // @method toBounds(sizeInMeters: Number): LatLngBounds
    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
    toBounds: function (sizeInMeters) {
      var latAccuracy = 180 * sizeInMeters / 40075017,
          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
    },
    clone: function () {
      return new LatLng(this.lat, this.lng, this.alt);
    }
  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
    if (a instanceof LatLng) {
      return a;
    }

    if (isArray(a) && typeof a[0] !== 'object') {
      if (a.length === 3) {
        return new LatLng(a[0], a[1], a[2]);
      }

      if (a.length === 2) {
        return new LatLng(a[0], a[1]);
      }

      return null;
    }

    if (a === undefined || a === null) {
      return a;
    }

    if (typeof a === 'object' && 'lat' in a) {
      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
    }

    if (b === undefined) {
      return null;
    }

    return new LatLng(a, b, c);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */


  var CRS = {
    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
    // Projects geographical coordinates into pixel coordinates for a given zoom.
    latLngToPoint: function (latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
          scale = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale);
    },
    // @method pointToLatLng(point: Point, zoom: Number): LatLng
    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
    // zoom into geographical coordinates.
    pointToLatLng: function (point, zoom) {
      var scale = this.scale(zoom),
          untransformedPoint = this.transformation.untransform(point, scale);
      return this.projection.unproject(untransformedPoint);
    },
    // @method project(latlng: LatLng): Point
    // Projects geographical coordinates into coordinates in units accepted for
    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
    project: function (latlng) {
      return this.projection.project(latlng);
    },
    // @method unproject(point: Point): LatLng
    // Given a projected coordinate returns the corresponding LatLng.
    // The inverse of `project`.
    unproject: function (point) {
      return this.projection.unproject(point);
    },
    // @method scale(zoom: Number): Number
    // Returns the scale used when transforming projected coordinates into
    // pixel coordinates for a particular zoom. For example, it returns
    // `256 * 2^zoom` for Mercator-based CRS.
    scale: function (zoom) {
      return 256 * Math.pow(2, zoom);
    },
    // @method zoom(scale: Number): Number
    // Inverse of `scale()`, returns the zoom level corresponding to a scale
    // factor of `scale`.
    zoom: function (scale) {
      return Math.log(scale / 256) / Math.LN2;
    },
    // @method getProjectedBounds(zoom: Number): Bounds
    // Returns the projection's bounds scaled and transformed for the provided `zoom`.
    getProjectedBounds: function (zoom) {
      if (this.infinite) {
        return null;
      }

      var b = this.projection.bounds,
          s = this.scale(zoom),
          min = this.transformation.transform(b.min, s),
          max = this.transformation.transform(b.max, s);
      return new Bounds(min, max);
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates.
    // @property code: String
    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
    //
    // @property wrapLng: Number[]
    // An array of two numbers defining whether the longitude (horizontal) coordinate
    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
    //
    // @property wrapLat: Number[]
    // Like `wrapLng`, but for the latitude (vertical) axis.
    // wrapLng: [min, max],
    // wrapLat: [min, max],
    // @property infinite: Boolean
    // If true, the coordinate space will be unbounded (infinite in both axes)
    infinite: false,
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where lat and lng has been wrapped according to the
    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
    wrapLatLng: function (latlng) {
      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
          alt = latlng.alt;
      return new LatLng(lat, lng, alt);
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring
    // that its center is within the CRS's bounds.
    // Only accepts actual `L.LatLngBounds` instances, not arrays.
    wrapLatLngBounds: function (bounds) {
      var center = bounds.getCenter(),
          newCenter = this.wrapLatLng(center),
          latShift = center.lat - newCenter.lat,
          lngShift = center.lng - newCenter.lng;

      if (latShift === 0 && lngShift === 0) {
        return bounds;
      }

      var sw = bounds.getSouthWest(),
          ne = bounds.getNorthEast(),
          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
      return new LatLngBounds(newSw, newNe);
    }
  };
  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
    wrapLng: [-180, 180],
    // Mean Earth Radius, as recommended for use by
    // the International Union of Geodesy and Geophysics,
    // see http://rosettacode.org/wiki/Haversine_formula
    R: 6371000,
    // distance between two geographical points using spherical law of cosines approximation
    distance: function (latlng1, latlng2) {
      var rad = Math.PI / 180,
          lat1 = latlng1.lat * rad,
          lat2 = latlng2.lat * rad,
          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return this.R * c;
    }
  });
  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection — the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;
  var SphericalMercator = {
    R: earthRadius,
    MAX_LATITUDE: 85.0511287798,
    project: function (latlng) {
      var d = Math.PI / 180,
          max = this.MAX_LATITUDE,
          lat = Math.max(Math.min(max, latlng.lat), -max),
          sin = Math.sin(lat * d);
      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
    },
    unproject: function (point) {
      var d = 180 / Math.PI;
      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
    },
    bounds: function () {
      var d = earthRadius * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    }()
  };
  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */
  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.

  function Transformation(a, b, c, d) {
    if (isArray(a)) {
      // use array properties
      this._a = a[0];
      this._b = a[1];
      this._c = a[2];
      this._d = a[3];
      return;
    }

    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  }

  Transformation.prototype = {
    // @method transform(point: Point, scale?: Number): Point
    // Returns a transformed point, optionally multiplied by the given scale.
    // Only accepts actual `L.Point` instances, not arrays.
    transform: function (point, scale) {
      // (Point, Number) -> Point
      return this._transform(point.clone(), scale);
    },
    // destructive transform (faster)
    _transform: function (point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },
    // @method untransform(point: Point, scale?: Number): Point
    // Returns the reverse transformation of the given point, optionally divided
    // by the given scale. Only accepts actual `L.Point` instances, not arrays.
    untransform: function (point, scale) {
      scale = scale || 1;
      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }
  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.
  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
    return new Transformation(a, b, c, d);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */


  var EPSG3857 = extend({}, Earth, {
    code: 'EPSG:3857',
    projection: SphericalMercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  var EPSG900913 = extend({}, EPSG3857, {
    code: 'EPSG:900913'
  }); // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:
  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).

  function svgCreate(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  } // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions


  function pointsToPath(rings, closed) {
    var str = '',
        i,
        j,
        len,
        len2,
        points,
        p;

    for (i = 0, len = rings.length; i < len; i++) {
      points = rings[i];

      for (j = 0, len2 = points.length; j < len2; j++) {
        p = points[j];
        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
      } // closes the ring for polygons; "x" is VML syntax


      str += closed ? svg ? 'z' : 'x' : '';
    } // SVG complains about empty path strings


    return str || 'M0 0';
  }
  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */


  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).

  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.

  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.

  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).

  var webkit = userAgentContains('webkit'); // @property android: Boolean
  // `true` for any browser running on an Android platform.

  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.

  var android23 = userAgentContains('android 2') || userAgentContains('android 3');
  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */

  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)

  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser

  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.

  var chrome = !edge && userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.

  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.

  var safari = !chrome && userAgentContains('safari');
  var phantom = userAgentContains('phantom'); // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).

  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform

  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.

  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.

  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.

  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.

  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.

  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.

  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.

  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).

  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).

  var pointer = !!(window.PointerEvent || msPointer); // @property touch: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // This does not necessarily mean that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.

  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.

  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.

  var mobileGecko = mobile && gecko; // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.

  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.

  var passiveEvents = function () {
    var supportsPassiveOption = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function () {
          // eslint-disable-line getter-return
          supportsPassiveOption = true;
        }
      });
      window.addEventListener('testPassiveEventSupport', falseFn, opts);
      window.removeEventListener('testPassiveEventSupport', falseFn, opts);
    } catch (e) {// Errors can safely be ignored since this is only a browser support test.
    }

    return supportsPassiveOption;
  }(); // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).


  var canvas = function () {
    return !!document.createElement('canvas').getContext;
  }(); // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).


  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).

  var vml = !svg && function () {
    try {
      var div = document.createElement('div');
      div.innerHTML = '<v:shape adj="1"/>';
      var shape = div.firstChild;
      shape.style.behavior = 'url(#default#VML)';
      return shape && typeof shape.adj === 'object';
    } catch (e) {
      return false;
    }
  }();

  function userAgentContains(str) {
    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }

  var Browser = {
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas,
    svg: svg,
    vml: vml
  };
  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';
  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';
  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';
  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
  var _pointers = {};
  var _pointerDocListener = false; // Provides a touch events wrapper for (ms)pointer events.
  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler, id) {
    if (type === 'touchstart') {
      _addPointerStart(obj, handler, id);
    } else if (type === 'touchmove') {
      _addPointerMove(obj, handler, id);
    } else if (type === 'touchend') {
      _addPointerEnd(obj, handler, id);
    }

    return this;
  }

  function removePointerListener(obj, type, id) {
    var handler = obj['_leaflet_' + type + id];

    if (type === 'touchstart') {
      obj.removeEventListener(POINTER_DOWN, handler, false);
    } else if (type === 'touchmove') {
      obj.removeEventListener(POINTER_MOVE, handler, false);
    } else if (type === 'touchend') {
      obj.removeEventListener(POINTER_UP, handler, false);
      obj.removeEventListener(POINTER_CANCEL, handler, false);
    }

    return this;
  }

  function _addPointerStart(obj, handler, id) {
    var onDown = bind(function (e) {
      // IE10 specific: MsTouch needs preventDefault. See #2000
      if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
        preventDefault(e);
      }

      _handlePointer(e, handler);
    });
    obj['_leaflet_touchstart' + id] = onDown;
    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation

    if (!_pointerDocListener) {
      // we listen document as any drags that end by moving the touch off the screen get fired there
      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
      document.addEventListener(POINTER_UP, _globalPointerUp, true);
      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
      _pointerDocListener = true;
    }
  }

  function _globalPointerDown(e) {
    _pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
    if (_pointers[e.pointerId]) {
      _pointers[e.pointerId] = e;
    }
  }

  function _globalPointerUp(e) {
    delete _pointers[e.pointerId];
  }

  function _handlePointer(e, handler) {
    e.touches = [];

    for (var i in _pointers) {
      e.touches.push(_pointers[i]);
    }

    e.changedTouches = [e];
    handler(e);
  }

  function _addPointerMove(obj, handler, id) {
    var onMove = function (e) {
      // don't fire touch moves when mouse isn't down
      if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse') && e.buttons === 0) {
        return;
      }

      _handlePointer(e, handler);
    };

    obj['_leaflet_touchmove' + id] = onMove;
    obj.addEventListener(POINTER_MOVE, onMove, false);
  }

  function _addPointerEnd(obj, handler, id) {
    var onUp = function (e) {
      _handlePointer(e, handler);
    };

    obj['_leaflet_touchend' + id] = onUp;
    obj.addEventListener(POINTER_UP, onUp, false);
    obj.addEventListener(POINTER_CANCEL, onUp, false);
  }
  /*
   * Extends the event handling code with double tap support for mobile browsers.
   */


  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';

  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';

  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs

  function addDoubleTapListener(obj, handler, id) {
    var last,
        touch$$1,
        doubleTap = false,
        delay = 250;

    function onTouchStart(e) {
      if (pointer) {
        if (!e.isPrimary) {
          return;
        }

        if (e.pointerType === 'mouse') {
          return;
        } // mouse fires native dblclick

      } else if (e.touches.length > 1) {
        return;
      }

      var now = Date.now(),
          delta = now - (last || now);
      touch$$1 = e.touches ? e.touches[0] : e;
      doubleTap = delta > 0 && delta <= delay;
      last = now;
    }

    function onTouchEnd(e) {
      if (doubleTap && !touch$$1.cancelBubble) {
        if (pointer) {
          if (e.pointerType === 'mouse') {
            return;
          } // work around .type being readonly with MSPointer* events


          var newTouch = {},
              prop,
              i;

          for (i in touch$$1) {
            prop = touch$$1[i];
            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
          }

          touch$$1 = newTouch;
        }

        touch$$1.type = 'dblclick';
        touch$$1.button = 0;
        handler(touch$$1);
        last = null;
      }
    }

    obj[_pre + _touchstart + id] = onTouchStart;
    obj[_pre + _touchend + id] = onTouchEnd;
    obj[_pre + 'dblclick' + id] = handler;
    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {
      passive: false
    } : false);
    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {
      passive: false
    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
    // the browser doesn't fire touchend/pointerup events but does fire
    // native dblclicks. See #4127.
    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.

    obj.addEventListener('dblclick', handler, false);
    return this;
  }

  function removeDoubleTapListener(obj, id) {
    var touchstart = obj[_pre + _touchstart + id],
        touchend = obj[_pre + _touchend + id],
        dblclick = obj[_pre + 'dblclick' + id];
    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener(_touchend, touchend, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener('dblclick', dblclick, false);
    return this;
  }
  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */
  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).


  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser
  // @property TRANSITION: String
  // Vendor-prefixed transition style name.

  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.

  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.

  function get(id) {
    return typeof id === 'string' ? document.getElementById(id) : id;
  } // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.


  function getStyle(el, style) {
    var value = el.style[style] || el.currentStyle && el.currentStyle[style];

    if ((!value || value === 'auto') && document.defaultView) {
      var css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }

    return value === 'auto' ? null : value;
  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.


  function create$1(tagName, className, container) {
    var el = document.createElement(tagName);
    el.className = className || '';

    if (container) {
      container.appendChild(el);
    }

    return el;
  } // @function remove(el: HTMLElement)
  // Removes `el` from its parent element


  function remove(el) {
    var parent = el.parentNode;

    if (parent) {
      parent.removeChild(el);
    }
  } // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`


  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  } // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.


  function toFront(el) {
    var parent = el.parentNode;

    if (parent && parent.lastChild !== el) {
      parent.appendChild(el);
    }
  } // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.


  function toBack(el) {
    var parent = el.parentNode;

    if (parent && parent.firstChild !== el) {
      parent.insertBefore(el, parent.firstChild);
    }
  } // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.


  function hasClass(el, name) {
    if (el.classList !== undefined) {
      return el.classList.contains(name);
    }

    var className = getClass(el);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  } // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.


  function addClass(el, name) {
    if (el.classList !== undefined) {
      var classes = splitWords(name);

      for (var i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      var className = getClass(el);
      setClass(el, (className ? className + ' ' : '') + name);
    }
  } // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.


  function removeClass(el, name) {
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
    }
  } // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.


  function setClass(el, name) {
    if (el.className.baseVal === undefined) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  } // @function getClass(el: HTMLElement): String
  // Returns the element's class.


  function getClass(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }

    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  } // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.


  function setOpacity(el, value) {
    if ('opacity' in el.style) {
      el.style.opacity = value;
    } else if ('filter' in el.style) {
      _setOpacityIE(el, value);
    }
  }

  function _setOpacityIE(el, value) {
    var filter = false,
        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist

    try {
      filter = el.filters.item(filterName);
    } catch (e) {
      // don't set opacity to 1 if we haven't already set an opacity,
      // it isn't needed and breaks transparent pngs.
      if (value === 1) {
        return;
      }
    }

    value = Math.round(value * 100);

    if (filter) {
      filter.Enabled = value !== 100;
      filter.Opacity = value;
    } else {
      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
    }
  } // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.


  function testProp(props) {
    var style = document.documentElement.style;

    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }

    return false;
  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.


  function setTransform(el, offset, scale) {
    var pos = offset || new Point(0, 0);
    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
  } // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).


  function setPosition(el, point) {
    /*eslint-disable */
    el._leaflet_pos = point;
    /* eslint-enable */

    if (any3d) {
      setTransform(el, point);
    } else {
      el.style.left = point.x + 'px';
      el.style.top = point.y + 'px';
    }
  } // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.


  function getPosition(el) {
    // this method is only used for elements previously positioned using setPosition,
    // so it's safe to cache the position for performance
    return el._leaflet_pos || new Point(0, 0);
  } // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.
  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).


  var disableTextSelection;
  var enableTextSelection;

  var _userSelect;

  if ('onselectstart' in document) {
    disableTextSelection = function () {
      on(window, 'selectstart', preventDefault);
    };

    enableTextSelection = function () {
      off(window, 'selectstart', preventDefault);
    };
  } else {
    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

    disableTextSelection = function () {
      if (userSelectProperty) {
        var style = document.documentElement.style;
        _userSelect = style[userSelectProperty];
        style[userSelectProperty] = 'none';
      }
    };

    enableTextSelection = function () {
      if (userSelectProperty) {
        document.documentElement.style[userSelectProperty] = _userSelect;
        _userSelect = undefined;
      }
    };
  } // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.


  function disableImageDrag() {
    on(window, 'dragstart', preventDefault);
  } // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).


  function enableImageDrag() {
    off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle; // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.


  function preventOutline(element) {
    while (element.tabIndex === -1) {
      element = element.parentNode;
    }

    if (!element.style) {
      return;
    }

    restoreOutline();
    _outlineElement = element;
    _outlineStyle = element.style.outline;
    element.style.outline = 'none';
    on(window, 'keydown', restoreOutline);
  } // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().


  function restoreOutline() {
    if (!_outlineElement) {
      return;
    }

    _outlineElement.style.outline = _outlineStyle;
    _outlineElement = undefined;
    _outlineStyle = undefined;
    off(window, 'keydown', restoreOutline);
  } // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.


  function getSizedParentNode(element) {
    do {
      element = element.parentNode;
    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);

    return element;
  } // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).


  function getScale(element) {
    var rect = element.getBoundingClientRect(); // Read-only in old browsers.

    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }

  var DomUtil = {
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    disableTextSelection: disableTextSelection,
    enableTextSelection: enableTextSelection,
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };
  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */
  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).
  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function on(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        addOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        addOne(obj, types[i], fn, context);
      }
    }

    return this;
  }

  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.
  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function off(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        removeOne(obj, type, types[type], fn);
      }
    } else if (types) {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    } else {
      for (var j in obj[eventsKey]) {
        removeOne(obj, j, obj[eventsKey][j]);
      }

      delete obj[eventsKey];
    }

    return this;
  }

  function browserFiresNativeDblClick() {
    // See https://github.com/w3c/pointerevents/issues/171
    if (pointer) {
      return !(edge || safari);
    }
  }

  var mouseSubst = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout',
    wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

    if (obj[eventsKey] && obj[eventsKey][id]) {
      return this;
    }

    var handler = function (e) {
      return fn.call(context || obj, e || window.event);
    };

    var originalHandler = handler;

    if (pointer && type.indexOf('touch') === 0) {
      // Needs DomEvent.Pointer.js
      addPointerListener(obj, type, handler, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      addDoubleTapListener(obj, handler, id);
    } else if ('addEventListener' in obj) {
      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {
        obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {
          passive: false
        } : false);
      } else if (type === 'mouseenter' || type === 'mouseleave') {
        handler = function (e) {
          e = e || window.event;

          if (isExternalTarget(obj, e)) {
            originalHandler(e);
          }
        };

        obj.addEventListener(mouseSubst[type], handler, false);
      } else {
        obj.addEventListener(type, originalHandler, false);
      }
    } else if ('attachEvent' in obj) {
      obj.attachEvent('on' + type, handler);
    }

    obj[eventsKey] = obj[eventsKey] || {};
    obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
        handler = obj[eventsKey] && obj[eventsKey][id];

    if (!handler) {
      return this;
    }

    if (pointer && type.indexOf('touch') === 0) {
      removePointerListener(obj, type, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      removeDoubleTapListener(obj, id);
    } else if ('removeEventListener' in obj) {
      obj.removeEventListener(mouseSubst[type] || type, handler, false);
    } else if ('detachEvent' in obj) {
      obj.detachEvent('on' + type, handler);
    }

    obj[eventsKey][id] = null;
  } // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```


  function stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else if (e.originalEvent) {
      // In case of Leaflet event.
      e.originalEvent._stopped = true;
    } else {
      e.cancelBubble = true;
    }

    skipped(e);
    return this;
  } // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).


  function disableScrollPropagation(el) {
    addOne(el, 'wheel', stopPropagation);
    return this;
  } // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).


  function disableClickPropagation(el) {
    on(el, 'mousedown touchstart dblclick', stopPropagation);
    addOne(el, 'click', fakeStop);
    return this;
  } // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.


  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }

    return this;
  } // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.


  function stop(e) {
    preventDefault(e);
    stopPropagation(e);
    return this;
  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.


  function getMousePosition(e, container) {
    if (!container) {
      return new Point(e.clientX, e.clientY);
    }

    var scale = getScale(container),
        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

    return new Point( // offset.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
  // and Firefox scrolls device pixels, not CSS pixels


  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.

  function getWheelDelta(e) {
    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
    0;
  }

  var skipEvents = {};

  function fakeStop(e) {
    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
    skipEvents[e.type] = true;
  }

  function skipped(e) {
    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map

    skipEvents[e.type] = false;
    return events;
  } // check if element really left/entered the event target (for mouseenter/mouseleave)


  function isExternalTarget(el, e) {
    var related = e.relatedTarget;

    if (!related) {
      return true;
    }

    try {
      while (related && related !== el) {
        related = related.parentNode;
      }
    } catch (err) {
      return false;
    }

    return related !== el;
  }

  var DomEvent = {
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    fakeStop: fakeStop,
    skipped: skipped,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };
  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var fx = new L.PosAnimation();
   * fx.run(el, [300, 500], 0.5);
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({
    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
    // Run an animation of a given element to a new position, optionally setting
    // duration in seconds (`0.25` by default) and easing linearity factor (3rd
    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
    // `0.5` by default).
    run: function (el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date(); // @event start: Event
      // Fired when the animation starts

      this.fire('start');

      this._animate();
    },
    // @method stop()
    // Stops the animation (if currently running).
    stop: function () {
      if (!this._inProgress) {
        return;
      }

      this._step(true);

      this._complete();
    },
    _animate: function () {
      // animation loop
      this._animId = requestAnimFrame(this._animate, this);

      this._step();
    },
    _step: function (round) {
      var elapsed = +new Date() - this._startTime,
          duration = this._duration * 1000;

      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration), round);
      } else {
        this._runFrame(1);

        this._complete();
      }
    },
    _runFrame: function (progress, round) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));

      if (round) {
        pos._round();
      }

      setPosition(this._el, pos); // @event step: Event
      // Fired continuously during the animation.

      this.fire('step');
    },
    _complete: function () {
      cancelAnimFrame(this._animId);
      this._inProgress = false; // @event end: Event
      // Fired when the animation ends.

      this.fire('end');
    },
    _easeOut: function (t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }
  });
  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API — it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({
    options: {
      // @section Map State Options
      // @option crs: CRS = L.CRS.EPSG3857
      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
      // sure what it means.
      crs: EPSG3857,
      // @option center: LatLng = undefined
      // Initial geographic center of the map
      center: undefined,
      // @option zoom: Number = undefined
      // Initial map zoom level
      zoom: undefined,
      // @option minZoom: Number = *
      // Minimum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the lowest of their `minZoom` options will be used instead.
      minZoom: undefined,
      // @option maxZoom: Number = *
      // Maximum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the highest of their `maxZoom` options will be used instead.
      maxZoom: undefined,
      // @option layers: Layer[] = []
      // Array of layers that will be added to the map initially
      layers: [],
      // @option maxBounds: LatLngBounds = null
      // When this option is set, the map restricts the view to the given
      // geographical bounds, bouncing the user back if the user tries to pan
      // outside the view. To set the restriction dynamically, use
      // [`setMaxBounds`](#map-setmaxbounds) method.
      maxBounds: undefined,
      // @option renderer: Renderer = *
      // The default method for drawing vector layers on the map. `L.SVG`
      // or `L.Canvas` by default depending on browser support.
      renderer: undefined,
      // @section Animation Options
      // @option zoomAnimation: Boolean = true
      // Whether the map zoom animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      zoomAnimation: true,
      // @option zoomAnimationThreshold: Number = 4
      // Won't animate zoom if the zoom difference exceeds this value.
      zoomAnimationThreshold: 4,
      // @option fadeAnimation: Boolean = true
      // Whether the tile fade animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      fadeAnimation: true,
      // @option markerZoomAnimation: Boolean = true
      // Whether markers animate their zoom with the zoom animation, if disabled
      // they will disappear for the length of the animation. By default it's
      // enabled in all browsers that support CSS3 Transitions except Android.
      markerZoomAnimation: true,
      // @option transform3DLimit: Number = 2^23
      // Defines the maximum size of a CSS translation transform. The default
      // value should not be changed unless a web browser positions layers in
      // the wrong place after doing a large `panBy`.
      transform3DLimit: 8388608,
      // Precision limit of a 32-bit float
      // @section Interaction Options
      // @option zoomSnap: Number = 1
      // Forces the map's zoom level to always be a multiple of this, particularly
      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
      // By default, the zoom level snaps to the nearest integer; lower values
      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
      zoomSnap: 1,
      // @option zoomDelta: Number = 1
      // Controls how much the map's zoom level will change after a
      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
      zoomDelta: 1,
      // @option trackResize: Boolean = true
      // Whether the map automatically handles browser window resize to update itself.
      trackResize: true
    },
    initialize: function (id, options) {
      // (HTMLElement or String, Object)
      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,
      // to avoid inconsistent state in some edge cases.

      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = true;

      this._initContainer(id);

      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980


      this._onResize = bind(this._onResize, this);

      this._initEvents();

      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }

      if (options.zoom !== undefined) {
        this._zoom = this._limitZoom(options.zoom);
      }

      if (options.center && options.zoom !== undefined) {
        this.setView(toLatLng(options.center), options.zoom, {
          reset: true
        });
      }

      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera

      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events
      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally

      if (this._zoomAnimated) {
        this._createAnimProxy();

        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }

      this._addLayers(this.options.layers);
    },
    // @section Methods for modifying map state
    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) with the given
    // animation options.
    setView: function (center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
      options = options || {};

      this._stop();

      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = extend({
            animate: options.animate
          }, options.zoom);
          options.pan = extend({
            animate: options.animate,
            duration: options.duration
          }, options.pan);
        } // try animating pan or zoom


        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

        if (moved) {
          // prevent resize handler call, the view will refresh after animation anyway
          clearTimeout(this._sizeTimer);
          return this;
        }
      } // animation didn't start, just reset the map view


      this._resetView(center, zoom);

      return this;
    },
    // @method setZoom(zoom: Number, options?: Zoom/pan options): this
    // Sets the zoom of the map.
    setZoom: function (zoom, options) {
      if (!this._loaded) {
        this._zoom = zoom;
        return this;
      }

      return this.setView(this.getCenter(), zoom, {
        zoom: options
      });
    },
    // @method zoomIn(delta?: Number, options?: Zoom options): this
    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomIn: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    },
    // @method zoomOut(delta?: Number, options?: Zoom options): this
    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomOut: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    },
    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified geographical point on the map
    // stationary (e.g. used internally for scroll zoom and double-click zoom).
    // @alternative
    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
    setZoomAround: function (latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
          viewHalf = this.getSize().divideBy(2),
          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {
        zoom: options
      });
    },
    _getBoundsCenterZoom: function (bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

      if (zoom === Infinity) {
        return {
          center: bounds.getCenter(),
          zoom: zoom
        };
      }

      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
          swPoint = this.project(bounds.getSouthWest(), zoom),
          nePoint = this.project(bounds.getNorthEast(), zoom),
          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
      return {
        center: center,
        zoom: zoom
      };
    },
    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets a map view that contains the given geographical bounds with the
    // maximum zoom level possible.
    fitBounds: function (bounds, options) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        throw new Error('Bounds are not valid.');
      }

      var target = this._getBoundsCenterZoom(bounds, options);

      return this.setView(target.center, target.zoom, options);
    },
    // @method fitWorld(options?: fitBounds options): this
    // Sets a map view that mostly contains the whole world with the maximum
    // zoom level possible.
    fitWorld: function (options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    },
    // @method panTo(latlng: LatLng, options?: Pan options): this
    // Pans the map to a given center.
    panTo: function (center, options) {
      // (LatLng)
      return this.setView(center, this._zoom, {
        pan: options
      });
    },
    // @method panBy(offset: Point, options?: Pan options): this
    // Pans the map by a given number of pixels (animated).
    panBy: function (offset, options) {
      offset = toPoint(offset).round();
      options = options || {};

      if (!offset.x && !offset.y) {
        return this.fire('moveend');
      } // If we pan too far, Chrome gets issues with tiles
      // and makes them disappear or appear in the wrong place (slightly offset) #2602


      if (options.animate !== true && !this.getSize().contains(offset)) {
        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());

        return this;
      }

      if (!this._panAnim) {
        this._panAnim = new PosAnimation();

        this._panAnim.on({
          'step': this._onPanTransitionStep,
          'end': this._onPanTransitionEnd
        }, this);
      } // don't fire movestart if animating inertia


      if (!options.noMoveStart) {
        this.fire('movestart');
      } // animate pan unless animate: false specified


      if (options.animate !== false) {
        addClass(this._mapPane, 'leaflet-pan-anim');

        var newPos = this._getMapPanePos().subtract(offset).round();

        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
      } else {
        this._rawPanBy(offset);

        this.fire('move').fire('moveend');
      }

      return this;
    },
    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) performing a smooth
    // pan-zoom animation.
    flyTo: function (targetCenter, targetZoom, options) {
      options = options || {};

      if (options.animate === false || !any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }

      this._stop();

      var from = this.project(this.getCenter()),
          to = this.project(targetCenter),
          size = this.getSize(),
          startZoom = this._zoom;
      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === undefined ? startZoom : targetZoom;
      var w0 = Math.max(size.x, size.y),
          w1 = w0 * this.getZoomScale(startZoom, targetZoom),
          u1 = to.distanceTo(from) || 1,
          rho = 1.42,
          rho2 = rho * rho;

      function r(i) {
        var s1 = i ? -1 : 1,
            s2 = i ? w1 : w0,
            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
            b1 = 2 * s2 * rho2 * u1,
            b = t1 / b1,
            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,
        // thus triggering an infinite loop in flyTo

        var log = sq < 0.000000001 ? -18 : Math.log(sq);
        return log;
      }

      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }

      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }

      function tanh(n) {
        return sinh(n) / cosh(n);
      }

      var r0 = r(0);

      function w(s) {
        return w0 * (cosh(r0) / cosh(r0 + rho * s));
      }

      function u(s) {
        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
      }

      function easeOut(t) {
        return 1 - Math.pow(1 - t, 1.5);
      }

      var start = Date.now(),
          S = (r(1) - r0) / rho,
          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

      function frame() {
        var t = (Date.now() - start) / duration,
            s = easeOut(t) * S;

        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);

          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
            flyTo: true
          });
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(true);
        }
      }

      this._moveStart(true, options.noMoveStart);

      frame.call(this);
      return this;
    },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    flyToBounds: function (bounds, options) {
      var target = this._getBoundsCenterZoom(bounds, options);

      return this.flyTo(target.center, target.zoom, options);
    },
    // @method setMaxBounds(bounds: LatLngBounds): this
    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
    setMaxBounds: function (bounds) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        this.options.maxBounds = null;
        return this.off('moveend', this._panInsideMaxBounds);
      } else if (this.options.maxBounds) {
        this.off('moveend', this._panInsideMaxBounds);
      }

      this.options.maxBounds = bounds;

      if (this._loaded) {
        this._panInsideMaxBounds();
      }

      return this.on('moveend', this._panInsideMaxBounds);
    },
    // @method setMinZoom(zoom: Number): this
    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
    setMinZoom: function (zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method setMaxZoom(zoom: Number): this
    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
    setMaxZoom: function (zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
    panInsideBounds: function (bounds, options) {
      this._enforcingBounds = true;

      var center = this.getCenter(),
          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

      if (!center.equals(newCenter)) {
        this.panTo(newCenter, options);
      }

      this._enforcingBounds = false;
      return this;
    },
    // @method panInside(latlng: LatLng, options?: options): this
    // Pans the map the minimum amount to make the `latlng` visible. Use
    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
    // If `latlng` is already within the (optionally padded) display bounds,
    // the map will not be panned.
    panInside: function (latlng, options) {
      options = options || {};
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          center = this.getCenter(),
          pixelCenter = this.project(center),
          pixelPoint = this.project(latlng),
          pixelBounds = this.getPixelBounds(),
          halfPixelBounds = pixelBounds.getSize().divideBy(2),
          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        var diff = pixelCenter.subtract(pixelPoint),
            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
          newCenter.x = pixelCenter.x - diff.x;

          if (diff.x > 0) {
            newCenter.x += halfPixelBounds.x - paddingTL.x;
          } else {
            newCenter.x -= halfPixelBounds.x - paddingBR.x;
          }
        }

        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
          newCenter.y = pixelCenter.y - diff.y;

          if (diff.y > 0) {
            newCenter.y += halfPixelBounds.y - paddingTL.y;
          } else {
            newCenter.y -= halfPixelBounds.y - paddingBR.y;
          }
        }

        this.panTo(this.unproject(newCenter), options);
        this._enforcingBounds = false;
      }

      return this;
    },
    // @method invalidateSize(options: Zoom/pan options): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default. If `options.pan` is `false`, panning will not occur.
    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
    // that it doesn't happen often even if the method is called many
    // times in a row.
    // @alternative
    // @method invalidateSize(animate: Boolean): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default.
    invalidateSize: function (options) {
      if (!this._loaded) {
        return this;
      }

      options = extend({
        animate: false,
        pan: true
      }, options === true ? {
        animate: true
      } : options);
      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._lastCenter = null;
      var newSize = this.getSize(),
          oldCenter = oldSize.divideBy(2).round(),
          newCenter = newSize.divideBy(2).round(),
          offset = oldCenter.subtract(newCenter);

      if (!offset.x && !offset.y) {
        return this;
      }

      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }

        this.fire('move');

        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
        } else {
          this.fire('moveend');
        }
      } // @section Map state change events
      // @event resize: ResizeEvent
      // Fired when the map is resized.


      return this.fire('resize', {
        oldSize: oldSize,
        newSize: newSize
      });
    },
    // @section Methods for modifying map state
    // @method stop(): this
    // Stops the currently running `panTo` or `flyTo` animation, if any.
    stop: function () {
      this.setZoom(this._limitZoom(this._zoom));

      if (!this.options.zoomSnap) {
        this.fire('viewreset');
      }

      return this._stop();
    },
    // @section Geolocation methods
    // @method locate(options?: Locate options): this
    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
    // and optionally sets the map view to the user's location with respect to
    // detection accuracy (or to the world view if geolocation failed).
    // Note that, if your page doesn't use HTTPS, this method will fail in
    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
    // See `Locate options` for more details.
    locate: function (options) {
      options = this._locateOptions = extend({
        timeout: 10000,
        watch: false // setView: false
        // maxZoom: <Number>
        // maximumAge: 0
        // enableHighAccuracy: false

      }, options);

      if (!('geolocation' in navigator)) {
        this._handleGeolocationError({
          code: 0,
          message: 'Geolocation not supported.'
        });

        return this;
      }

      var onResponse = bind(this._handleGeolocationResponse, this),
          onError = bind(this._handleGeolocationError, this);

      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }

      return this;
    },
    // @method stopLocate(): this
    // Stops watching location previously initiated by `map.locate({watch: true})`
    // and aborts resetting the map view if map.locate was called with
    // `{setView: true}`.
    stopLocate: function () {
      if (navigator.geolocation && navigator.geolocation.clearWatch) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }

      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }

      return this;
    },
    _handleGeolocationError: function (error) {
      var c = error.code,
          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      } // @section Location events
      // @event locationerror: ErrorEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.


      this.fire('locationerror', {
        code: c,
        message: 'Geolocation error: ' + message + '.'
      });
    },
    _handleGeolocationResponse: function (pos) {
      var lat = pos.coords.latitude,
          lng = pos.coords.longitude,
          latlng = new LatLng(lat, lng),
          bounds = latlng.toBounds(pos.coords.accuracy * 2),
          options = this._locateOptions;

      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
      }

      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp
      };

      for (var i in pos.coords) {
        if (typeof pos.coords[i] === 'number') {
          data[i] = pos.coords[i];
        }
      } // @event locationfound: LocationEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method)
      // went successfully.


      this.fire('locationfound', data);
    },
    // TODO Appropriate docs section?
    // @section Other Methods
    // @method addHandler(name: String, HandlerClass: Function): this
    // Adds a new `Handler` to the map, given its name and constructor function.
    addHandler: function (name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }

      var handler = this[name] = new HandlerClass(this);

      this._handlers.push(handler);

      if (this.options[name]) {
        handler.enable();
      }

      return this;
    },
    // @method remove(): this
    // Destroys the map and clears all related event listeners.
    remove: function () {
      this._initEvents(true);

      this.off('moveend', this._panInsideMaxBounds);

      if (this._containerId !== this._container._leaflet_id) {
        throw new Error('Map container is being reused by another instance');
      }

      try {
        // throws error in IE6-8
        delete this._container._leaflet_id;
        delete this._containerId;
      } catch (e) {
        /*eslint-disable */
        this._container._leaflet_id = undefined;
        /* eslint-enable */

        this._containerId = undefined;
      }

      if (this._locationWatchId !== undefined) {
        this.stopLocate();
      }

      this._stop();

      remove(this._mapPane);

      if (this._clearControlPos) {
        this._clearControlPos();
      }

      if (this._resizeRequest) {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = null;
      }

      this._clearHandlers();

      if (this._loaded) {
        // @section Map state change events
        // @event unload: Event
        // Fired when the map is destroyed with [remove](#map-remove) method.
        this.fire('unload');
      }

      var i;

      for (i in this._layers) {
        this._layers[i].remove();
      }

      for (i in this._panes) {
        remove(this._panes[i]);
      }

      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;
      return this;
    },
    // @section Other Methods
    // @method createPane(name: String, container?: HTMLElement): HTMLElement
    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
    // then returns it. The pane is created as a child of `container`, or
    // as a child of the main map pane if not set.
    createPane: function (name, container) {
      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
          pane = create$1('div', className, container || this._mapPane);

      if (name) {
        this._panes[name] = pane;
      }

      return pane;
    },
    // @section Methods for Getting Map State
    // @method getCenter(): LatLng
    // Returns the geographical center of the map view
    getCenter: function () {
      this._checkIfLoaded();

      if (this._lastCenter && !this._moved()) {
        return this._lastCenter;
      }

      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },
    // @method getZoom(): Number
    // Returns the current zoom level of the map view
    getZoom: function () {
      return this._zoom;
    },
    // @method getBounds(): LatLngBounds
    // Returns the geographical bounds visible in the current map view
    getBounds: function () {
      var bounds = this.getPixelBounds(),
          sw = this.unproject(bounds.getBottomLeft()),
          ne = this.unproject(bounds.getTopRight());
      return new LatLngBounds(sw, ne);
    },
    // @method getMinZoom(): Number
    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
    getMinZoom: function () {
      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
    },
    // @method getMaxZoom(): Number
    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
    getMaxZoom: function () {
      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
    },
    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
    // Returns the maximum zoom level on which the given bounds fit to the map
    // view in its entirety. If `inside` (optional) is set to `true`, the method
    // instead returns the minimum zoom level on which the map view fits into
    // the given bounds in its entirety.
    getBoundsZoom: function (bounds, inside, padding) {
      // (LatLngBounds[, Boolean, Point]) -> Number
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);
      var zoom = this.getZoom() || 0,
          min = this.getMinZoom(),
          max = this.getMaxZoom(),
          nw = bounds.getNorthWest(),
          se = bounds.getSouthEast(),
          size = this.getSize().subtract(padding),
          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
          snap = any3d ? this.options.zoomSnap : 1,
          scalex = size.x / boundsSize.x,
          scaley = size.y / boundsSize.y,
          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
      zoom = this.getScaleZoom(scale, zoom);

      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level

        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    // @method getSize(): Point
    // Returns the current size of the map container (in pixels).
    getSize: function () {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
        this._sizeChanged = false;
      }

      return this._size.clone();
    },
    // @method getPixelBounds(): Bounds
    // Returns the bounds of the current map view in projected pixel
    // coordinates (sometimes useful in layer and overlay implementations).
    getPixelBounds: function (center, zoom) {
      var topLeftPoint = this._getTopLeftPoint(center, zoom);

      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },
    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
    // the map pane? "left point of the map layer" can be confusing, specially
    // since there can be negative offsets.
    // @method getPixelOrigin(): Point
    // Returns the projected pixel coordinates of the top left point of
    // the map layer (useful in custom layer and overlay implementations).
    getPixelOrigin: function () {
      this._checkIfLoaded();

      return this._pixelOrigin;
    },
    // @method getPixelWorldBounds(zoom?: Number): Bounds
    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
    // If `zoom` is omitted, the map's current zoom level is used.
    getPixelWorldBounds: function (zoom) {
      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
    },
    // @section Other Methods
    // @method getPane(pane: String|HTMLElement): HTMLElement
    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
    getPane: function (pane) {
      return typeof pane === 'string' ? this._panes[pane] : pane;
    },
    // @method getPanes(): Object
    // Returns a plain object containing the names of all [panes](#map-pane) as keys and
    // the panes as values.
    getPanes: function () {
      return this._panes;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the map.
    getContainer: function () {
      return this._container;
    },
    // @section Conversion Methods
    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
    // Returns the scale factor to be applied to a map transition from zoom level
    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
    getZoomScale: function (toZoom, fromZoom) {
      // TODO replace with universal implementation after refactoring projections
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    },
    // @method getScaleZoom(scale: Number, fromZoom: Number): Number
    // Returns the zoom level that the map would end up at, if it is at `fromZoom`
    // level and everything is scaled by a factor of `scale`. Inverse of
    // [`getZoomScale`](#map-getZoomScale).
    getScaleZoom: function (scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      var zoom = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    },
    // @method project(latlng: LatLng, zoom: Number): Point
    // Projects a geographical coordinate `LatLng` according to the projection
    // of the map's CRS, then scales it according to `zoom` and the CRS's
    // `Transformation`. The result is pixel coordinate relative to
    // the CRS origin.
    project: function (latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    },
    // @method unproject(point: Point, zoom: Number): LatLng
    // Inverse of [`project`](#map-project).
    unproject: function (point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    },
    // @method layerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding geographical coordinate (for the current zoom level).
    layerPointToLatLng: function (point) {
      var projectedPoint = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },
    // @method latLngToLayerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the [origin pixel](#map-getpixelorigin).
    latLngToLayerPoint: function (latlng) {
      var projectedPoint = this.project(toLatLng(latlng))._round();

      return projectedPoint._subtract(this.getPixelOrigin());
    },
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
    // CRS's bounds.
    // By default this means longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees.
    wrapLatLng: function (latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring that
    // its center is within the CRS's bounds.
    // By default this means the center longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees, and the majority of the bounds
    // overlaps the CRS's bounds.
    wrapLatLngBounds: function (latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates according to
    // the map's CRS. By default this measures distance in meters.
    distance: function (latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    },
    // @method containerPointToLayerPoint(point: Point): Point
    // Given a pixel coordinate relative to the map container, returns the corresponding
    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
    containerPointToLayerPoint: function (point) {
      // (Point)
      return toPoint(point).subtract(this._getMapPanePos());
    },
    // @method layerPointToContainerPoint(point: Point): Point
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding pixel coordinate relative to the map container.
    layerPointToContainerPoint: function (point) {
      // (Point)
      return toPoint(point).add(this._getMapPanePos());
    },
    // @method containerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the map container, returns
    // the corresponding geographical coordinate (for the current zoom level).
    containerPointToLatLng: function (point) {
      var layerPoint = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(layerPoint);
    },
    // @method latLngToContainerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the map container.
    latLngToContainerPoint: function (latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    },
    // @method mouseEventToContainerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to the
    // map container where the event took place.
    mouseEventToContainerPoint: function (e) {
      return getMousePosition(e, this._container);
    },
    // @method mouseEventToLayerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to
    // the [origin pixel](#map-getpixelorigin) where the event took place.
    mouseEventToLayerPoint: function (e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    },
    // @method mouseEventToLatLng(ev: MouseEvent): LatLng
    // Given a MouseEvent object, returns geographical coordinate where the
    // event took place.
    mouseEventToLatLng: function (e) {
      // (MouseEvent)
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },
    // map initialization methods
    _initContainer: function (id) {
      var container = this._container = get(id);

      if (!container) {
        throw new Error('Map container not found.');
      } else if (container._leaflet_id) {
        throw new Error('Map container is already initialized.');
      }

      on(container, 'scroll', this._onScroll, this);
      this._containerId = stamp(container);
    },
    _initLayout: function () {
      var container = this._container;
      this._fadeAnimated = this.options.fadeAnimation && any3d;
      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));
      var position = getStyle(container, 'position');

      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        container.style.position = 'relative';
      }

      this._initPanes();

      if (this._initControlPos) {
        this._initControlPos();
      }
    },
    _initPanes: function () {
      var panes = this._panes = {};
      this._paneRenderers = {}; // @section
      //
      // Panes are DOM elements used to control the ordering of layers on the map. You
      // can access panes with [`map.getPane`](#map-getpane) or
      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
      // [`map.createPane`](#map-createpane) method.
      //
      // Every map has the following default panes that differ only in zIndex.
      //
      // @pane mapPane: HTMLElement = 'auto'
      // Pane that contains all other map panes

      this._mapPane = this.createPane('mapPane', this._container);
      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200
      // Pane for `GridLayer`s and `TileLayer`s

      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400
      // Pane for overlay shadows (e.g. `Marker` shadows)

      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500
      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s

      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600
      // Pane for `Icon`s of `Marker`s

      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650
      // Pane for `Tooltip`s.

      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700
      // Pane for `Popup`s.

      this.createPane('popupPane');

      if (!this.options.markerZoomAnimation) {
        addClass(panes.markerPane, 'leaflet-zoom-hide');
        addClass(panes.shadowPane, 'leaflet-zoom-hide');
      }
    },
    // private methods that modify map state
    // @section Map state change events
    _resetView: function (center, zoom) {
      setPosition(this._mapPane, new Point(0, 0));
      var loading = !this._loaded;
      this._loaded = true;
      zoom = this._limitZoom(zoom);
      this.fire('viewprereset');
      var zoomChanged = this._zoom !== zoom;

      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event
      // Fired when the map needs to redraw its content (this usually happens
      // on map zoom or load). Very useful for creating custom overlays.


      this.fire('viewreset'); // @event load: Event
      // Fired when the map is initialized (when its center and zoom are set
      // for the first time).

      if (loading) {
        this.fire('load');
      }
    },
    _moveStart: function (zoomChanged, noMoveStart) {
      // @event zoomstart: Event
      // Fired when the map zoom is about to change (e.g. before zoom animation).
      // @event movestart: Event
      // Fired when the view of the map starts changing (e.g. user starts dragging the map).
      if (zoomChanged) {
        this.fire('zoomstart');
      }

      if (!noMoveStart) {
        this.fire('movestart');
      }

      return this;
    },
    _move: function (center, zoom, data) {
      if (zoom === undefined) {
        zoom = this._zoom;
      }

      var zoomChanged = this._zoom !== zoom;
      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event
      // Fired repeatedly during any change in zoom level, including zoom
      // and fly animations.

      if (zoomChanged || data && data.pinch) {
        // Always fire 'zoom' if pinching because #3530
        this.fire('zoom', data);
      } // @event move: Event
      // Fired repeatedly during any movement of the map, including pan and
      // fly animations.


      return this.fire('move', data);
    },
    _moveEnd: function (zoomChanged) {
      // @event zoomend: Event
      // Fired when the map has changed, after any animations.
      if (zoomChanged) {
        this.fire('zoomend');
      } // @event moveend: Event
      // Fired when the center of the map stops changing (e.g. user stopped
      // dragging the map).


      return this.fire('moveend');
    },
    _stop: function () {
      cancelAnimFrame(this._flyToFrame);

      if (this._panAnim) {
        this._panAnim.stop();
      }

      return this;
    },
    _rawPanBy: function (offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },
    _getZoomSpan: function () {
      return this.getMaxZoom() - this.getMinZoom();
    },
    _panInsideMaxBounds: function () {
      if (!this._enforcingBounds) {
        this.panInsideBounds(this.options.maxBounds);
      }
    },
    _checkIfLoaded: function () {
      if (!this._loaded) {
        throw new Error('Set map center and zoom first.');
      }
    },
    // DOM event handling
    // @section Interaction events
    _initEvents: function (remove$$1) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;
      var onOff = remove$$1 ? off : on; // @event click: MouseEvent
      // Fired when the user clicks (or taps) the map.
      // @event dblclick: MouseEvent
      // Fired when the user double-clicks (or double-taps) the map.
      // @event mousedown: MouseEvent
      // Fired when the user pushes the mouse button on the map.
      // @event mouseup: MouseEvent
      // Fired when the user releases the mouse button on the map.
      // @event mouseover: MouseEvent
      // Fired when the mouse enters the map.
      // @event mouseout: MouseEvent
      // Fired when the mouse leaves the map.
      // @event mousemove: MouseEvent
      // Fired while the mouse moves over the map.
      // @event contextmenu: MouseEvent
      // Fired when the user pushes the right mouse button on the map, prevents
      // default browser context menu from showing if there are listeners on
      // this event. Also fired on mobile when the user holds a single touch
      // for a second (also called long press).
      // @event keypress: KeyboardEvent
      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
      // @event keydown: KeyboardEvent
      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
      // the `keydown` event is fired for keys that produce a character value and for keys
      // that do not produce a character value.
      // @event keyup: KeyboardEvent
      // Fired when the user releases a key from the keyboard while the map is focused.

      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

      if (this.options.trackResize) {
        onOff(window, 'resize', this._onResize, this);
      }

      if (any3d && this.options.transform3DLimit) {
        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
      }
    },
    _onResize: function () {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function () {
        this.invalidateSize({
          debounceMoveend: true
        });
      }, this);
    },
    _onScroll: function () {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    },
    _onMoveEnd: function () {
      var pos = this._getMapPanePos();

      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
        this._resetView(this.getCenter(), this.getZoom());
      }
    },
    _findEventTargets: function (e, type) {
      var targets = [],
          target,
          isHover = type === 'mouseout' || type === 'mouseover',
          src = e.target || e.srcElement,
          dragging = false;

      while (src) {
        target = this._targets[stamp(src)];

        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
          // Prevent firing click after you just dragged an object.
          dragging = true;
          break;
        }

        if (target && target.listens(type, true)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }

          targets.push(target);

          if (isHover) {
            break;
          }
        }

        if (src === this._container) {
          break;
        }

        src = src.parentNode;
      }

      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
        targets = [this];
      }

      return targets;
    },
    _handleDOMEvent: function (e) {
      if (!this._loaded || skipped(e)) {
        return;
      }

      var type = e.type;

      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
        // prevents outline when clicking on keyboard-focusable element
        preventOutline(e.target || e.srcElement);
      }

      this._fireDOMEvent(e, type);
    },
    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
    _fireDOMEvent: function (e, type, targets) {
      if (e.type === 'click') {
        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
        // @event preclick: MouseEvent
        // Fired before mouse click on the map (sometimes useful when you
        // want something to happen on click before any existing click
        // handlers start running).
        var synth = extend({}, e);
        synth.type = 'preclick';

        this._fireDOMEvent(synth, synth.type, targets);
      }

      if (e._stopped) {
        return;
      } // Find the layer the event is propagating from and its parents.


      targets = (targets || []).concat(this._findEventTargets(e, type));

      if (!targets.length) {
        return;
      }

      var target = targets[0];

      if (type === 'contextmenu' && target.listens(type, true)) {
        preventDefault(e);
      }

      var data = {
        originalEvent: e
      };

      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
      }

      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(type, data, true);

        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
          return;
        }
      }
    },
    _draggableMoved: function (obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
    },
    _clearHandlers: function () {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },
    // @section Other Methods
    // @method whenReady(fn: Function, context?: Object): this
    // Runs the given function `fn` when the map gets initialized with
    // a view (center and zoom) and at least one layer, or immediately
    // if it's already initialized, optionally passing a function context.
    whenReady: function (callback, context) {
      if (this._loaded) {
        callback.call(context || this, {
          target: this
        });
      } else {
        this.on('load', callback, context);
      }

      return this;
    },
    // private methods for getting map state
    _getMapPanePos: function () {
      return getPosition(this._mapPane) || new Point(0, 0);
    },
    _moved: function () {
      var pos = this._getMapPanePos();

      return pos && !pos.equals([0, 0]);
    },
    _getTopLeftPoint: function (center, zoom) {
      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
      return pixelOrigin.subtract(this._getMapPanePos());
    },
    _getNewPixelOrigin: function (center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);

      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
    },
    _latLngToNewLayerPoint: function (latlng, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return this.project(latlng, zoom)._subtract(topLeft);
    },
    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
    },
    // layer point of the current center
    _getCenterLayerPoint: function () {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },
    // offset of the specified place to the current center in pixels
    _getCenterOffset: function (latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    },
    // adjust center for view to get inside bounds
    _limitCenter: function (center, zoom, bounds) {
      if (!bounds) {
        return center;
      }

      var centerPoint = this.project(center, zoom),
          viewHalf = this.getSize().divideBy(2),
          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.
      // This prevents unstable projections from getting into
      // an infinite loop of tiny offsets.


      if (offset.round().equals([0, 0])) {
        return center;
      }

      return this.unproject(centerPoint.add(offset), zoom);
    },
    // adjust offset for view to get inside bounds
    _limitOffset: function (offset, bounds) {
      if (!bounds) {
        return offset;
      }

      var viewBounds = this.getPixelBounds(),
          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },
    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
          dx = this._rebound(minOffset.x, -maxOffset.x),
          dy = this._rebound(minOffset.y, -maxOffset.y);

      return new Point(dx, dy);
    },
    _rebound: function (left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },
    _limitZoom: function (zoom) {
      var min = this.getMinZoom(),
          max = this.getMaxZoom(),
          snap = any3d ? this.options.zoomSnap : 1;

      if (snap) {
        zoom = Math.round(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    _onPanTransitionStep: function () {
      this.fire('move');
    },
    _onPanTransitionEnd: function () {
      removeClass(this._mapPane, 'leaflet-pan-anim');
      this.fire('moveend');
    },
    _tryAnimatedPan: function (center, options) {
      // difference between the new and current centers in pixels
      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options


      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
        return false;
      }

      this.panBy(offset, options);
      return true;
    },
    _createAnimProxy: function () {
      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');

      this._panes.mapPane.appendChild(proxy);

      this.on('zoomanim', function (e) {
        var prop = TRANSFORM,
            transform = this._proxy.style[prop];
        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired

        if (transform === this._proxy.style[prop] && this._animatingZoom) {
          this._onZoomTransitionEnd();
        }
      }, this);
      this.on('load moveend', this._animMoveEnd, this);

      this._on('unload', this._destroyAnimProxy, this);
    },
    _destroyAnimProxy: function () {
      remove(this._proxy);
      this.off('load moveend', this._animMoveEnd, this);
      delete this._proxy;
    },
    _animMoveEnd: function () {
      var c = this.getCenter(),
          z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    },
    _catchTransitionEnd: function (e) {
      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
        this._onZoomTransitionEnd();
      }
    },
    _nothingToAnimate: function () {
      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
    },
    _tryAnimatedZoom: function (center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }

      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large

      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return false;
      } // offset is the pixel coords of the zoom origin relative to the current center


      var scale = this.getZoomScale(zoom),
          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced


      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }

      requestAnimFrame(function () {
        this._moveStart(true, false)._animateZoom(center, zoom, true);
      }, this);
      return true;
    },
    _animateZoom: function (center, zoom, startAnim, noUpdate) {
      if (!this._mapPane) {
        return;
      }

      if (startAnim) {
        this._animatingZoom = true; // remember what center/zoom to set after animation

        this._animateToCenter = center;
        this._animateToZoom = zoom;
        addClass(this._mapPane, 'leaflet-zoom-anim');
      } // @section Other Events
      // @event zoomanim: ZoomAnimEvent
      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.


      this.fire('zoomanim', {
        center: center,
        zoom: zoom,
        noUpdate: noUpdate
      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693

      setTimeout(bind(this._onZoomTransitionEnd, this), 250);
    },
    _onZoomTransitionEnd: function () {
      if (!this._animatingZoom) {
        return;
      }

      if (this._mapPane) {
        removeClass(this._mapPane, 'leaflet-zoom-anim');
      }

      this._animatingZoom = false;

      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.


      requestAnimFrame(function () {
        this._moveEnd(true);
      }, this);
    }
  }); // @section
  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.

  function createMap(id, options) {
    return new Map(id, options);
  }
  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */


  var Control = Class.extend({
    // @section
    // @aka Control options
    options: {
      // @option position: String = 'topright'
      // The position of the control (one of the map corners). Possible values are `'topleft'`,
      // `'topright'`, `'bottomleft'` or `'bottomright'`
      position: 'topright'
    },
    initialize: function (options) {
      setOptions(this, options);
    },

    /* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
    getPosition: function () {
      return this.options.position;
    },
    // @method setPosition(position: string): this
    // Sets the position of the control.
    setPosition: function (position) {
      var map = this._map;

      if (map) {
        map.removeControl(this);
      }

      this.options.position = position;

      if (map) {
        map.addControl(this);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTMLElement that contains the control.
    getContainer: function () {
      return this._container;
    },
    // @method addTo(map: Map): this
    // Adds the control to the given map.
    addTo: function (map) {
      this.remove();
      this._map = map;
      var container = this._container = this.onAdd(map),
          pos = this.getPosition(),
          corner = map._controlCorners[pos];
      addClass(container, 'leaflet-control');

      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }

      this._map.on('unload', this.remove, this);

      return this;
    },
    // @method remove: this
    // Removes the control from the map it is currently active on.
    remove: function () {
      if (!this._map) {
        return this;
      }

      remove(this._container);

      if (this.onRemove) {
        this.onRemove(this._map);
      }

      this._map.off('unload', this.remove, this);

      this._map = null;
      return this;
    },
    _refocusOnMap: function (e) {
      // if map exists and event is not a keyboard event
      if (this._map && e && e.screenX > 0 && e.screenY > 0) {
        this._map.getContainer().focus();
      }
    }
  });

  var control = function (options) {
    return new Control(options);
  };
  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */


  Map.include({
    // @method addControl(control: Control): this
    // Adds the given control to the map
    addControl: function (control) {
      control.addTo(this);
      return this;
    },
    // @method removeControl(control: Control): this
    // Removes the given control from the map
    removeControl: function (control) {
      control.remove();
      return this;
    },
    _initControlPos: function () {
      var corners = this._controlCorners = {},
          l = 'leaflet-',
          container = this._controlContainer = create$1('div', l + 'control-container', this._container);

      function createCorner(vSide, hSide) {
        var className = l + vSide + ' ' + l + hSide;
        corners[vSide + hSide] = create$1('div', className, container);
      }

      createCorner('top', 'left');
      createCorner('top', 'right');
      createCorner('bottom', 'left');
      createCorner('bottom', 'right');
    },
    _clearControlPos: function () {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }

      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    }
  });
  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
      // @option collapsed: Boolean = true
      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
      collapsed: true,
      position: 'topright',
      // @option autoZIndex: Boolean = true
      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
      autoZIndex: true,
      // @option hideSingleBase: Boolean = false
      // If `true`, the base layers in the control will be hidden when there is only one.
      hideSingleBase: false,
      // @option sortLayers: Boolean = false
      // Whether to sort the layers. When `false`, layers will keep the order
      // in which they were added to the control.
      sortLayers: false,
      // @option sortFunction: Function = *
      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
      // that will be used for sorting the layers, when `sortLayers` is `true`.
      // The function receives both the `L.Layer` instances and their names, as in
      // `sortFunction(layerA, layerB, nameA, nameB)`.
      // By default, it sorts layers alphabetically by their name.
      sortFunction: function (layerA, layerB, nameA, nameB) {
        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
      }
    },
    initialize: function (baseLayers, overlays, options) {
      setOptions(this, options);
      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._handlingClick = false;

      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }

      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },
    onAdd: function (map) {
      this._initLayout();

      this._update();

      this._map = map;
      map.on('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.on('add remove', this._onLayerChange, this);
      }

      return this._container;
    },
    addTo: function (map) {
      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.

      return this._expandIfNotCollapsed();
    },
    onRemove: function () {
      this._map.off('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off('add remove', this._onLayerChange, this);
      }
    },
    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
      this._addLayer(layer, name);

      return this._map ? this._update() : this;
    },
    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
      this._addLayer(layer, name, true);

      return this._map ? this._update() : this;
    },
    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
      layer.off('add remove', this._onLayerChange, this);

      var obj = this._getLayer(stamp(layer));

      if (obj) {
        this._layers.splice(this._layers.indexOf(obj), 1);
      }

      return this._map ? this._update() : this;
    },
    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
      addClass(this._container, 'leaflet-control-layers-expanded');
      this._section.style.height = null;
      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);

      if (acceptableHeight < this._section.clientHeight) {
        addClass(this._section, 'leaflet-control-layers-scrollbar');
        this._section.style.height = acceptableHeight + 'px';
      } else {
        removeClass(this._section, 'leaflet-control-layers-scrollbar');
      }

      this._checkDisabledLayers();

      return this;
    },
    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
      removeClass(this._container, 'leaflet-control-layers-expanded');
      return this;
    },
    _initLayout: function () {
      var className = 'leaflet-control-layers',
          container = this._container = create$1('div', className),
          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released

      container.setAttribute('aria-haspopup', true);
      disableClickPropagation(container);
      disableScrollPropagation(container);
      var section = this._section = create$1('section', className + '-list');

      if (collapsed) {
        this._map.on('click', this.collapse, this);

        if (!android) {
          on(container, {
            mouseenter: this.expand,
            mouseleave: this.collapse
          }, this);
        }
      }

      var link = this._layersLink = create$1('a', className + '-toggle', container);
      link.href = '#';
      link.title = 'Layers';

      if (touch) {
        on(link, 'click', stop);
        on(link, 'click', this.expand, this);
      } else {
        on(link, 'focus', this.expand, this);
      }

      if (!collapsed) {
        this.expand();
      }

      this._baseLayersList = create$1('div', className + '-base', section);
      this._separator = create$1('div', className + '-separator', section);
      this._overlaysList = create$1('div', className + '-overlays', section);
      container.appendChild(section);
    },
    _getLayer: function (id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    },
    _addLayer: function (layer, name, overlay) {
      if (this._map) {
        layer.on('add remove', this._onLayerChange, this);
      }

      this._layers.push({
        layer: layer,
        name: name,
        overlay: overlay
      });

      if (this.options.sortLayers) {
        this._layers.sort(bind(function (a, b) {
          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
        }, this));
      }

      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }

      this._expandIfNotCollapsed();
    },
    _update: function () {
      if (!this._container) {
        return this;
      }

      empty(this._baseLayersList);
      empty(this._overlaysList);
      this._layerControlInputs = [];
      var baseLayersPresent,
          overlaysPresent,
          i,
          obj,
          baseLayersCount = 0;

      for (i = 0; i < this._layers.length; i++) {
        obj = this._layers[i];

        this._addItem(obj);

        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      } // Hide base layers section if there's only one layer.


      if (this.options.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
      }

      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
      return this;
    },
    _onLayerChange: function (e) {
      if (!this._handlingClick) {
        this._update();
      }

      var obj = this._getLayer(stamp(e.target)); // @namespace Map
      // @section Layer events
      // @event baselayerchange: LayersControlEvent
      // Fired when the base layer is changed through the [layers control](#control-layers).
      // @event overlayadd: LayersControlEvent
      // Fired when an overlay is selected through the [layers control](#control-layers).
      // @event overlayremove: LayersControlEvent
      // Fired when an overlay is deselected through the [layers control](#control-layers).
      // @namespace Control.Layers


      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

      if (type) {
        this._map.fire(type, obj);
      }
    },
    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
    _createRadioElement: function (name, checked) {
      var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    },
    _addItem: function (obj) {
      var label = document.createElement('label'),
          checked = this._map.hasLayer(obj.layer),
          input;

      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'leaflet-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
      }

      this._layerControlInputs.push(input);

      input.layerId = stamp(obj.layer);
      on(input, 'click', this._onInputClick, this);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled
      // https://github.com/Leaflet/Leaflet/issues/2771

      var holder = document.createElement('div');
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);
      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);

      this._checkDisabledLayers();

      return label;
    },
    _onInputClick: function () {
      var inputs = this._layerControlInputs,
          input,
          layer;
      var addedLayers = [],
          removedLayers = [];
      this._handlingClick = true;

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;

        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      } // Bugfix issue 2318: Should remove all old layers before readding new ones


      for (i = 0; i < removedLayers.length; i++) {
        if (this._map.hasLayer(removedLayers[i])) {
          this._map.removeLayer(removedLayers[i]);
        }
      }

      for (i = 0; i < addedLayers.length; i++) {
        if (!this._map.hasLayer(addedLayers[i])) {
          this._map.addLayer(addedLayers[i]);
        }
      }

      this._handlingClick = false;

      this._refocusOnMap();
    },
    _checkDisabledLayers: function () {
      var inputs = this._layerControlInputs,
          input,
          layer,
          zoom = this._map.getZoom();

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
      }
    },
    _expandIfNotCollapsed: function () {
      if (this._map && !this.options.collapsed) {
        this.expand();
      }

      return this;
    },
    _expand: function () {
      // Backward compatibility, remove me in 1.1.
      return this.expand();
    },
    _collapse: function () {
      // Backward compatibility, remove me in 1.1.
      return this.collapse();
    }
  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.

  var layers = function (baseLayers, overlays, options) {
    return new Layers(baseLayers, overlays, options);
  };
  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */


  var Zoom = Control.extend({
    // @section
    // @aka Control.Zoom options
    options: {
      position: 'topleft',
      // @option zoomInText: String = '+'
      // The text set on the 'zoom in' button.
      zoomInText: '+',
      // @option zoomInTitle: String = 'Zoom in'
      // The title set on the 'zoom in' button.
      zoomInTitle: 'Zoom in',
      // @option zoomOutText: String = '&#x2212;'
      // The text set on the 'zoom out' button.
      zoomOutText: '&#x2212;',
      // @option zoomOutTitle: String = 'Zoom out'
      // The title set on the 'zoom out' button.
      zoomOutTitle: 'Zoom out'
    },
    onAdd: function (map) {
      var zoomName = 'leaflet-control-zoom',
          container = create$1('div', zoomName + ' leaflet-bar'),
          options = this.options;
      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

      this._updateDisabled();

      map.on('zoomend zoomlevelschange', this._updateDisabled, this);
      return container;
    },
    onRemove: function (map) {
      map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    disable: function () {
      this._disabled = true;

      this._updateDisabled();

      return this;
    },
    enable: function () {
      this._disabled = false;

      this._updateDisabled();

      return this;
    },
    _zoomIn: function (e) {
      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _zoomOut: function (e) {
      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _createButton: function (html, title, className, container, fn) {
      var link = create$1('a', className, container);
      link.innerHTML = html;
      link.href = '#';
      link.title = title;
      /*
       * Will force screen readers like VoiceOver to read this as "Zoom in - button"
       */

      link.setAttribute('role', 'button');
      link.setAttribute('aria-label', title);
      disableClickPropagation(link);
      on(link, 'click', stop);
      on(link, 'click', fn, this);
      on(link, 'click', this._refocusOnMap, this);
      return link;
    },
    _updateDisabled: function () {
      var map = this._map,
          className = 'leaflet-disabled';
      removeClass(this._zoomInButton, className);
      removeClass(this._zoomOutButton, className);

      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, className);
      }

      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, className);
      }
    }
  }); // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.

  Map.mergeOptions({
    zoomControl: true
  });
  Map.addInitHook(function () {
    if (this.options.zoomControl) {
      // @section Controls
      // @property zoomControl: Control.Zoom
      // The default zoom control (only available if the
      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
      this.zoomControl = new Zoom();
      this.addControl(this.zoomControl);
    }
  }); // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control

  var zoom = function (options) {
    return new Zoom(options);
  };
  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */


  var Scale = Control.extend({
    // @section
    // @aka Control.Scale options
    options: {
      position: 'bottomleft',
      // @option maxWidth: Number = 100
      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
      maxWidth: 100,
      // @option metric: Boolean = True
      // Whether to show the metric scale line (m/km).
      metric: true,
      // @option imperial: Boolean = True
      // Whether to show the imperial scale line (mi/ft).
      imperial: true // @option updateWhenIdle: Boolean = false
      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).

    },
    onAdd: function (map) {
      var className = 'leaflet-control-scale',
          container = create$1('div', className),
          options = this.options;

      this._addScales(options, className + '-line', container);

      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
      map.whenReady(this._update, this);
      return container;
    },
    onRemove: function (map) {
      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
    },
    _addScales: function (options, className, container) {
      if (options.metric) {
        this._mScale = create$1('div', className, container);
      }

      if (options.imperial) {
        this._iScale = create$1('div', className, container);
      }
    },
    _update: function () {
      var map = this._map,
          y = map.getSize().y / 2;
      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

      this._updateScales(maxMeters);
    },
    _updateScales: function (maxMeters) {
      if (this.options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }

      if (this.options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters),
          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

      this._updateScale(this._mScale, label, meters / maxMeters);
    },
    _updateImperial: function (maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
          maxMiles,
          miles,
          feet;

      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);

        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
      } else {
        feet = this._getRoundNum(maxFeet);

        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
      }
    },
    _updateScale: function (scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
      scale.innerHTML = text;
    },
    _getRoundNum: function (num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
          d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  }); // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.

  var scale = function (options) {
    return new Scale(options);
  };
  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */


  var Attribution = Control.extend({
    // @section
    // @aka Control.Attribution options
    options: {
      position: 'bottomright',
      // @option prefix: String = 'Leaflet'
      // The HTML text shown before the attributions. Pass `false` to disable.
      prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
    },
    initialize: function (options) {
      setOptions(this, options);
      this._attributions = {};
    },
    onAdd: function (map) {
      map.attributionControl = this;
      this._container = create$1('div', 'leaflet-control-attribution');
      disableClickPropagation(this._container); // TODO ugly, refactor

      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }

      this._update();

      return this._container;
    },
    // @method setPrefix(prefix: String): this
    // Sets the text before the attributions.
    setPrefix: function (prefix) {
      this.options.prefix = prefix;

      this._update();

      return this;
    },
    // @method addAttribution(text: String): this
    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
    addAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }

      this._attributions[text]++;

      this._update();

      return this;
    },
    // @method removeAttribution(text: String): this
    // Removes an attribution text.
    removeAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (this._attributions[text]) {
        this._attributions[text]--;

        this._update();
      }

      return this;
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      var attribs = [];

      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }

      var prefixAndAttribs = [];

      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }

      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(', '));
      }

      this._container.innerHTML = prefixAndAttribs.join(' | ');
    }
  }); // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.

  Map.mergeOptions({
    attributionControl: true
  });
  Map.addInitHook(function () {
    if (this.options.attributionControl) {
      new Attribution().addTo(this);
    }
  }); // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.

  var attribution = function (options) {
    return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;
  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;
  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */
  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
    initialize: function (map) {
      this._map = map;
    },
    // @method enable(): this
    // Enables the handler
    enable: function () {
      if (this._enabled) {
        return this;
      }

      this._enabled = true;
      this.addHooks();
      return this;
    },
    // @method disable(): this
    // Disables the handler
    disable: function () {
      if (!this._enabled) {
        return this;
      }

      this._enabled = false;
      this.removeHooks();
      return this;
    },
    // @method enabled(): Boolean
    // Returns `true` if the handler is enabled
    enabled: function () {
      return !!this._enabled;
    } // @section Extension methods
    // Classes inheriting from `Handler` must implement the two following methods:
    // @method addHooks()
    // Called when the handler is enabled, should add event hooks.
    // @method removeHooks()
    // Called when the handler is disabled, should remove the event hooks added previously.

  }); // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.

  Handler.addTo = function (map, name) {
    map.addHandler(name, this);
    return this;
  };

  var Mixin = {
    Events: Events
  };
  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = touch ? 'touchstart mousedown' : 'mousedown';
  var END = {
    mousedown: 'mouseup',
    touchstart: 'touchend',
    pointerdown: 'touchend',
    MSPointerDown: 'touchend'
  };
  var MOVE = {
    mousedown: 'mousemove',
    touchstart: 'touchmove',
    pointerdown: 'touchmove',
    MSPointerDown: 'touchmove'
  };
  var Draggable = Evented.extend({
    options: {
      // @section
      // @aka Draggable options
      // @option clickTolerance: Number = 3
      // The max number of pixels a user can shift the mouse pointer during a click
      // for it to be considered a valid click (as opposed to a mouse drag).
      clickTolerance: 3
    },
    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
    initialize: function (element, dragStartTarget, preventOutline$$1, options) {
      setOptions(this, options);
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline$$1;
    },
    // @method enable()
    // Enables the dragging ability
    enable: function () {
      if (this._enabled) {
        return;
      }

      on(this._dragStartTarget, START, this._onDown, this);
      this._enabled = true;
    },
    // @method disable()
    // Disables the dragging ability
    disable: function () {
      if (!this._enabled) {
        return;
      } // If we're currently dragging this draggable,
      // disabling it counts as first ending the drag.


      if (Draggable._dragging === this) {
        this.finishDrag();
      }

      off(this._dragStartTarget, START, this._onDown, this);
      this._enabled = false;
      this._moved = false;
    },
    _onDown: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this._moved = false;

      if (hasClass(this._element, 'leaflet-zoom-anim')) {
        return;
      }

      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
        return;
      }

      Draggable._dragging = this; // Prevent dragging multiple objects at once.

      if (this._preventOutline) {
        preventOutline(this._element);
      }

      disableImageDrag();
      disableTextSelection();

      if (this._moving) {
        return;
      } // @event down: Event
      // Fired when a drag is about to start.


      this.fire('down');
      var first = e.touches ? e.touches[0] : e,
          sizedParent = getSizedParentNode(this._element);
      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).

      this._parentScale = getScale(sizedParent);
      on(document, MOVE[e.type], this._onMove, this);
      on(document, END[e.type], this._onUp, this);
    },
    _onMove: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }

      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

      if (!offset.x && !offset.y) {
        return;
      }

      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
        return;
      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.
      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
      // and we can use the cached value for the scale.


      offset.x /= this._parentScale.x;
      offset.y /= this._parentScale.y;
      preventDefault(e);

      if (!this._moved) {
        // @event dragstart: Event
        // Fired when a drag starts
        this.fire('dragstart');
        this._moved = true;
        this._startPos = getPosition(this._element).subtract(offset);
        addClass(document.body, 'leaflet-dragging');
        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it
        // if necessary

        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
          this._lastTarget = this._lastTarget.correspondingUseElement;
        }

        addClass(this._lastTarget, 'leaflet-drag-target');
      }

      this._newPos = this._startPos.add(offset);
      this._moving = true;
      cancelAnimFrame(this._animRequest);
      this._lastEvent = e;
      this._animRequest = requestAnimFrame(this._updatePosition, this, true);
    },
    _updatePosition: function () {
      var e = {
        originalEvent: this._lastEvent
      }; // @event predrag: Event
      // Fired continuously during dragging *before* each corresponding
      // update of the element's position.

      this.fire('predrag', e);
      setPosition(this._element, this._newPos); // @event drag: Event
      // Fired continuously during dragging.

      this.fire('drag', e);
    },
    _onUp: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this.finishDrag();
    },
    finishDrag: function () {
      removeClass(document.body, 'leaflet-dragging');

      if (this._lastTarget) {
        removeClass(this._lastTarget, 'leaflet-drag-target');
        this._lastTarget = null;
      }

      for (var i in MOVE) {
        off(document, MOVE[i], this._onMove, this);
        off(document, END[i], this._onUp, this);
      }

      enableImageDrag();
      enableTextSelection();

      if (this._moved && this._moving) {
        // ensure drag is not fired after dragend
        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent
        // Fired when the drag ends.

        this.fire('dragend', {
          distance: this._newPos.distanceTo(this._startPos)
        });
      }

      this._moving = false;
      Draggable._dragging = false;
    }
  });
  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */
  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.
  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).

  function simplify(points, tolerance) {
    if (!tolerance || !points.length) {
      return points.slice();
    }

    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction

    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification

    points = _simplifyDP(points, sqTolerance);
    return points;
  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.


  function pointToSegmentDistance(p, p1, p2) {
    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.


  function closestPointOnSegment(p, p1, p2) {
    return _sqClosestPointOnSegment(p, p1, p2);
  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm


  function _simplifyDP(points, sqTolerance) {
    var len = points.length,
        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
        markers = new ArrayConstructor(len);
    markers[0] = markers[len - 1] = 1;

    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

    var i,
        newPoints = [];

    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }

    return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {
    var maxSqDist = 0,
        index,
        i,
        sqDist;

    for (i = first + 1; i <= last - 1; i++) {
      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }

    if (maxSqDist > sqTolerance) {
      markers[index] = 1;

      _simplifyDPStep(points, markers, sqTolerance, first, index);

      _simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  } // reduce points that are too close to each other to a single point


  function _reducePoints(points, sqTolerance) {
    var reducedPoints = [points[0]];

    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
      if (_sqDist(points[i], points[prev]) > sqTolerance) {
        reducedPoints.push(points[i]);
        prev = i;
      }
    }

    if (prev < len - 1) {
      reducedPoints.push(points[len - 1]);
    }

    return reducedPoints;
  }

  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.


  function clipSegment(a, b, bounds, useLastCode, round) {
    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
        codeB = _getBitCode(b, bounds),
        codeOut,
        p,
        newCode; // save 2nd code to avoid calculating it on the next segment


    _lastCode = codeB;

    while (true) {
      // if a,b is inside the clip window (trivial accept)
      if (!(codeA | codeB)) {
        return [a, b];
      } // if a,b is outside the clip window (trivial reject)


      if (codeA & codeB) {
        return false;
      } // other cases


      codeOut = codeA || codeB;
      p = _getEdgeIntersection(a, b, codeOut, bounds, round);
      newCode = _getBitCode(p, bounds);

      if (codeOut === codeA) {
        a = p;
        codeA = newCode;
      } else {
        b = p;
        codeB = newCode;
      }
    }
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
    var dx = b.x - a.x,
        dy = b.y - a.y,
        min = bounds.min,
        max = bounds.max,
        x,
        y;

    if (code & 8) {
      // top
      x = a.x + dx * (max.y - a.y) / dy;
      y = max.y;
    } else if (code & 4) {
      // bottom
      x = a.x + dx * (min.y - a.y) / dy;
      y = min.y;
    } else if (code & 2) {
      // right
      x = max.x;
      y = a.y + dy * (max.x - a.x) / dx;
    } else if (code & 1) {
      // left
      x = min.x;
      y = a.y + dy * (min.x - a.x) / dx;
    }

    return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
    var code = 0;

    if (p.x < bounds.min.x) {
      // left
      code |= 1;
    } else if (p.x > bounds.max.x) {
      // right
      code |= 2;
    }

    if (p.y < bounds.min.y) {
      // bottom
      code |= 4;
    } else if (p.y > bounds.max.y) {
      // top
      code |= 8;
    }

    return code;
  } // square distance (to avoid unnecessary Math.sqrt calls)


  function _sqDist(p1, p2) {
    var dx = p2.x - p1.x,
        dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  } // return closest point on segment or distance to that point


  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y,
        dot = dx * dx + dy * dy,
        t;

    if (dot > 0) {
      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;
    return sqDist ? dx * dx + dy * dy : new Point(x, y);
  } // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.


  function isFlat(latlngs) {
    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
  }

  function _flat(latlngs) {
    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
    return isFlat(latlngs);
  }

  var LineUtil = {
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat
  };
  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */

  function clipPolygon(points, bounds, round) {
    var clippedPoints,
        edges = [1, 4, 2, 8],
        i,
        j,
        k,
        a,
        b,
        len,
        edge,
        p;

    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = _getBitCode(points[i], bounds);
    } // for each edge (left, bottom, right, top)


    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];

      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j]; // if a is inside the clip window

        if (!(a._code & edge)) {
          // if b is outside the clip window (a->b goes out of screen)
          if (b._code & edge) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }

          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)
        } else if (!(b._code & edge)) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }

      points = clippedPoints;
    }

    return points;
  }

  var PolyUtil = {
    clipPolygon: clipPolygon
  };
  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection — the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
    project: function (latlng) {
      return new Point(latlng.lng, latlng.lat);
    },
    unproject: function (point) {
      return new LatLng(point.y, point.x);
    },
    bounds: new Bounds([-180, -90], [180, 90])
  };
  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
    R: 6378137,
    R_MINOR: 6356752.314245179,
    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
    project: function (latlng) {
      var d = Math.PI / 180,
          r = this.R,
          y = latlng.lat * d,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          con = e * Math.sin(y);
      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
      y = -r * Math.log(Math.max(ts, 1E-10));
      return new Point(latlng.lng * d * r, y);
    },
    unproject: function (point) {
      var d = 180 / Math.PI,
          r = this.R,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          ts = Math.exp(-point.y / r),
          phi = Math.PI / 2 - 2 * Math.atan(ts);

      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        con = e * Math.sin(phi);
        con = Math.pow((1 - con) / (1 + con), e / 2);
        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
        phi += dphi;
      }

      return new LatLng(phi * d, point.x * d / r);
    }
  };
  /*
   * @class Projection
    * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).
    * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid
    * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.
    * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.
    * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
    */

  var index = {
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */

  var EPSG3395 = extend({}, Earth, {
    code: 'EPSG:3395',
    projection: Mercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
    code: 'EPSG:4326',
    projection: LonLat,
    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });
  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
    projection: LonLat,
    transformation: toTransformation(1, 0, -1, 0),
    scale: function (zoom) {
      return Math.pow(2, zoom);
    },
    zoom: function (scale) {
      return Math.log(scale) / Math.LN2;
    },
    distance: function (latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng,
          dy = latlng2.lat - latlng1.lat;
      return Math.sqrt(dx * dx + dy * dy);
    },
    infinite: true
  });
  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;
  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */

  var Layer = Evented.extend({
    // Classes extending `L.Layer` will inherit the following options:
    options: {
      // @option pane: String = 'overlayPane'
      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
      pane: 'overlayPane',
      // @option attribution: String = null
      // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
      attribution: null,
      bubblingMouseEvents: true
    },

    /* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
    addTo: function (map) {
      map.addLayer(this);
      return this;
    },
    // @method remove: this
    // Removes the layer from the map it is currently active on.
    remove: function () {
      return this.removeFrom(this._map || this._mapToAdd);
    },
    // @method removeFrom(map: Map): this
    // Removes the layer from the given map
    //
    // @alternative
    // @method removeFrom(group: LayerGroup): this
    // Removes the layer from the given `LayerGroup`
    removeFrom: function (obj) {
      if (obj) {
        obj.removeLayer(this);
      }

      return this;
    },
    // @method getPane(name? : String): HTMLElement
    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
    getPane: function (name) {
      return this._map.getPane(name ? this.options[name] || name : this.options.pane);
    },
    addInteractiveTarget: function (targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    },
    removeInteractiveTarget: function (targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    },
    // @method getAttribution: String
    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
    getAttribution: function () {
      return this.options.attribution;
    },
    _layerAdd: function (e) {
      var map = e.target; // check in case layer gets added and then removed before the map is ready

      if (!map.hasLayer(this)) {
        return;
      }

      this._map = map;
      this._zoomAnimated = map._zoomAnimated;

      if (this.getEvents) {
        var events = this.getEvents();
        map.on(events, this);
        this.once('remove', function () {
          map.off(events, this);
        }, this);
      }

      this.onAdd(map);

      if (this.getAttribution && map.attributionControl) {
        map.attributionControl.addAttribution(this.getAttribution());
      }

      this.fire('add');
      map.fire('layeradd', {
        layer: this
      });
    }
  });
  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */

  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */

  Map.include({
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the map
    addLayer: function (layer) {
      if (!layer._layerAdd) {
        throw new Error('The provided object is not a Layer.');
      }

      var id = stamp(layer);

      if (this._layers[id]) {
        return this;
      }

      this._layers[id] = layer;
      layer._mapToAdd = this;

      if (layer.beforeAdd) {
        layer.beforeAdd(this);
      }

      this.whenReady(layer._layerAdd, layer);
      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the map.
    removeLayer: function (layer) {
      var id = stamp(layer);

      if (!this._layers[id]) {
        return this;
      }

      if (this._loaded) {
        layer.onRemove(this);
      }

      if (layer.getAttribution && this.attributionControl) {
        this.attributionControl.removeAttribution(layer.getAttribution());
      }

      delete this._layers[id];

      if (this._loaded) {
        this.fire('layerremove', {
          layer: layer
        });
        layer.fire('remove');
      }

      layer._map = layer._mapToAdd = null;
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the map
    hasLayer: function (layer) {
      return !!layer && stamp(layer) in this._layers;
    },

    /* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    _addLayers: function (layers) {
      layers = layers ? isArray(layers) ? layers : [layers] : [];

      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },
    _addZoomLimit: function (layer) {
      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
        this._zoomBoundLayers[stamp(layer)] = layer;

        this._updateZoomLevels();
      }
    },
    _removeZoomLimit: function (layer) {
      var id = stamp(layer);

      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];

        this._updateZoomLevels();
      }
    },
    _updateZoomLevels: function () {
      var minZoom = Infinity,
          maxZoom = -Infinity,
          oldZoomSpan = this._getZoomSpan();

      for (var i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;
        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
      }

      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events
      // @event zoomlevelschange: Event
      // Fired when the number of zoomlevels on the map is changed due
      // to adding or removing a layer.

      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire('zoomlevelschange');
      }

      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
        this.setZoom(this._layersMaxZoom);
      }

      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
        this.setZoom(this._layersMinZoom);
      }
    }
  });
  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({
    initialize: function (layers, options) {
      setOptions(this, options);
      this._layers = {};
      var i, len;

      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the group.
    addLayer: function (layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;

      if (this._map) {
        this._map.addLayer(layer);
      }

      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the group.
    // @alternative
    // @method removeLayer(id: Number): this
    // Removes the layer with the given internal ID from the group.
    removeLayer: function (layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);

      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }

      delete this._layers[id];
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the group.
    // @alternative
    // @method hasLayer(id: Number): Boolean
    // Returns `true` if the given internal ID is currently added to the group.
    hasLayer: function (layer) {
      if (!layer) {
        return false;
      }

      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
      return layerId in this._layers;
    },
    // @method clearLayers(): this
    // Removes all the layers from the group.
    clearLayers: function () {
      return this.eachLayer(this.removeLayer, this);
    },
    // @method invoke(methodName: String, …): this
    // Calls `methodName` on every layer contained in this group, passing any
    // additional parameters. Has no effect if the layers contained do not
    // implement `methodName`.
    invoke: function (methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
          i,
          layer;

      for (i in this._layers) {
        layer = this._layers[i];

        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }

      return this;
    },
    onAdd: function (map) {
      this.eachLayer(map.addLayer, map);
    },
    onRemove: function (map) {
      this.eachLayer(map.removeLayer, map);
    },
    // @method eachLayer(fn: Function, context?: Object): this
    // Iterates over the layers of the group, optionally specifying context of the iterator function.
    // ```js
    // group.eachLayer(function (layer) {
    // 	layer.bindPopup('Hello');
    // });
    // ```
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    // @method getLayer(id: Number): Layer
    // Returns the layer with the given internal ID.
    getLayer: function (id) {
      return this._layers[id];
    },
    // @method getLayers(): Layer[]
    // Returns an array of all the layers added to the group.
    getLayers: function () {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    },
    // @method setZIndex(zIndex: Number): this
    // Calls `setZIndex` on every layer contained in this group, passing the z-index.
    setZIndex: function (zIndex) {
      return this.invoke('setZIndex', zIndex);
    },
    // @method getLayerId(layer: Layer): Number
    // Returns the internal ID for a layer
    getLayerId: function (layer) {
      return stamp(layer);
    }
  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.

  var layerGroup = function (layers, options) {
    return new LayerGroup(layers, options);
  };
  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */


  var FeatureGroup = LayerGroup.extend({
    addLayer: function (layer) {
      if (this.hasLayer(layer)) {
        return this;
      }

      layer.addEventParent(this);
      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent
      // Fired when a layer is added to this `FeatureGroup`

      return this.fire('layeradd', {
        layer: layer
      });
    },
    removeLayer: function (layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }

      if (layer in this._layers) {
        layer = this._layers[layer];
      }

      layer.removeEventParent(this);
      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent
      // Fired when a layer is removed from this `FeatureGroup`

      return this.fire('layerremove', {
        layer: layer
      });
    },
    // @method setStyle(style: Path options): this
    // Sets the given path options to each layer of the group that has a `setStyle` method.
    setStyle: function (style) {
      return this.invoke('setStyle', style);
    },
    // @method bringToFront(): this
    // Brings the layer group to the top of all other layers
    bringToFront: function () {
      return this.invoke('bringToFront');
    },
    // @method bringToBack(): this
    // Brings the layer group to the back of all other layers
    bringToBack: function () {
      return this.invoke('bringToBack');
    },
    // @method getBounds(): LatLngBounds
    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
    getBounds: function () {
      var bounds = new LatLngBounds();

      for (var id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }

      return bounds;
    }
  }); // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.

  var featureGroup = function (layers, options) {
    return new FeatureGroup(layers, options);
  };
  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */


  var Icon = Class.extend({
    /* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */
    options: {
      popupAnchor: [0, 0],
      tooltipAnchor: [0, 0]
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    // @method createIcon(oldIcon?: HTMLElement): HTMLElement
    // Called internally when the icon has to be shown, returns a `<img>` HTML element
    // styled according to the options.
    createIcon: function (oldIcon) {
      return this._createIcon('icon', oldIcon);
    },
    // @method createShadow(oldIcon?: HTMLElement): HTMLElement
    // As `createIcon`, but for the shadow beneath it.
    createShadow: function (oldIcon) {
      return this._createIcon('shadow', oldIcon);
    },
    _createIcon: function (name, oldIcon) {
      var src = this._getIconUrl(name);

      if (!src) {
        if (name === 'icon') {
          throw new Error('iconUrl not set in Icon options (see the docs).');
        }

        return null;
      }

      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);

      this._setIconStyles(img, name);

      return img;
    },
    _setIconStyles: function (img, name) {
      var options = this.options;
      var sizeOption = options[name + 'Size'];

      if (typeof sizeOption === 'number') {
        sizeOption = [sizeOption, sizeOption];
      }

      var size = toPoint(sizeOption),
          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

      if (anchor) {
        img.style.marginLeft = -anchor.x + 'px';
        img.style.marginTop = -anchor.y + 'px';
      }

      if (size) {
        img.style.width = size.x + 'px';
        img.style.height = size.y + 'px';
      }
    },
    _createImg: function (src, el) {
      el = el || document.createElement('img');
      el.src = src;
      return el;
    },
    _getIconUrl: function (name) {
      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
    }
  }); // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.

  function icon(options) {
    return new Icon(options);
  }
  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */


  var IconDefault = Icon.extend({
    options: {
      iconUrl: 'marker-icon.png',
      iconRetinaUrl: 'marker-icon-2x.png',
      shadowUrl: 'marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41]
    },
    _getIconUrl: function (name) {
      if (!IconDefault.imagePath) {
        // Deprecated, backwards-compatibility only
        IconDefault.imagePath = this._detectIconPath();
      } // @option imagePath: String
      // `Icon.Default` will try to auto-detect the location of the
      // blue icon images. If you are placing these images in a non-standard
      // way, set this option to point to the right path.


      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
    },
    _detectIconPath: function () {
      var el = create$1('div', 'leaflet-default-icon-path', document.body);
      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

      document.body.removeChild(el);

      if (path === null || path.indexOf('url') !== 0) {
        path = '';
      } else {
        path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
      }

      return path;
    }
  });
  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */

  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
    initialize: function (marker) {
      this._marker = marker;
    },
    addHooks: function () {
      var icon = this._marker._icon;

      if (!this._draggable) {
        this._draggable = new Draggable(icon, icon, true);
      }

      this._draggable.on({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).enable();

      addClass(icon, 'leaflet-marker-draggable');
    },
    removeHooks: function () {
      this._draggable.off({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).disable();

      if (this._marker._icon) {
        removeClass(this._marker._icon, 'leaflet-marker-draggable');
      }
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    _adjustPan: function (e) {
      var marker = this._marker,
          map = marker._map,
          speed = this._marker.options.autoPanSpeed,
          padding = this._marker.options.autoPanPadding,
          iconPos = getPosition(marker._icon),
          bounds = map.getPixelBounds(),
          origin = map.getPixelOrigin();
      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));

      if (!panBounds.contains(iconPos)) {
        // Compute incremental movement
        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
        map.panBy(movement, {
          animate: false
        });

        this._draggable._newPos._add(movement);

        this._draggable._startPos._add(movement);

        setPosition(marker._icon, this._draggable._newPos);

        this._onDrag(e);

        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDragStart: function () {
      // @section Dragging events
      // @event dragstart: Event
      // Fired when the user starts dragging the marker.
      // @event movestart: Event
      // Fired when the marker starts moving (because of dragging).
      this._oldLatLng = this._marker.getLatLng(); // When using ES6 imports it could not be set when `Popup` was not imported as well

      this._marker.closePopup && this._marker.closePopup();

      this._marker.fire('movestart').fire('dragstart');
    },
    _onPreDrag: function (e) {
      if (this._marker.options.autoPan) {
        cancelAnimFrame(this._panRequest);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDrag: function (e) {
      var marker = this._marker,
          shadow = marker._shadow,
          iconPos = getPosition(marker._icon),
          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position


      if (shadow) {
        setPosition(shadow, iconPos);
      }

      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng; // @event drag: Event
      // Fired repeatedly while the user drags the marker.

      marker.fire('move', e).fire('drag', e);
    },
    _onDragEnd: function (e) {
      // @event dragend: DragEndEvent
      // Fired when the user stops dragging the marker.
      cancelAnimFrame(this._panRequest); // @event moveend: Event
      // Fired when the marker stops moving (because of dragging).

      delete this._oldLatLng;

      this._marker.fire('moveend').fire('dragend', e);
    }
  });
  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({
    // @section
    // @aka Marker options
    options: {
      // @option icon: Icon = *
      // Icon instance to use for rendering the marker.
      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
      // If not specified, a common instance of `L.Icon.Default` is used.
      icon: new IconDefault(),
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option keyboard: Boolean = true
      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
      keyboard: true,
      // @option title: String = ''
      // Text for the browser tooltip that appear on marker hover (no tooltip by default).
      title: '',
      // @option alt: String = ''
      // Text for the `alt` attribute of the icon image (useful for accessibility).
      alt: '',
      // @option zIndexOffset: Number = 0
      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
      zIndexOffset: 0,
      // @option opacity: Number = 1.0
      // The opacity of the marker.
      opacity: 1,
      // @option riseOnHover: Boolean = false
      // If `true`, the marker will get on top of others when you hover the mouse over it.
      riseOnHover: false,
      // @option riseOffset: Number = 250
      // The z-index offset used for the `riseOnHover` feature.
      riseOffset: 250,
      // @option pane: String = 'markerPane'
      // `Map pane` where the markers icon will be added.
      pane: 'markerPane',
      // @option shadowPane: String = 'shadowPane'
      // `Map pane` where the markers shadow will be added.
      shadowPane: 'shadowPane',
      // @option bubblingMouseEvents: Boolean = false
      // When `true`, a mouse event on this marker will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: false,
      // @section Draggable marker options
      // @option draggable: Boolean = false
      // Whether the marker is draggable with mouse/touch or not.
      draggable: false,
      // @option autoPan: Boolean = false
      // Whether to pan the map when dragging this marker near its edge or not.
      autoPan: false,
      // @option autoPanPadding: Point = Point(50, 50)
      // Distance (in pixels to the left/right and to the top/bottom) of the
      // map edge to start panning the map.
      autoPanPadding: [50, 50],
      // @option autoPanSpeed: Number = 10
      // Number of pixels the map should pan by.
      autoPanSpeed: 10
    },

    /* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    },
    onAdd: function (map) {
      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

      if (this._zoomAnimated) {
        map.on('zoomanim', this._animateZoom, this);
      }

      this._initIcon();

      this.update();
    },
    onRemove: function (map) {
      if (this.dragging && this.dragging.enabled()) {
        this.options.draggable = true;
        this.dragging.removeHooks();
      }

      delete this.dragging;

      if (this._zoomAnimated) {
        map.off('zoomanim', this._animateZoom, this);
      }

      this._removeIcon();

      this._removeShadow();
    },
    getEvents: function () {
      return {
        zoom: this.update,
        viewreset: this.update
      };
    },
    // @method getLatLng: LatLng
    // Returns the current geographical position of the marker.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Changes the marker position to the given point.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method setZIndexOffset(offset: Number): this
    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
    setZIndexOffset: function (offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    },
    // @method getIcon: Icon
    // Returns the current icon used by the marker
    getIcon: function () {
      return this.options.icon;
    },
    // @method setIcon(icon: Icon): this
    // Changes the marker icon.
    setIcon: function (icon) {
      this.options.icon = icon;

      if (this._map) {
        this._initIcon();

        this.update();
      }

      if (this._popup) {
        this.bindPopup(this._popup, this._popup.options);
      }

      return this;
    },
    getElement: function () {
      return this._icon;
    },
    update: function () {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();

        this._setPos(pos);
      }

      return this;
    },
    _initIcon: function () {
      var options = this.options,
          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      var icon = options.icon.createIcon(this._icon),
          addIcon = false; // if we're not reusing the icon, remove the old one and init new one

      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }

        addIcon = true;

        if (options.title) {
          icon.title = options.title;
        }

        if (icon.tagName === 'IMG') {
          icon.alt = options.alt || '';
        }
      }

      addClass(icon, classToAdd);

      if (options.keyboard) {
        icon.tabIndex = '0';
      }

      this._icon = icon;

      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      var newShadow = options.icon.createShadow(this._shadow),
          addShadow = false;

      if (newShadow !== this._shadow) {
        this._removeShadow();

        addShadow = true;
      }

      if (newShadow) {
        addClass(newShadow, classToAdd);
        newShadow.alt = '';
      }

      this._shadow = newShadow;

      if (options.opacity < 1) {
        this._updateOpacity();
      }

      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }

      this._initInteraction();

      if (newShadow && addShadow) {
        this.getPane(options.shadowPane).appendChild(this._shadow);
      }
    },
    _removeIcon: function () {
      if (this.options.riseOnHover) {
        this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      remove(this._icon);
      this.removeInteractiveTarget(this._icon);
      this._icon = null;
    },
    _removeShadow: function () {
      if (this._shadow) {
        remove(this._shadow);
      }

      this._shadow = null;
    },
    _setPos: function (pos) {
      if (this._icon) {
        setPosition(this._icon, pos);
      }

      if (this._shadow) {
        setPosition(this._shadow, pos);
      }

      this._zIndex = pos.y + this.options.zIndexOffset;

      this._resetZIndex();
    },
    _updateZIndex: function (offset) {
      if (this._icon) {
        this._icon.style.zIndex = this._zIndex + offset;
      }
    },
    _animateZoom: function (opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

      this._setPos(pos);
    },
    _initInteraction: function () {
      if (!this.options.interactive) {
        return;
      }

      addClass(this._icon, 'leaflet-interactive');
      this.addInteractiveTarget(this._icon);

      if (MarkerDrag) {
        var draggable = this.options.draggable;

        if (this.dragging) {
          draggable = this.dragging.enabled();
          this.dragging.disable();
        }

        this.dragging = new MarkerDrag(this);

        if (draggable) {
          this.dragging.enable();
        }
      }
    },
    // @method setOpacity(opacity: Number): this
    // Changes the opacity of the marker.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._map) {
        this._updateOpacity();
      }

      return this;
    },
    _updateOpacity: function () {
      var opacity = this.options.opacity;

      if (this._icon) {
        setOpacity(this._icon, opacity);
      }

      if (this._shadow) {
        setOpacity(this._shadow, opacity);
      }
    },
    _bringToFront: function () {
      this._updateZIndex(this.options.riseOffset);
    },
    _resetZIndex: function () {
      this._updateZIndex(0);
    },
    _getPopupAnchor: function () {
      return this.options.icon.options.popupAnchor;
    },
    _getTooltipAnchor: function () {
      return this.options.icon.options.tooltipAnchor;
    }
  }); // factory L.marker(latlng: LatLng, options? : Marker options)
  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.

  function marker(latlng, options) {
    return new Marker(latlng, options);
  }
  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */


  var Path = Layer.extend({
    // @section
    // @aka Path options
    options: {
      // @option stroke: Boolean = true
      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
      stroke: true,
      // @option color: String = '#3388ff'
      // Stroke color
      color: '#3388ff',
      // @option weight: Number = 3
      // Stroke width in pixels
      weight: 3,
      // @option opacity: Number = 1.0
      // Stroke opacity
      opacity: 1,
      // @option lineCap: String= 'round'
      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
      lineCap: 'round',
      // @option lineJoin: String = 'round'
      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
      lineJoin: 'round',
      // @option dashArray: String = null
      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashArray: null,
      // @option dashOffset: String = null
      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashOffset: null,
      // @option fill: Boolean = depends
      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
      fill: false,
      // @option fillColor: String = *
      // Fill color. Defaults to the value of the [`color`](#path-color) option
      fillColor: null,
      // @option fillOpacity: Number = 0.2
      // Fill opacity.
      fillOpacity: 0.2,
      // @option fillRule: String = 'evenodd'
      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
      fillRule: 'evenodd',
      // className: '',
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option bubblingMouseEvents: Boolean = true
      // When `true`, a mouse event on this path will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: true
    },
    beforeAdd: function (map) {
      // Renderer is set here because we need to call renderer.getEvents
      // before this.getEvents.
      this._renderer = map.getRenderer(this);
    },
    onAdd: function () {
      this._renderer._initPath(this);

      this._reset();

      this._renderer._addPath(this);
    },
    onRemove: function () {
      this._renderer._removePath(this);
    },
    // @method redraw(): this
    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
    redraw: function () {
      if (this._map) {
        this._renderer._updatePath(this);
      }

      return this;
    },
    // @method setStyle(style: Path options): this
    // Changes the appearance of a Path based on the options in the `Path options` object.
    setStyle: function (style) {
      setOptions(this, style);

      if (this._renderer) {
        this._renderer._updateStyle(this);

        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
          this._updateBounds();
        }
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all path layers.
    bringToFront: function () {
      if (this._renderer) {
        this._renderer._bringToFront(this);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all path layers.
    bringToBack: function () {
      if (this._renderer) {
        this._renderer._bringToBack(this);
      }

      return this;
    },
    getElement: function () {
      return this._path;
    },
    _reset: function () {
      // defined in child classes
      this._project();

      this._update();
    },
    _clickTolerance: function () {
      // used when doing hit detection for Canvas layers
      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
    }
  });
  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
      fill: true,
      // @option radius: Number = 10
      // Radius of the circle marker, in pixels
      radius: 10
    },
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    },
    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
      return this._latlng;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle marker. Units are in pixels.
    setRadius: function (radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of the circle
    getRadius: function () {
      return this._radius;
    },
    setStyle: function (options) {
      var radius = options && options.radius || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    },
    _project: function () {
      this._point = this._map.latLngToLayerPoint(this._latlng);

      this._updateBounds();
    },
    _updateBounds: function () {
      var r = this._radius,
          r2 = this._radiusY || r,
          w = this._clickTolerance(),
          p = [r + w, r2 + w];

      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function () {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function () {
      this._renderer._updateCircle(this);
    },
    _empty: function () {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    }
  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.

  function circleMarker(latlng, options) {
    return new CircleMarker(latlng, options);
  }
  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */


  var Circle = CircleMarker.extend({
    initialize: function (latlng, options, legacyOptions) {
      if (typeof options === 'number') {
        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
        options = extend({}, legacyOptions, {
          radius: options
        });
      }

      setOptions(this, options);
      this._latlng = toLatLng(latlng);

      if (isNaN(this.options.radius)) {
        throw new Error('Circle radius cannot be NaN');
      } // @section
      // @aka Circle options
      // @option radius: Number; Radius of the circle, in meters.


      this._mRadius = this.options.radius;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle. Units are in meters.
    setRadius: function (radius) {
      this._mRadius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of a circle. Units are in meters.
    getRadius: function () {
      return this._mRadius;
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      var half = [this._radius, this._radiusY || this._radius];
      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
    },
    setStyle: Path.prototype.setStyle,
    _project: function () {
      var lng = this._latlng.lng,
          lat = this._latlng.lat,
          map = this._map,
          crs = map.options.crs;

      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180,
            latR = this._mRadius / Earth.R / d,
            top = map.project([lat + latR, lng]),
            bottom = map.project([lat - latR, lng]),
            p = top.add(bottom).divideBy(2),
            lat2 = map.unproject(p).lat,
            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

        if (isNaN(lngR) || lngR === 0) {
          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
        }

        this._point = p.subtract(map.getPixelOrigin());
        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
        this._radiusY = p.y - top.y;
      } else {
        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
        this._point = map.latLngToLayerPoint(this._latlng);
        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
      }

      this._updateBounds();
    }
  }); // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.

  function circle(latlng, options, legacyOptions) {
    return new Circle(latlng, options, legacyOptions);
  }
  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({
    // @section
    // @aka Polyline options
    options: {
      // @option smoothFactor: Number = 1.0
      // How much to simplify the polyline on each zoom level. More means
      // better performance and smoother look, and less means more accurate representation.
      smoothFactor: 1.0,
      // @option noClip: Boolean = false
      // Disable polyline clipping.
      noClip: false
    },
    initialize: function (latlngs, options) {
      setOptions(this, options);

      this._setLatLngs(latlngs);
    },
    // @method getLatLngs(): LatLng[]
    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
    getLatLngs: function () {
      return this._latlngs;
    },
    // @method setLatLngs(latlngs: LatLng[]): this
    // Replaces all the points in the polyline with the given array of geographical points.
    setLatLngs: function (latlngs) {
      this._setLatLngs(latlngs);

      return this.redraw();
    },
    // @method isEmpty(): Boolean
    // Returns `true` if the Polyline has no LatLngs.
    isEmpty: function () {
      return !this._latlngs.length;
    },
    // @method closestLayerPoint(p: Point): Point
    // Returns the point closest to `p` on the Polyline.
    closestLayerPoint: function (p) {
      var minDistance = Infinity,
          minPoint = null,
          closest = _sqClosestPointOnSegment,
          p1,
          p2;

      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
        var points = this._parts[j];

        for (var i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = closest(p, p1, p2, true);

          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = closest(p, p1, p2);
          }
        }
      }

      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }

      return minPoint;
    },
    // @method getCenter(): LatLng
    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          halfDist,
          segDist,
          dist,
          p1,
          p2,
          ratio,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polyline centroid algorithm; only uses the first ring if there are multiple


      for (i = 0, halfDist = 0; i < len - 1; i++) {
        halfDist += points[i].distanceTo(points[i + 1]) / 2;
      } // The line is so small in the current view that all points are on the same pixel.


      if (halfDist === 0) {
        return this._map.layerPointToLatLng(points[0]);
      }

      for (i = 0, dist = 0; i < len - 1; i++) {
        p1 = points[i];
        p2 = points[i + 1];
        segDist = p1.distanceTo(p2);
        dist += segDist;

        if (dist > halfDist) {
          ratio = (dist - halfDist) / segDist;
          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
        }
      }
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      return this._bounds;
    },
    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
    // Adds a given point to the polyline. By default, adds to the first ring of
    // the polyline in case of a multi-polyline, but can be overridden by passing
    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
    addLatLng: function (latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);

      this._bounds.extend(latlng);

      return this.redraw();
    },
    _setLatLngs: function (latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    },
    _defaultShape: function () {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    },
    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
    _convertLatLngs: function (latlngs) {
      var result = [],
          flat = isFlat(latlngs);

      for (var i = 0, len = latlngs.length; i < len; i++) {
        if (flat) {
          result[i] = toLatLng(latlngs[i]);

          this._bounds.extend(result[i]);
        } else {
          result[i] = this._convertLatLngs(latlngs[i]);
        }
      }

      return result;
    },
    _project: function () {
      var pxBounds = new Bounds();
      this._rings = [];

      this._projectLatlngs(this._latlngs, this._rings, pxBounds);

      if (this._bounds.isValid() && pxBounds.isValid()) {
        this._rawPxBounds = pxBounds;

        this._updateBounds();
      }
    },
    _updateBounds: function () {
      var w = this._clickTolerance(),
          p = new Point(w, w);

      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);
    },
    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result, projectedBounds) {
      var flat = latlngs[0] instanceof LatLng,
          len = latlngs.length,
          i,
          ring;

      if (flat) {
        ring = [];

        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
          projectedBounds.extend(ring[i]);
        }

        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    },
    // clip polyline by renderer bounds so that we have less to render for performance
    _clipPoints: function () {
      var bounds = this._renderer._bounds;
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      var parts = this._parts,
          i,
          j,
          k,
          len,
          len2,
          segment,
          points;

      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
        points = this._rings[i];

        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, true);

          if (!segment) {
            continue;
          }

          parts[k] = parts[k] || [];
          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part

          if (segment[1] !== points[j + 1] || j === len2 - 2) {
            parts[k].push(segment[1]);
            k++;
          }
        }
      }
    },
    // simplify each clipped part of the polyline for performance
    _simplifyPoints: function () {
      var parts = this._parts,
          tolerance = this.options.smoothFactor;

      for (var i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      this._clipPoints();

      this._simplifyPoints();

      this._updatePath();
    },
    _updatePath: function () {
      this._renderer._updatePoly(this);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p, closed) {
      var i,
          j,
          k,
          len,
          len2,
          part,
          w = this._clickTolerance();

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // hit detection for polylines


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && j === 0) {
            continue;
          }

          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return true;
          }
        }
      }

      return false;
    }
  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.

  function polyline(latlngs, options) {
    return new Polyline(latlngs, options);
  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.


  Polyline._flat = _flat;
  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({
    options: {
      fill: true
    },
    isEmpty: function () {
      return !this._latlngs.length || !this._latlngs[0].length;
    },
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          j,
          p1,
          p2,
          f,
          area,
          x,
          y,
          center,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polygon centroid algorithm; only uses the first ring if there are multiple


      area = x = y = 0;

      for (i = 0, j = len - 1; i < len; j = i++) {
        p1 = points[i];
        p2 = points[j];
        f = p1.y * p2.x - p2.y * p1.x;
        x += (p1.x + p2.x) * f;
        y += (p1.y + p2.y) * f;
        area += f * 3;
      }

      if (area === 0) {
        // Polygon is so small that all points are on same pixel.
        center = points[0];
      } else {
        center = [x / area, y / area];
      }

      return this._map.layerPointToLatLng(center);
    },
    _convertLatLngs: function (latlngs) {
      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
          len = result.length; // remove last point if it equals first one


      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
        result.pop();
      }

      return result;
    },
    _setLatLngs: function (latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);

      if (isFlat(this._latlngs)) {
        this._latlngs = [this._latlngs];
      }
    },
    _defaultShape: function () {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    },
    _clipPoints: function () {
      // polygons need a different clipping algorithm so we redefine that
      var bounds = this._renderer._bounds,
          w = this.options.weight,
          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges

      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
        clipped = clipPolygon(this._rings[i], bounds, true);

        if (clipped.length) {
          this._parts.push(clipped);
        }
      }
    },
    _updatePath: function () {
      this._renderer._updatePoly(this, true);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      var inside = false,
          part,
          p1,
          p2,
          i,
          j,
          k,
          len,
          len2;

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // ray casting algorithm for detecting if point is in polygon


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];

          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
            inside = !inside;
          }
        }
      } // also check if it's on polygon stroke


      return inside || Polyline.prototype._containsPoint.call(this, p, true);
    }
  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)

  function polygon(latlngs, options) {
    return new Polygon(latlngs, options);
  }
  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */


  var GeoJSON = FeatureGroup.extend({
    /* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     *
     * @option markersInheritOptions: Boolean = false
     * Whether default Markers for "Point" type Features inherit from group options.
     */
    initialize: function (geojson, options) {
      setOptions(this, options);
      this._layers = {};

      if (geojson) {
        this.addData(geojson);
      }
    },
    // @method addData( <GeoJSON> data ): this
    // Adds a GeoJSON object to the layer.
    addData: function (geojson) {
      var features = isArray(geojson) ? geojson : geojson.features,
          i,
          len,
          feature;

      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          // only add this if geometry or geometries are set and not null
          feature = features[i];

          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
            this.addData(feature);
          }
        }

        return this;
      }

      var options = this.options;

      if (options.filter && !options.filter(geojson)) {
        return this;
      }

      var layer = geometryToLayer(geojson, options);

      if (!layer) {
        return this;
      }

      layer.feature = asFeature(geojson);
      layer.defaultOptions = layer.options;
      this.resetStyle(layer);

      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }

      return this.addLayer(layer);
    },
    // @method resetStyle( <Path> layer? ): this
    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
    // If `layer` is omitted, the style of all features in the current layer is reset.
    resetStyle: function (layer) {
      if (layer === undefined) {
        return this.eachLayer(this.resetStyle, this);
      } // reset any custom styles


      layer.options = extend({}, layer.defaultOptions);

      this._setLayerStyle(layer, this.options.style);

      return this;
    },
    // @method setStyle( <Function> style ): this
    // Changes styles of GeoJSON vector layers with the given style function.
    setStyle: function (style) {
      return this.eachLayer(function (layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },
    _setLayerStyle: function (layer, style) {
      if (layer.setStyle) {
        if (typeof style === 'function') {
          style = style(layer.feature);
        }

        layer.setStyle(style);
      }
    }
  }); // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:
  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.

  function geometryToLayer(geojson, options) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
        coords = geometry ? geometry.coordinates : null,
        layers = [],
        pointToLayer = options && options.pointToLayer,
        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
        latlng,
        latlngs,
        i,
        len;

    if (!coords && !geometry) {
      return null;
    }

    switch (geometry.type) {
      case 'Point':
        latlng = _coordsToLatLng(coords);
        return _pointToLayer(pointToLayer, geojson, latlng, options);

      case 'MultiPoint':
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
        }

        return new FeatureGroup(layers);

      case 'LineString':
      case 'MultiLineString':
        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
        return new Polyline(latlngs, options);

      case 'Polygon':
      case 'MultiPolygon':
        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
        return new Polygon(latlngs, options);

      case 'GeometryCollection':
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var layer = geometryToLayer({
            geometry: geometry.geometries[i],
            type: 'Feature',
            properties: geojson.properties
          }, options);

          if (layer) {
            layers.push(layer);
          }
        }

        return new FeatureGroup(layers);

      default:
        throw new Error('Invalid GeoJSON object.');
    }
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
  } // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.


  function coordsToLatLng(coords) {
    return new LatLng(coords[1], coords[0], coords[2]);
  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.


  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
    var latlngs = [];

    for (var i = 0, len = coords.length, latlng; i < len; i++) {
      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
      latlngs.push(latlng);
    }

    return latlngs;
  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)


  function latLngToCoords(latlng, precision) {
    precision = typeof precision === 'number' ? precision : 6;
    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.


  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
    var coords = [];

    for (var i = 0, len = latlngs.length; i < len; i++) {
      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
    }

    if (!levelsDeep && closed) {
      coords.push(coords[0]);
    }

    return coords;
  }

  function getFeature(layer, newGeometry) {
    return layer.feature ? extend({}, layer.feature, {
      geometry: newGeometry
    }) : asFeature(newGeometry);
  } // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.


  function asFeature(geojson) {
    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
      return geojson;
    }

    return {
      type: 'Feature',
      properties: {},
      geometry: geojson
    };
  }

  var PointToGeoJSON = {
    toGeoJSON: function (precision) {
      return getFeature(this, {
        type: 'Point',
        coordinates: latLngToCoords(this.getLatLng(), precision)
      });
    }
  }; // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).

  Marker.include(PointToGeoJSON); // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).

  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON); // @namespace Polyline
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).

  Polyline.include({
    toGeoJSON: function (precision) {
      var multi = !isFlat(this._latlngs);
      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'LineString',
        coordinates: coords
      });
    }
  }); // @namespace Polygon
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).

  Polygon.include({
    toGeoJSON: function (precision) {
      var holes = !isFlat(this._latlngs),
          multi = holes && !isFlat(this._latlngs[0]);
      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

      if (!holes) {
        coords = [coords];
      }

      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'Polygon',
        coordinates: coords
      });
    }
  }); // @namespace LayerGroup

  LayerGroup.include({
    toMultiPoint: function (precision) {
      var coords = [];
      this.eachLayer(function (layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });
      return getFeature(this, {
        type: 'MultiPoint',
        coordinates: coords
      });
    },
    // @method toGeoJSON(precision?: Number): Object
    // `precision` is the number of decimal places for coordinates.
    // The default value is 6 places.
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
    toGeoJSON: function (precision) {
      var type = this.feature && this.feature.geometry && this.feature.geometry.type;

      if (type === 'MultiPoint') {
        return this.toMultiPoint(precision);
      }

      var isGeometryCollection = type === 'GeometryCollection',
          jsons = [];
      this.eachLayer(function (layer) {
        if (layer.toGeoJSON) {
          var json = layer.toGeoJSON(precision);

          if (isGeometryCollection) {
            jsons.push(json.geometry);
          } else {
            var feature = asFeature(json); // Squash nested feature collections

            if (feature.type === 'FeatureCollection') {
              jsons.push.apply(jsons, feature.features);
            } else {
              jsons.push(feature);
            }
          }
        }
      });

      if (isGeometryCollection) {
        return getFeature(this, {
          geometries: jsons,
          type: 'GeometryCollection'
        });
      }

      return {
        type: 'FeatureCollection',
        features: jsons
      };
    }
  }); // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.

  function geoJSON(geojson, options) {
    return new GeoJSON(geojson, options);
  } // Backward compatibility.


  var geoJson = geoJSON;
  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({
    // @section
    // @aka ImageOverlay options
    options: {
      // @option opacity: Number = 1.0
      // The opacity of the image overlay.
      opacity: 1,
      // @option alt: String = ''
      // Text for the `alt` attribute of the image (useful for accessibility).
      alt: '',
      // @option interactive: Boolean = false
      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
      interactive: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the image.
      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
      // @option errorOverlayUrl: String = ''
      // URL to the overlay image to show in place of the overlay that failed to load.
      errorOverlayUrl: '',
      // @option zIndex: Number = 1
      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
      zIndex: 1,
      // @option className: String = ''
      // A custom class name to assign to the image. Empty by default.
      className: ''
    },
    initialize: function (url, bounds, options) {
      // (String, LatLngBounds, Object)
      this._url = url;
      this._bounds = toLatLngBounds(bounds);
      setOptions(this, options);
    },
    onAdd: function () {
      if (!this._image) {
        this._initImage();

        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }

      if (this.options.interactive) {
        addClass(this._image, 'leaflet-interactive');
        this.addInteractiveTarget(this._image);
      }

      this.getPane().appendChild(this._image);

      this._reset();
    },
    onRemove: function () {
      remove(this._image);

      if (this.options.interactive) {
        this.removeInteractiveTarget(this._image);
      }
    },
    // @method setOpacity(opacity: Number): this
    // Sets the opacity of the overlay.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._image) {
        this._updateOpacity();
      }

      return this;
    },
    setStyle: function (styleOpts) {
      if (styleOpts.opacity) {
        this.setOpacity(styleOpts.opacity);
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all overlays.
    bringToFront: function () {
      if (this._map) {
        toFront(this._image);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all overlays.
    bringToBack: function () {
      if (this._map) {
        toBack(this._image);
      }

      return this;
    },
    // @method setUrl(url: String): this
    // Changes the URL of the image.
    setUrl: function (url) {
      this._url = url;

      if (this._image) {
        this._image.src = url;
      }

      return this;
    },
    // @method setBounds(bounds: LatLngBounds): this
    // Update the bounds that this ImageOverlay covers
    setBounds: function (bounds) {
      this._bounds = toLatLngBounds(bounds);

      if (this._map) {
        this._reset();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        zoom: this._reset,
        viewreset: this._reset
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method setZIndex(value: Number): this
    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
    setZIndex: function (value) {
      this.options.zIndex = value;

      this._updateZIndex();

      return this;
    },
    // @method getBounds(): LatLngBounds
    // Get the bounds that this ImageOverlay covers
    getBounds: function () {
      return this._bounds;
    },
    // @method getElement(): HTMLElement
    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
    // used by this overlay.
    getElement: function () {
      return this._image;
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'IMG';
      var img = this._image = wasElementSupplied ? this._url : create$1('img');
      addClass(img, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(img, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(img, this.options.className);
      }

      img.onselectstart = falseFn;
      img.onmousemove = falseFn; // @event load: Event
      // Fired when the ImageOverlay layer has loaded its image

      img.onload = bind(this.fire, this, 'load');
      img.onerror = bind(this._overlayOnError, this, 'error');

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }

      if (this.options.zIndex) {
        this._updateZIndex();
      }

      if (wasElementSupplied) {
        this._url = img.src;
        return;
      }

      img.src = this._url;
      img.alt = this.options.alt;
    },
    _animateZoom: function (e) {
      var scale = this._map.getZoomScale(e.zoom),
          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

      setTransform(this._image, offset, scale);
    },
    _reset: function () {
      var image = this._image,
          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
          size = bounds.getSize();
      setPosition(image, bounds.min);
      image.style.width = size.x + 'px';
      image.style.height = size.y + 'px';
    },
    _updateOpacity: function () {
      setOpacity(this._image, this.options.opacity);
    },
    _updateZIndex: function () {
      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._image.style.zIndex = this.options.zIndex;
      }
    },
    _overlayOnError: function () {
      // @event error: Event
      // Fired when the ImageOverlay layer fails to load its image
      this.fire('error');
      var errorUrl = this.options.errorOverlayUrl;

      if (errorUrl && this._url !== errorUrl) {
        this._url = errorUrl;
        this._image.src = errorUrl;
      }
    }
  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.

  var imageOverlay = function (url, bounds, options) {
    return new ImageOverlay(url, bounds, options);
  };
  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */


  var VideoOverlay = ImageOverlay.extend({
    // @section
    // @aka VideoOverlay options
    options: {
      // @option autoplay: Boolean = true
      // Whether the video starts playing automatically when loaded.
      autoplay: true,
      // @option loop: Boolean = true
      // Whether the video will loop back to the beginning when played.
      loop: true,
      // @option keepAspectRatio: Boolean = true
      // Whether the video will save aspect ratio after the projection.
      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
      keepAspectRatio: true,
      // @option muted: Boolean = false
      // Whether the video starts on mute when loaded.
      muted: false
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'VIDEO';
      var vid = this._image = wasElementSupplied ? this._url : create$1('video');
      addClass(vid, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(vid, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(vid, this.options.className);
      }

      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn; // @event load: Event
      // Fired when the video has finished loading the first frame

      vid.onloadeddata = bind(this.fire, this, 'load');

      if (wasElementSupplied) {
        var sourceElements = vid.getElementsByTagName('source');
        var sources = [];

        for (var j = 0; j < sourceElements.length; j++) {
          sources.push(sourceElements[j].src);
        }

        this._url = sourceElements.length > 0 ? sources : [vid.src];
        return;
      }

      if (!isArray(this._url)) {
        this._url = [this._url];
      }

      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
        vid.style['objectFit'] = 'fill';
      }

      vid.autoplay = !!this.options.autoplay;
      vid.loop = !!this.options.loop;
      vid.muted = !!this.options.muted;

      for (var i = 0; i < this._url.length; i++) {
        var source = create$1('source');
        source.src = this._url[i];
        vid.appendChild(source);
      }
    } // @method getElement(): HTMLVideoElement
    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
    // used by this overlay.

  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
    return new VideoOverlay(video, bounds, options);
  }
  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */


  var SVGOverlay = ImageOverlay.extend({
    _initImage: function () {
      var el = this._image = this._url;
      addClass(el, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(el, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(el, this.options.className);
      }

      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    } // @method getElement(): SVGElement
    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
    // used by this overlay.

  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
    return new SVGOverlay(el, bounds, options);
  }
  /*
   * @class DivOverlay
   * @inherits Layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
   */
  // @namespace DivOverlay


  var DivOverlay = Layer.extend({
    // @section
    // @aka DivOverlay options
    options: {
      // @option offset: Point = Point(0, 7)
      // The offset of the popup position. Useful to control the anchor
      // of the popup when opening it on some overlays.
      offset: [0, 7],
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: '',
      // @option pane: String = 'popupPane'
      // `Map pane` where the popup will be added.
      pane: 'popupPane'
    },
    initialize: function (options, source) {
      setOptions(this, options);
      this._source = source;
    },
    onAdd: function (map) {
      this._zoomAnimated = map._zoomAnimated;

      if (!this._container) {
        this._initLayout();
      }

      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
      }

      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();

      if (map._fadeAnimated) {
        setOpacity(this._container, 1);
      }

      this.bringToFront();
    },
    onRemove: function (map) {
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
      } else {
        remove(this._container);
      }
    },
    // @namespace Popup
    // @method getLatLng: LatLng
    // Returns the geographical point of popup.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Sets the geographical point where the popup will open.
    setLatLng: function (latlng) {
      this._latlng = toLatLng(latlng);

      if (this._map) {
        this._updatePosition();

        this._adjustPan();
      }

      return this;
    },
    // @method getContent: String|HTMLElement
    // Returns the content of the popup.
    getContent: function () {
      return this._content;
    },
    // @method setContent(htmlContent: String|HTMLElement|Function): this
    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
    setContent: function (content) {
      this._content = content;
      this.update();
      return this;
    },
    // @method getElement: String|HTMLElement
    // Returns the HTML container of the popup.
    getElement: function () {
      return this._container;
    },
    // @method update: null
    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
    update: function () {
      if (!this._map) {
        return;
      }

      this._container.style.visibility = 'hidden';

      this._updateContent();

      this._updateLayout();

      this._updatePosition();

      this._container.style.visibility = '';

      this._adjustPan();
    },
    getEvents: function () {
      var events = {
        zoom: this._updatePosition,
        viewreset: this._updatePosition
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method isOpen: Boolean
    // Returns `true` when the popup is visible on the map.
    isOpen: function () {
      return !!this._map && this._map.hasLayer(this);
    },
    // @method bringToFront: this
    // Brings this popup in front of other popups (in the same map pane).
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings this popup to the back of other popups (in the same map pane).
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
      }

      return this;
    },
    _prepareOpen: function (parent, layer, latlng) {
      if (!(layer instanceof Layer)) {
        latlng = layer;
        layer = parent;
      }

      if (layer instanceof FeatureGroup) {
        for (var id in parent._layers) {
          layer = parent._layers[id];
          break;
        }
      }

      if (!latlng) {
        if (layer.getCenter) {
          latlng = layer.getCenter();
        } else if (layer.getLatLng) {
          latlng = layer.getLatLng();
        } else {
          throw new Error('Unable to get source layer LatLng.');
        }
      } // set overlay source to this layer


      this._source = layer; // update the overlay (content, layout, ect...)

      this.update();
      return latlng;
    },
    _updateContent: function () {
      if (!this._content) {
        return;
      }

      var node = this._contentNode;
      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

      if (typeof content === 'string') {
        node.innerHTML = content;
      } else {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }

        node.appendChild(content);
      }

      this.fire('contentupdate');
    },
    _updatePosition: function () {
      if (!this._map) {
        return;
      }

      var pos = this._map.latLngToLayerPoint(this._latlng),
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (this._zoomAnimated) {
        setPosition(this._container, pos.add(anchor));
      } else {
        offset = offset.add(pos).add(anchor);
      }

      var bottom = this._containerBottom = -offset.y,
          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)

      this._container.style.bottom = bottom + 'px';
      this._container.style.left = left + 'px';
    },
    _getAnchor: function () {
      return [0, 0];
    }
  });
  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   * Here's a more complicated way to open a popup on a map:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */
  // @namespace Popup

  var Popup = DivOverlay.extend({
    // @section
    // @aka Popup options
    options: {
      // @option maxWidth: Number = 300
      // Max width of the popup, in pixels.
      maxWidth: 300,
      // @option minWidth: Number = 50
      // Min width of the popup, in pixels.
      minWidth: 50,
      // @option maxHeight: Number = null
      // If set, creates a scrollable container of the given height
      // inside a popup if its content exceeds it.
      maxHeight: null,
      // @option autoPan: Boolean = true
      // Set it to `false` if you don't want the map to do panning animation
      // to fit the opened popup.
      autoPan: true,
      // @option autoPanPaddingTopLeft: Point = null
      // The margin between the popup and the top left corner of the map
      // view after autopanning was performed.
      autoPanPaddingTopLeft: null,
      // @option autoPanPaddingBottomRight: Point = null
      // The margin between the popup and the bottom right corner of the map
      // view after autopanning was performed.
      autoPanPaddingBottomRight: null,
      // @option autoPanPadding: Point = Point(5, 5)
      // Equivalent of setting both top left and bottom right autopan padding to the same value.
      autoPanPadding: [5, 5],
      // @option keepInView: Boolean = false
      // Set it to `true` if you want to prevent users from panning the popup
      // off of the screen while it is open.
      keepInView: false,
      // @option closeButton: Boolean = true
      // Controls the presence of a close button in the popup.
      closeButton: true,
      // @option autoClose: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the popup closing when another popup is opened.
      autoClose: true,
      // @option closeOnEscapeKey: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the ESC key for closing of the popup.
      closeOnEscapeKey: true,
      // @option closeOnClick: Boolean = *
      // Set it if you want to override the default behavior of the popup closing when user clicks
      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: ''
    },
    // @namespace Popup
    // @method openOn(map: Map): this
    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
    openOn: function (map) {
      map.openPopup(this);
      return this;
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupopen: PopupEvent
      // Fired when a popup is opened in the map

      map.fire('popupopen', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupopen: PopupEvent
        // Fired when a popup bound to this layer is opened
        this._source.fire('popupopen', {
          popup: this
        }, true); // For non-path layers, we toggle the popup when clicking
        // again the layer, so prevent the map to reopen it.


        if (!(this._source instanceof Path)) {
          this._source.on('preclick', stopPropagation);
        }
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupclose: PopupEvent
      // Fired when a popup in the map is closed

      map.fire('popupclose', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupclose: PopupEvent
        // Fired when a popup bound to this layer is closed
        this._source.fire('popupclose', {
          popup: this
        }, true);

        if (!(this._source instanceof Path)) {
          this._source.off('preclick', stopPropagation);
        }
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this._close;
      }

      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closePopup(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-popup',
          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');
      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
      this._contentNode = create$1('div', prefix + '-content', wrapper);
      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, 'contextmenu', stopPropagation);
      this._tipContainer = create$1('div', prefix + '-tip-container', container);
      this._tip = create$1('div', prefix + '-tip', this._tipContainer);

      if (this.options.closeButton) {
        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
        closeButton.href = '#close';
        closeButton.innerHTML = '&#215;';
        on(closeButton, 'click', this._onCloseButtonClick, this);
      }
    },
    _updateLayout: function () {
      var container = this._contentNode,
          style = container.style;
      style.width = '';
      style.whiteSpace = 'nowrap';
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = width + 1 + 'px';
      style.whiteSpace = '';
      style.height = '';
      var height = container.offsetHeight,
          maxHeight = this.options.maxHeight,
          scrolledClass = 'leaflet-popup-scrolled';

      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + 'px';
        addClass(container, scrolledClass);
      } else {
        removeClass(container, scrolledClass);
      }

      this._containerWidth = this._container.offsetWidth;
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
          anchor = this._getAnchor();

      setPosition(this._container, pos.add(anchor));
    },
    _adjustPan: function () {
      if (!this.options.autoPan) {
        return;
      }

      if (this._map._panAnim) {
        this._map._panAnim.stop();
      }

      var map = this._map,
          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
          containerHeight = this._container.offsetHeight + marginBottom,
          containerWidth = this._containerWidth,
          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

      layerPos._add(getPosition(this._container));

      var containerPos = map.layerPointToContainerPoint(layerPos),
          padding = toPoint(this.options.autoPanPadding),
          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
          size = map.getSize(),
          dx = 0,
          dy = 0;

      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        // right
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }

      if (containerPos.x - dx - paddingTL.x < 0) {
        // left
        dx = containerPos.x - paddingTL.x;
      }

      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        // bottom
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }

      if (containerPos.y - dy - paddingTL.y < 0) {
        // top
        dy = containerPos.y - paddingTL.y;
      } // @namespace Map
      // @section Popup events
      // @event autopanstart: Event
      // Fired when the map starts autopanning when opening a popup.


      if (dx || dy) {
        map.fire('autopanstart').panBy([dx, dy]);
      }
    },
    _onCloseButtonClick: function (e) {
      this._close();

      stop(e);
    },
    _getAnchor: function () {
      // Where should we anchor the popup on the source layer?
      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
    }
  }); // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.

  var popup = function (options, source) {
    return new Popup(options, source);
  };
  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */


  Map.mergeOptions({
    closePopupOnClick: true
  }); // @namespace Map
  // @section Methods for Layers and Controls

  Map.include({
    // @method openPopup(popup: Popup): this
    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
    // @alternative
    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
    // Creates a popup with the specified content and options and opens it in the given point on a map.
    openPopup: function (popup, latlng, options) {
      if (!(popup instanceof Popup)) {
        popup = new Popup(options).setContent(popup);
      }

      if (latlng) {
        popup.setLatLng(latlng);
      }

      if (this.hasLayer(popup)) {
        return this;
      }

      if (this._popup && this._popup.options.autoClose) {
        this.closePopup();
      }

      this._popup = popup;
      return this.addLayer(popup);
    },
    // @method closePopup(popup?: Popup): this
    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
    closePopup: function (popup) {
      if (!popup || popup === this._popup) {
        popup = this._popup;
        this._popup = null;
      }

      if (popup) {
        this.removeLayer(popup);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */
  // @section Popup methods

  Layer.include({
    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
    // Binds a popup to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindPopup: function (content, options) {
      if (content instanceof Popup) {
        setOptions(content, options);
        this._popup = content;
        content._source = this;
      } else {
        if (!this._popup || options) {
          this._popup = new Popup(options, this);
        }

        this._popup.setContent(content);
      }

      if (!this._popupHandlersAdded) {
        this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = true;
      }

      return this;
    },
    // @method unbindPopup(): this
    // Removes the popup previously bound with `bindPopup`.
    unbindPopup: function () {
      if (this._popup) {
        this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = false;
        this._popup = null;
      }

      return this;
    },
    // @method openPopup(latlng?: LatLng): this
    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
    openPopup: function (layer, latlng) {
      if (this._popup && this._map) {
        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map

        this._map.openPopup(this._popup, latlng);
      }

      return this;
    },
    // @method closePopup(): this
    // Closes the popup bound to this layer if it is open.
    closePopup: function () {
      if (this._popup) {
        this._popup._close();
      }

      return this;
    },
    // @method togglePopup(): this
    // Opens or closes the popup bound to this layer depending on its current state.
    togglePopup: function (target) {
      if (this._popup) {
        if (this._popup._map) {
          this.closePopup();
        } else {
          this.openPopup(target);
        }
      }

      return this;
    },
    // @method isPopupOpen(): boolean
    // Returns `true` if the popup bound to this layer is currently open.
    isPopupOpen: function () {
      return this._popup ? this._popup.isOpen() : false;
    },
    // @method setPopupContent(content: String|HTMLElement|Popup): this
    // Sets the content of the popup bound to this layer.
    setPopupContent: function (content) {
      if (this._popup) {
        this._popup.setContent(content);
      }

      return this;
    },
    // @method getPopup(): Popup
    // Returns the popup bound to this layer.
    getPopup: function () {
      return this._popup;
    },
    _openPopup: function (e) {
      var layer = e.layer || e.target;

      if (!this._popup) {
        return;
      }

      if (!this._map) {
        return;
      } // prevent map click


      stop(e); // if this inherits from Path its a vector and we can just
      // open the popup at the new location

      if (layer instanceof Path) {
        this.openPopup(e.layer || e.target, e.latlng);
        return;
      } // otherwise treat it like a marker and figure out
      // if we should toggle it open/closed


      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
        this.closePopup();
      } else {
        this.openPopup(layer, e.latlng);
      }
    },
    _movePopup: function (e) {
      this._popup.setLatLng(e.latlng);
    },
    _onKeyPress: function (e) {
      if (e.originalEvent.keyCode === 13) {
        this._openPopup(e);
      }
    }
  });
  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */
  // @namespace Tooltip

  var Tooltip = DivOverlay.extend({
    // @section
    // @aka Tooltip options
    options: {
      // @option pane: String = 'tooltipPane'
      // `Map pane` where the tooltip will be added.
      pane: 'tooltipPane',
      // @option offset: Point = Point(0, 0)
      // Optional offset of the tooltip position.
      offset: [0, 0],
      // @option direction: String = 'auto'
      // Direction where to open the tooltip. Possible values are: `right`, `left`,
      // `top`, `bottom`, `center`, `auto`.
      // `auto` will dynamically switch between `right` and `left` according to the tooltip
      // position on the map.
      direction: 'auto',
      // @option permanent: Boolean = false
      // Whether to open the tooltip permanently or only on mouseover.
      permanent: false,
      // @option sticky: Boolean = false
      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
      sticky: false,
      // @option interactive: Boolean = false
      // If true, the tooltip will listen to the feature events.
      interactive: false,
      // @option opacity: Number = 0.9
      // Tooltip container opacity.
      opacity: 0.9
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity); // @namespace Map
      // @section Tooltip events
      // @event tooltipopen: TooltipEvent
      // Fired when a tooltip is opened in the map.

      map.fire('tooltipopen', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipopen: TooltipEvent
        // Fired when a tooltip bound to this layer is opened.
        this._source.fire('tooltipopen', {
          tooltip: this
        }, true);
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Tooltip events
      // @event tooltipclose: TooltipEvent
      // Fired when a tooltip in the map is closed.

      map.fire('tooltipclose', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipclose: TooltipEvent
        // Fired when a tooltip bound to this layer is closed.
        this._source.fire('tooltipclose', {
          tooltip: this
        }, true);
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (touch && !this.options.permanent) {
        events.preclick = this._close;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closeTooltip(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-tooltip',
          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      this._contentNode = this._container = create$1('div', className);
    },
    _updateLayout: function () {},
    _adjustPan: function () {},
    _setPosition: function (pos) {
      var subX,
          subY,
          map = this._map,
          container = this._container,
          centerPoint = map.latLngToContainerPoint(map.getCenter()),
          tooltipPoint = map.layerPointToContainerPoint(pos),
          direction = this.options.direction,
          tooltipWidth = container.offsetWidth,
          tooltipHeight = container.offsetHeight,
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (direction === 'top') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight;
      } else if (direction === 'bottom') {
        subX = tooltipWidth / 2;
        subY = 0;
      } else if (direction === 'center') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight / 2;
      } else if (direction === 'right') {
        subX = 0;
        subY = tooltipHeight / 2;
      } else if (direction === 'left') {
        subX = tooltipWidth;
        subY = tooltipHeight / 2;
      } else if (tooltipPoint.x < centerPoint.x) {
        direction = 'right';
        subX = 0;
        subY = tooltipHeight / 2;
      } else {
        direction = 'left';
        subX = tooltipWidth + (offset.x + anchor.x) * 2;
        subY = tooltipHeight / 2;
      }

      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
      removeClass(container, 'leaflet-tooltip-right');
      removeClass(container, 'leaflet-tooltip-left');
      removeClass(container, 'leaflet-tooltip-top');
      removeClass(container, 'leaflet-tooltip-bottom');
      addClass(container, 'leaflet-tooltip-' + direction);
      setPosition(container, pos);
    },
    _updatePosition: function () {
      var pos = this._map.latLngToLayerPoint(this._latlng);

      this._setPosition(pos);
    },
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._container) {
        setOpacity(this._container, opacity);
      }
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);

      this._setPosition(pos);
    },
    _getAnchor: function () {
      // Where should we anchor the tooltip on the source layer?
      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
    }
  }); // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.

  var tooltip = function (options, source) {
    return new Tooltip(options, source);
  }; // @namespace Map
  // @section Methods for Layers and Controls


  Map.include({
    // @method openTooltip(tooltip: Tooltip): this
    // Opens the specified tooltip.
    // @alternative
    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
    // Creates a tooltip with the specified content and options and open it.
    openTooltip: function (tooltip, latlng, options) {
      if (!(tooltip instanceof Tooltip)) {
        tooltip = new Tooltip(options).setContent(tooltip);
      }

      if (latlng) {
        tooltip.setLatLng(latlng);
      }

      if (this.hasLayer(tooltip)) {
        return this;
      }

      return this.addLayer(tooltip);
    },
    // @method closeTooltip(tooltip?: Tooltip): this
    // Closes the tooltip given as parameter.
    closeTooltip: function (tooltip) {
      if (tooltip) {
        this.removeLayer(tooltip);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */
  // @section Tooltip methods

  Layer.include({
    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
    // Binds a tooltip to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindTooltip: function (content, options) {
      if (content instanceof Tooltip) {
        setOptions(content, options);
        this._tooltip = content;
        content._source = this;
      } else {
        if (!this._tooltip || options) {
          this._tooltip = new Tooltip(options, this);
        }

        this._tooltip.setContent(content);
      }

      this._initTooltipInteractions();

      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
        this.openTooltip();
      }

      return this;
    },
    // @method unbindTooltip(): this
    // Removes the tooltip previously bound with `bindTooltip`.
    unbindTooltip: function () {
      if (this._tooltip) {
        this._initTooltipInteractions(true);

        this.closeTooltip();
        this._tooltip = null;
      }

      return this;
    },
    _initTooltipInteractions: function (remove$$1) {
      if (!remove$$1 && this._tooltipHandlersAdded) {
        return;
      }

      var onOff = remove$$1 ? 'off' : 'on',
          events = {
        remove: this.closeTooltip,
        move: this._moveTooltip
      };

      if (!this._tooltip.options.permanent) {
        events.mouseover = this._openTooltip;
        events.mouseout = this.closeTooltip;

        if (this._tooltip.options.sticky) {
          events.mousemove = this._moveTooltip;
        }

        if (touch) {
          events.click = this._openTooltip;
        }
      } else {
        events.add = this._openTooltip;
      }

      this[onOff](events);
      this._tooltipHandlersAdded = !remove$$1;
    },
    // @method openTooltip(latlng?: LatLng): this
    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
    openTooltip: function (layer, latlng) {
      if (this._tooltip && this._map) {
        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map

        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never
        // opened.


        if (this._tooltip.options.interactive && this._tooltip._container) {
          addClass(this._tooltip._container, 'leaflet-clickable');
          this.addInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method closeTooltip(): this
    // Closes the tooltip bound to this layer if it is open.
    closeTooltip: function () {
      if (this._tooltip) {
        this._tooltip._close();

        if (this._tooltip.options.interactive && this._tooltip._container) {
          removeClass(this._tooltip._container, 'leaflet-clickable');
          this.removeInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method toggleTooltip(): this
    // Opens or closes the tooltip bound to this layer depending on its current state.
    toggleTooltip: function (target) {
      if (this._tooltip) {
        if (this._tooltip._map) {
          this.closeTooltip();
        } else {
          this.openTooltip(target);
        }
      }

      return this;
    },
    // @method isTooltipOpen(): boolean
    // Returns `true` if the tooltip bound to this layer is currently open.
    isTooltipOpen: function () {
      return this._tooltip.isOpen();
    },
    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
    // Sets the content of the tooltip bound to this layer.
    setTooltipContent: function (content) {
      if (this._tooltip) {
        this._tooltip.setContent(content);
      }

      return this;
    },
    // @method getTooltip(): Tooltip
    // Returns the tooltip bound to this layer.
    getTooltip: function () {
      return this._tooltip;
    },
    _openTooltip: function (e) {
      var layer = e.layer || e.target;

      if (!this._tooltip || !this._map) {
        return;
      }

      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
    },
    _moveTooltip: function (e) {
      var latlng = e.latlng,
          containerPoint,
          layerPoint;

      if (this._tooltip.options.sticky && e.originalEvent) {
        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
        latlng = this._map.layerPointToLatLng(layerPoint);
      }

      this._tooltip.setLatLng(latlng);
    }
  });
  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
    options: {
      // @section
      // @aka DivIcon options
      iconSize: [12, 12],
      // also can be set through CSS
      // iconAnchor: (Point),
      // popupAnchor: (Point),
      // @option html: String|HTMLElement = ''
      // Custom HTML code to put inside the div element, empty by default. Alternatively,
      // an instance of `HTMLElement`.
      html: false,
      // @option bgPos: Point = [0, 0]
      // Optional relative position of the background, in pixels
      bgPos: null,
      className: 'leaflet-div-icon'
    },
    createIcon: function (oldIcon) {
      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
          options = this.options;

      if (options.html instanceof Element) {
        empty(div);
        div.appendChild(options.html);
      } else {
        div.innerHTML = options.html !== false ? options.html : '';
      }

      if (options.bgPos) {
        var bgPos = toPoint(options.bgPos);
        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
      }

      this._setIconStyles(div, 'icon');

      return div;
    },
    createShadow: function () {
      return null;
    }
  }); // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.

  function divIcon(options) {
    return new DivIcon(options);
  }

  Icon.Default = IconDefault;
  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */

  var GridLayer = Layer.extend({
    // @section
    // @aka GridLayer options
    options: {
      // @option tileSize: Number|Point = 256
      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
      tileSize: 256,
      // @option opacity: Number = 1.0
      // Opacity of the tiles. Can be used in the `createTile()` function.
      opacity: 1,
      // @option updateWhenIdle: Boolean = (depends)
      // Load new tiles only when panning ends.
      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
      updateWhenIdle: mobile,
      // @option updateWhenZooming: Boolean = true
      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
      updateWhenZooming: true,
      // @option updateInterval: Number = 200
      // Tiles will not update more than once every `updateInterval` milliseconds when panning.
      updateInterval: 200,
      // @option zIndex: Number = 1
      // The explicit zIndex of the tile layer.
      zIndex: 1,
      // @option bounds: LatLngBounds = undefined
      // If set, tiles will only be loaded inside the set `LatLngBounds`.
      bounds: null,
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = undefined
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: undefined,
      // @option maxNativeZoom: Number = undefined
      // Maximum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
      // from `maxNativeZoom` level and auto-scaled.
      maxNativeZoom: undefined,
      // @option minNativeZoom: Number = undefined
      // Minimum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
      // from `minNativeZoom` level and auto-scaled.
      minNativeZoom: undefined,
      // @option noWrap: Boolean = false
      // Whether the layer is wrapped around the antimeridian. If `true`, the
      // GridLayer will only be displayed once at low zoom levels. Has no
      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
      // tiles outside the CRS limits.
      noWrap: false,
      // @option pane: String = 'tilePane'
      // `Map pane` where the grid layer will be added.
      pane: 'tilePane',
      // @option className: String = ''
      // A custom class name to assign to the tile layer. Empty by default.
      className: '',
      // @option keepBuffer: Number = 2
      // When panning the map, keep this many rows and columns of tiles before unloading them.
      keepBuffer: 2
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    onAdd: function () {
      this._initContainer();

      this._levels = {};
      this._tiles = {};

      this._resetView();

      this._update();
    },
    beforeAdd: function (map) {
      map._addZoomLimit(this);
    },
    onRemove: function (map) {
      this._removeAllTiles();

      remove(this._container);

      map._removeZoomLimit(this);

      this._container = null;
      this._tileZoom = undefined;
    },
    // @method bringToFront: this
    // Brings the tile layer to the top of all tile layers.
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);

        this._setAutoZIndex(Math.max);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings the tile layer to the bottom of all tile layers.
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);

        this._setAutoZIndex(Math.min);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the tiles for this layer.
    getContainer: function () {
      return this._container;
    },
    // @method setOpacity(opacity: Number): this
    // Changes the [opacity](#gridlayer-opacity) of the grid layer.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      this._updateOpacity();

      return this;
    },
    // @method setZIndex(zIndex: Number): this
    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
    setZIndex: function (zIndex) {
      this.options.zIndex = zIndex;

      this._updateZIndex();

      return this;
    },
    // @method isLoading: Boolean
    // Returns `true` if any tile in the grid layer has not finished loading.
    isLoading: function () {
      return this._loading;
    },
    // @method redraw: this
    // Causes the layer to clear all the tiles and request them again.
    redraw: function () {
      if (this._map) {
        this._removeAllTiles();

        this._update();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd
      };

      if (!this.options.updateWhenIdle) {
        // update tiles on move, but not more often than once per given interval
        if (!this._onMove) {
          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
        }

        events.move = this._onMove;
      }

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @section Extension methods
    // Layers extending `GridLayer` shall reimplement the following method.
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, must be overridden by classes extending `GridLayer`.
    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
    // is specified, it must be called when the tile has finished loading and drawing.
    createTile: function () {
      return document.createElement('div');
    },
    // @section
    // @method getTileSize: Point
    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
    getTileSize: function () {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    },
    _updateZIndex: function () {
      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },
    _setAutoZIndex: function (compare) {
      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
      var layers = this.getPane().children,
          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

      for (var i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex;

        if (layers[i] !== this._container && zIndex) {
          edgeZIndex = compare(edgeZIndex, +zIndex);
        }
      }

      if (isFinite(edgeZIndex)) {
        this.options.zIndex = edgeZIndex + compare(-1, 1);

        this._updateZIndex();
      }
    },
    _updateOpacity: function () {
      if (!this._map) {
        return;
      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles


      if (ielt9) {
        return;
      }

      setOpacity(this._container, this.options.opacity);
      var now = +new Date(),
          nextFrame = false,
          willPrune = false;

      for (var key in this._tiles) {
        var tile = this._tiles[key];

        if (!tile.current || !tile.loaded) {
          continue;
        }

        var fade = Math.min(1, (now - tile.loaded) / 200);
        setOpacity(tile.el, fade);

        if (fade < 1) {
          nextFrame = true;
        } else {
          if (tile.active) {
            willPrune = true;
          } else {
            this._onOpaqueTile(tile);
          }

          tile.active = true;
        }
      }

      if (willPrune && !this._noPrune) {
        this._pruneTiles();
      }

      if (nextFrame) {
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      }
    },
    _onOpaqueTile: falseFn,
    _initContainer: function () {
      if (this._container) {
        return;
      }

      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));

      this._updateZIndex();

      if (this.options.opacity < 1) {
        this._updateOpacity();
      }

      this.getPane().appendChild(this._container);
    },
    _updateLevels: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom;

      if (zoom === undefined) {
        return undefined;
      }

      for (var z in this._levels) {
        z = Number(z);

        if (this._levels[z].el.children.length || z === zoom) {
          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);

          this._onUpdateLevel(z);
        } else {
          remove(this._levels[z].el);

          this._removeTilesAtZoom(z);

          this._onRemoveLevel(z);

          delete this._levels[z];
        }
      }

      var level = this._levels[zoom],
          map = this._map;

      if (!level) {
        level = this._levels[zoom] = {};
        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
        level.el.style.zIndex = maxZoom;
        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
        level.zoom = zoom;

        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition


        falseFn(level.el.offsetWidth);

        this._onCreateLevel(level);
      }

      this._level = level;
      return level;
    },
    _onUpdateLevel: falseFn,
    _onRemoveLevel: falseFn,
    _onCreateLevel: falseFn,
    _pruneTiles: function () {
      if (!this._map) {
        return;
      }

      var key, tile;

      var zoom = this._map.getZoom();

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._removeAllTiles();

        return;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];
        tile.retain = tile.current;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];

        if (tile.current && !tile.active) {
          var coords = tile.coords;

          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
          }
        }
      }

      for (key in this._tiles) {
        if (!this._tiles[key].retain) {
          this._removeTile(key);
        }
      }
    },
    _removeTilesAtZoom: function (zoom) {
      for (var key in this._tiles) {
        if (this._tiles[key].coords.z !== zoom) {
          continue;
        }

        this._removeTile(key);
      }
    },
    _removeAllTiles: function () {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    },
    _invalidateAll: function () {
      for (var z in this._levels) {
        remove(this._levels[z].el);

        this._onRemoveLevel(Number(z));

        delete this._levels[z];
      }

      this._removeAllTiles();

      this._tileZoom = undefined;
    },
    _retainParent: function (x, y, z, minZoom) {
      var x2 = Math.floor(x / 2),
          y2 = Math.floor(y / 2),
          z2 = z - 1,
          coords2 = new Point(+x2, +y2);
      coords2.z = +z2;

      var key = this._tileCoordsToKey(coords2),
          tile = this._tiles[key];

      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }

      if (z2 > minZoom) {
        return this._retainParent(x2, y2, z2, minZoom);
      }

      return false;
    },
    _retainChildren: function (x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;

          var key = this._tileCoordsToKey(coords),
              tile = this._tiles[key];

          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }

          if (z + 1 < maxZoom) {
            this._retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    },
    _resetView: function (e) {
      var animating = e && (e.pinch || e.flyTo);

      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
    },
    _animateZoom: function (e) {
      this._setView(e.center, e.zoom, true, e.noUpdate);
    },
    _clampZoom: function (zoom) {
      var options = this.options;

      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
        return options.minNativeZoom;
      }

      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
        return options.maxNativeZoom;
      }

      return zoom;
    },
    _setView: function (center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);

      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
        tileZoom = undefined;
      } else {
        tileZoom = this._clampZoom(tileZoom);
      }

      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom;

        if (this._abortLoading) {
          this._abortLoading();
        }

        this._updateLevels();

        this._resetGrid();

        if (tileZoom !== undefined) {
          this._update(center);
        }

        if (!noPrune) {
          this._pruneTiles();
        } // Flag to prevent _updateOpacity from pruning tiles during
        // a zoom anim or a pinch gesture


        this._noPrune = !!noPrune;
      }

      this._setZoomTransforms(center, zoom);
    },
    _setZoomTransforms: function (center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    },
    _setZoomTransform: function (level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom),
          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

      if (any3d) {
        setTransform(level.el, translate, scale);
      } else {
        setPosition(level.el, translate);
      }
    },
    _resetGrid: function () {
      var map = this._map,
          crs = map.options.crs,
          tileSize = this._tileSize = this.getTileSize(),
          tileZoom = this._tileZoom;

      var bounds = this._map.getPixelWorldBounds(this._tileZoom);

      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }

      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
    },
    _onMoveEnd: function () {
      if (!this._map || this._map._animatingZoom) {
        return;
      }

      this._update();
    },
    _getTiledPixelBounds: function (center) {
      var map = this._map,
          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
          scale = map.getZoomScale(mapZoom, this._tileZoom),
          pixelCenter = map.project(center, this._tileZoom).floor(),
          halfSize = map.getSize().divideBy(scale * 2);
      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },
    // Private method to load tiles in the grid's active zoom level according to map bounds
    _update: function (center) {
      var map = this._map;

      if (!map) {
        return;
      }

      var zoom = this._clampZoom(map.getZoom());

      if (center === undefined) {
        center = map.getCenter();
      }

      if (this._tileZoom === undefined) {
        return;
      } // if out of minzoom/maxzoom


      var pixelBounds = this._getTiledPixelBounds(center),
          tileRange = this._pxBoundsToTileRange(pixelBounds),
          tileCenter = tileRange.getCenter(),
          queue = [],
          margin = this.options.keepBuffer,
          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.


      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
        throw new Error('Attempted to load an infinite number of tiles');
      }

      for (var key in this._tiles) {
        var c = this._tiles[key].coords;

        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
          this._tiles[key].current = false;
        }
      } // _update just loads more tiles. If the tile zoom level differs too much
      // from the map's, let _setView reset levels and prune old tiles.


      if (Math.abs(zoom - this._tileZoom) > 1) {
        this._setView(center, zoom);

        return;
      } // create a queue of coordinates to load tiles from


      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = new Point(i, j);
          coords.z = this._tileZoom;

          if (!this._isValidTile(coords)) {
            continue;
          }

          var tile = this._tiles[this._tileCoordsToKey(coords)];

          if (tile) {
            tile.current = true;
          } else {
            queue.push(coords);
          }
        }
      } // sort tile queue to load tiles in order of their distance to center


      queue.sort(function (a, b) {
        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
      });

      if (queue.length !== 0) {
        // if it's the first batch of tiles to load
        if (!this._loading) {
          this._loading = true; // @event loading: Event
          // Fired when the grid layer starts loading tiles.

          this.fire('loading');
        } // create DOM fragment to append tiles in one batch


        var fragment = document.createDocumentFragment();

        for (i = 0; i < queue.length; i++) {
          this._addTile(queue[i], fragment);
        }

        this._level.el.appendChild(fragment);
      }
    },
    _isValidTile: function (coords) {
      var crs = this._map.options.crs;

      if (!crs.infinite) {
        // don't load tile if it's out of bounds and not wrapped
        var bounds = this._globalTileRange;

        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
          return false;
        }
      }

      if (!this.options.bounds) {
        return true;
      } // don't load tile if it doesn't intersect the bounds in options


      var tileBounds = this._tileCoordsToBounds(coords);

      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
    },
    _keyToBounds: function (key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    },
    _tileCoordsToNwSe: function (coords) {
      var map = this._map,
          tileSize = this.getTileSize(),
          nwPoint = coords.scaleBy(tileSize),
          sePoint = nwPoint.add(tileSize),
          nw = map.unproject(nwPoint, coords.z),
          se = map.unproject(sePoint, coords.z);
      return [nw, se];
    },
    // converts tile coordinates to its geographical bounds
    _tileCoordsToBounds: function (coords) {
      var bp = this._tileCoordsToNwSe(coords),
          bounds = new LatLngBounds(bp[0], bp[1]);

      if (!this.options.noWrap) {
        bounds = this._map.wrapLatLngBounds(bounds);
      }

      return bounds;
    },
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords) {
      return coords.x + ':' + coords.y + ':' + coords.z;
    },
    // converts tile cache key to coordinates
    _keyToTileCoords: function (key) {
      var k = key.split(':'),
          coords = new Point(+k[0], +k[1]);
      coords.z = +k[2];
      return coords;
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      }

      remove(tile.el);
      delete this._tiles[key]; // @event tileunload: TileEvent
      // Fired when a tile is removed (e.g. when a tile goes off the screen).

      this.fire('tileunload', {
        tile: tile.el,
        coords: this._keyToTileCoords(key)
      });
    },
    _initTile: function (tile) {
      addClass(tile, 'leaflet-tile');
      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + 'px';
      tile.style.height = tileSize.y + 'px';
      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems

      if (ielt9 && this.options.opacity < 1) {
        setOpacity(tile, this.options.opacity);
      } // without this hack, tiles disappear after zoom on Chrome for Android
      // https://github.com/Leaflet/Leaflet/issues/2078


      if (android && !android23) {
        tile.style.WebkitBackfaceVisibility = 'hidden';
      }
    },
    _addTile: function (coords, container) {
      var tilePos = this._getTilePos(coords),
          key = this._tileCoordsToKey(coords);

      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

      this._initTile(tile); // if createTile is defined with a second argument ("done" callback),
      // we know that tile is async and will be ready later; otherwise


      if (this.createTile.length < 2) {
        // mark tile as ready, but delay one frame for opacity animation to happen
        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      }

      setPosition(tile, tilePos); // save tile in cache

      this._tiles[key] = {
        el: tile,
        coords: coords,
        current: true
      };
      container.appendChild(tile); // @event tileloadstart: TileEvent
      // Fired when a tile is requested and starts loading.

      this.fire('tileloadstart', {
        tile: tile,
        coords: coords
      });
    },
    _tileReady: function (coords, err, tile) {
      if (err) {
        // @event tileerror: TileErrorEvent
        // Fired when there is an error loading a tile.
        this.fire('tileerror', {
          error: err,
          tile: tile,
          coords: coords
        });
      }

      var key = this._tileCoordsToKey(coords);

      tile = this._tiles[key];

      if (!tile) {
        return;
      }

      tile.loaded = +new Date();

      if (this._map._fadeAnimated) {
        setOpacity(tile.el, 0);
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      } else {
        tile.active = true;

        this._pruneTiles();
      }

      if (!err) {
        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent
        // Fired when a tile loads.

        this.fire('tileload', {
          tile: tile.el,
          coords: coords
        });
      }

      if (this._noTilesToLoad()) {
        this._loading = false; // @event load: Event
        // Fired when the grid layer loaded all visible tiles.

        this.fire('load');

        if (ielt9 || !this._map._fadeAnimated) {
          requestAnimFrame(this._pruneTiles, this);
        } else {
          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
          // to trigger a pruning.
          setTimeout(bind(this._pruneTiles, this), 250);
        }
      }
    },
    _getTilePos: function (coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    },
    _wrapCoords: function (coords) {
      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
      newCoords.z = coords.z;
      return newCoords;
    },
    _pxBoundsToTileRange: function (bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
    },
    _noTilesToLoad: function () {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return false;
        }
      }

      return true;
    }
  }); // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.

  function gridLayer(options) {
    return new GridLayer(options);
  }
  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({
    // @section
    // @aka TileLayer options
    options: {
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = 18
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: 18,
      // @option subdomains: String|String[] = 'abc'
      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
      subdomains: 'abc',
      // @option errorTileUrl: String = ''
      // URL to the tile image to show in place of the tile that failed to load.
      errorTileUrl: '',
      // @option zoomOffset: Number = 0
      // The zoom number used in tile URLs will be offset with this value.
      zoomOffset: 0,
      // @option tms: Boolean = false
      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
      tms: false,
      // @option zoomReverse: Boolean = false
      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
      zoomReverse: false,
      // @option detectRetina: Boolean = false
      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
      detectRetina: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false
    },
    initialize: function (url, options) {
      this._url = url;
      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels

      if (options.detectRetina && retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);

        if (!options.zoomReverse) {
          options.zoomOffset++;
          options.maxZoom--;
        } else {
          options.zoomOffset--;
          options.minZoom++;
        }

        options.minZoom = Math.max(0, options.minZoom);
      }

      if (typeof options.subdomains === 'string') {
        options.subdomains = options.subdomains.split('');
      } // for https://github.com/Leaflet/Leaflet/issues/137


      if (!android) {
        this.on('tileunload', this._onTileRemove);
      }
    },
    // @method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    // If the URL does not change, the layer will not be redrawn unless
    // the noRedraw parameter is set to false.
    setUrl: function (url, noRedraw) {
      if (this._url === url && noRedraw === undefined) {
        noRedraw = true;
      }

      this._url = url;

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    },
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
    // callback is called when the tile has been loaded.
    createTile: function (coords, done) {
      var tile = document.createElement('img');
      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
      on(tile, 'error', bind(this._tileOnError, this, done, tile));

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }
      /*
       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
       http://www.w3.org/TR/WCAG20-TECHS/H67
      */


      tile.alt = '';
      /*
       Set role="presentation" to force screen readers to ignore this
       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
      */

      tile.setAttribute('role', 'presentation');
      tile.src = this.getTileUrl(coords);
      return tile;
    },
    // @section Extension methods
    // @uninheritable
    // Layers extending `TileLayer` might reimplement the following method.
    // @method getTileUrl(coords: Object): String
    // Called only internally, returns the URL for a tile given its coordinates.
    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
    getTileUrl: function (coords) {
      var data = {
        r: retina ? '@2x' : '',
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: this._getZoomForUrl()
      };

      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;

        if (this.options.tms) {
          data['y'] = invertedY;
        }

        data['-y'] = invertedY;
      }

      return template(this._url, extend(data, this.options));
    },
    _tileOnLoad: function (done, tile) {
      // For https://github.com/Leaflet/Leaflet/issues/3332
      if (ielt9) {
        setTimeout(bind(done, this, null, tile), 0);
      } else {
        done(null, tile);
      }
    },
    _tileOnError: function (done, tile, e) {
      var errorUrl = this.options.errorTileUrl;

      if (errorUrl && tile.getAttribute('src') !== errorUrl) {
        tile.src = errorUrl;
      }

      done(e, tile);
    },
    _onTileRemove: function (e) {
      e.tile.onload = null;
    },
    _getZoomForUrl: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom,
          zoomReverse = this.options.zoomReverse,
          zoomOffset = this.options.zoomOffset;

      if (zoomReverse) {
        zoom = maxZoom - zoom;
      }

      return zoom + zoomOffset;
    },
    _getSubdomain: function (tilePoint) {
      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },
    // stops loading all tiles in the background layer
    _abortLoading: function () {
      var i, tile;

      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          tile = this._tiles[i].el;
          tile.onload = falseFn;
          tile.onerror = falseFn;

          if (!tile.complete) {
            tile.src = emptyImageUrl;
            remove(tile);
            delete this._tiles[i];
          }
        }
      }
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      } // Cancels any pending http requests associated with the tile
      // unless we're on Android's stock browser,
      // see https://github.com/Leaflet/Leaflet/issues/137


      if (!androidStock) {
        tile.el.setAttribute('src', emptyImageUrl);
      }

      return GridLayer.prototype._removeTile.call(this, key);
    },
    _tileReady: function (coords, err, tile) {
      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {
        return;
      }

      return GridLayer.prototype._tileReady.call(this, coords, err, tile);
    }
  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
    return new TileLayer(url, options);
  }
  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data © 2012 IEM Nexrad"
   * });
   * ```
   */


  var TileLayerWMS = TileLayer.extend({
    // @section
    // @aka TileLayer.WMS options
    // If any custom options not documented here are used, they will be sent to the
    // WMS server as extra parameters in each request URL. This can be useful for
    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
    defaultWmsParams: {
      service: 'WMS',
      request: 'GetMap',
      // @option layers: String = ''
      // **(required)** Comma-separated list of WMS layers to show.
      layers: '',
      // @option styles: String = ''
      // Comma-separated list of WMS styles.
      styles: '',
      // @option format: String = 'image/jpeg'
      // WMS image format (use `'image/png'` for layers with transparency).
      format: 'image/jpeg',
      // @option transparent: Boolean = false
      // If `true`, the WMS service will return images with transparency.
      transparent: false,
      // @option version: String = '1.1.1'
      // Version of the WMS service to use
      version: '1.1.1'
    },
    options: {
      // @option crs: CRS = null
      // Coordinate Reference System to use for the WMS requests, defaults to
      // map CRS. Don't change this if you're not sure what it means.
      crs: null,
      // @option uppercase: Boolean = false
      // If `true`, WMS request parameter keys will be uppercase.
      uppercase: false
    },
    initialize: function (url, options) {
      this._url = url;
      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params

      for (var i in options) {
        if (!(i in this.options)) {
          wmsParams[i] = options[i];
        }
      }

      options = setOptions(this, options);
      var realRetina = options.detectRetina && retina ? 2 : 1;
      var tileSize = this.getTileSize();
      wmsParams.width = tileSize.x * realRetina;
      wmsParams.height = tileSize.y * realRetina;
      this.wmsParams = wmsParams;
    },
    onAdd: function (map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
      this.wmsParams[projectionKey] = this._crs.code;
      TileLayer.prototype.onAdd.call(this, map);
    },
    getTileUrl: function (coords) {
      var tileBounds = this._tileCoordsToNwSe(coords),
          crs = this._crs,
          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
          min = bounds.min,
          max = bounds.max,
          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
          url = TileLayer.prototype.getTileUrl.call(this, coords);

      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
    },
    // @method setParams(params: Object, noRedraw?: Boolean): this
    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
    setParams: function (params, noRedraw) {
      extend(this.wmsParams, params);

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    }
  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.

  function tileLayerWMS(url, options) {
    return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;
  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({
    // @section
    // @aka Renderer options
    options: {
      // @option padding: Number = 0.1
      // How much to extend the clip area around the map view (relative to its size)
      // e.g. 0.1 would be 10% of map view in each direction
      padding: 0.1,
      // @option tolerance: Number = 0
      // How much to extend click tolerance round a path/object on the map
      tolerance: 0
    },
    initialize: function (options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    },
    onAdd: function () {
      if (!this._container) {
        this._initContainer(); // defined by renderer implementations


        if (this._zoomAnimated) {
          addClass(this._container, 'leaflet-zoom-animated');
        }
      }

      this.getPane().appendChild(this._container);

      this._update();

      this.on('update', this._updatePaths, this);
    },
    onRemove: function () {
      this.off('update', this._updatePaths, this);

      this._destroyContainer();
    },
    getEvents: function () {
      var events = {
        viewreset: this._reset,
        zoom: this._onZoom,
        moveend: this._update,
        zoomend: this._onZoomEnd
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._onAnimZoom;
      }

      return events;
    },
    _onAnimZoom: function (ev) {
      this._updateTransform(ev.center, ev.zoom);
    },
    _onZoom: function () {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    },
    _updateTransform: function (center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom),
          position = getPosition(this._container),
          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
          currentCenterPoint = this._map.project(this._center, zoom),
          destCenterPoint = this._map.project(center, zoom),
          centerOffset = destCenterPoint.subtract(currentCenterPoint),
          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

      if (any3d) {
        setTransform(this._container, topLeftOffset, scale);
      } else {
        setPosition(this._container, topLeftOffset);
      }
    },
    _reset: function () {
      this._update();

      this._updateTransform(this._center, this._zoom);

      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    },
    _onZoomEnd: function () {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    },
    _updatePaths: function () {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    },
    _update: function () {
      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
      // Subclasses are responsible of firing the 'update' event.
      var p = this.options.padding,
          size = this._map.getSize(),
          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }
  });
  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    },
    _onViewPreReset: function () {
      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
      this._postponeUpdatePaths = true;
    },
    onAdd: function () {
      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,
      // in case of removing the renderer itself from the map.

      this._draw();
    },
    _initContainer: function () {
      var container = this._container = document.createElement('canvas');
      on(container, 'mousemove', this._onMouseMove, this);
      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
      on(container, 'mouseout', this._handleMouseOut, this);
      this._ctx = container.getContext('2d');
    },
    _destroyContainer: function () {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    },
    _updatePaths: function () {
      if (this._postponeUpdatePaths) {
        return;
      }

      var layer;
      this._redrawBounds = null;

      for (var id in this._layers) {
        layer = this._layers[id];

        layer._update();
      }

      this._redraw();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          container = this._container,
          size = b.getSize(),
          m = retina ? 2 : 1;
      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina

      container.width = m * size.x;
      container.height = m * size.y;
      container.style.width = size.x + 'px';
      container.style.height = size.y + 'px';

      if (retina) {
        this._ctx.scale(2, 2);
      } // translate so we use the same path coordinates after canvas element moves


      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves


      this.fire('update');
    },
    _reset: function () {
      Renderer.prototype._reset.call(this);

      if (this._postponeUpdatePaths) {
        this._postponeUpdatePaths = false;

        this._updatePaths();
      }
    },
    _initPath: function (layer) {
      this._updateDashArray(layer);

      this._layers[stamp(layer)] = layer;
      var order = layer._order = {
        layer: layer,
        prev: this._drawLast,
        next: null
      };

      if (this._drawLast) {
        this._drawLast.next = order;
      }

      this._drawLast = order;
      this._drawFirst = this._drawFirst || this._drawLast;
    },
    _addPath: function (layer) {
      this._requestRedraw(layer);
    },
    _removePath: function (layer) {
      var order = layer._order;
      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        this._drawLast = prev;
      }

      if (prev) {
        prev.next = next;
      } else {
        this._drawFirst = next;
      }

      delete layer._order;
      delete this._layers[stamp(layer)];

      this._requestRedraw(layer);
    },
    _updatePath: function (layer) {
      // Redraw the union of the layer's old pixel
      // bounds and the new pixel bounds.
      this._extendRedrawBounds(layer);

      layer._project();

      layer._update(); // The redraw will extend the redraw bounds
      // with the new pixel bounds.


      this._requestRedraw(layer);
    },
    _updateStyle: function (layer) {
      this._updateDashArray(layer);

      this._requestRedraw(layer);
    },
    _updateDashArray: function (layer) {
      if (typeof layer.options.dashArray === 'string') {
        var parts = layer.options.dashArray.split(/[, ]+/),
            dashArray = [],
            dashValue,
            i;

        for (i = 0; i < parts.length; i++) {
          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths

          if (isNaN(dashValue)) {
            return;
          }

          dashArray.push(dashValue);
        }

        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    },
    _requestRedraw: function (layer) {
      if (!this._map) {
        return;
      }

      this._extendRedrawBounds(layer);

      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
    },
    _extendRedrawBounds: function (layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();

        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));

        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    },
    _redraw: function () {
      this._redrawRequest = null;

      if (this._redrawBounds) {
        this._redrawBounds.min._floor();

        this._redrawBounds.max._ceil();
      }

      this._clear(); // clear layers in redraw bounds


      this._draw(); // draw layers


      this._redrawBounds = null;
    },
    _clear: function () {
      var bounds = this._redrawBounds;

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save();

        this._ctx.setTransform(1, 0, 0, 1, 0, 0);

        this._ctx.clearRect(0, 0, this._container.width, this._container.height);

        this._ctx.restore();
      }
    },
    _draw: function () {
      var layer,
          bounds = this._redrawBounds;

      this._ctx.save();

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.beginPath();

        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);

        this._ctx.clip();
      }

      this._drawing = true;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
          layer._updatePath();
        }
      }

      this._drawing = false;

      this._ctx.restore(); // Restore state before clipping.

    },
    _updatePoly: function (layer, closed) {
      if (!this._drawing) {
        return;
      }

      var i,
          j,
          len2,
          p,
          parts = layer._parts,
          len = parts.length,
          ctx = this._ctx;

      if (!len) {
        return;
      }

      ctx.beginPath();

      for (i = 0; i < len; i++) {
        for (j = 0, len2 = parts[i].length; j < len2; j++) {
          p = parts[i][j];
          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
        }

        if (closed) {
          ctx.closePath();
        }
      }

      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature

    },
    _updateCircle: function (layer) {
      if (!this._drawing || layer._empty()) {
        return;
      }

      var p = layer._point,
          ctx = this._ctx,
          r = Math.max(Math.round(layer._radius), 1),
          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }

      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

      if (s !== 1) {
        ctx.restore();
      }

      this._fillStroke(ctx, layer);
    },
    _fillStroke: function (ctx, layer) {
      var options = layer.options;

      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fillStyle = options.fillColor || options.color;
        ctx.fill(options.fillRule || 'evenodd');
      }

      if (options.stroke && options.weight !== 0) {
        if (ctx.setLineDash) {
          ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }

        ctx.globalAlpha = options.opacity;
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        ctx.lineCap = options.lineCap;
        ctx.lineJoin = options.lineJoin;
        ctx.stroke();
      }
    },
    // Canvas obviously doesn't have mouse events for individual drawn objects,
    // so we emulate that by calculating what's under the mouse on mousemove/click manually
    _onClick: function (e) {
      var point = this._map.mouseEventToLayerPoint(e),
          layer,
          clickedLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          if (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {
            clickedLayer = layer;
          }
        }
      }

      if (clickedLayer) {
        fakeStop(e);

        this._fireEvent([clickedLayer], e);
      }
    },
    _onMouseMove: function (e) {
      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
        return;
      }

      var point = this._map.mouseEventToLayerPoint(e);

      this._handleMouseHover(e, point);
    },
    _handleMouseOut: function (e) {
      var layer = this._hoveredLayer;

      if (layer) {
        // if we're leaving the layer, fire mouseout
        removeClass(this._container, 'leaflet-interactive');

        this._fireEvent([layer], e, 'mouseout');

        this._hoveredLayer = null;
        this._mouseHoverThrottled = false;
      }
    },
    _handleMouseHover: function (e, point) {
      if (this._mouseHoverThrottled) {
        return;
      }

      var layer, candidateHoveredLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          candidateHoveredLayer = layer;
        }
      }

      if (candidateHoveredLayer !== this._hoveredLayer) {
        this._handleMouseOut(e);

        if (candidateHoveredLayer) {
          addClass(this._container, 'leaflet-interactive'); // change cursor

          this._fireEvent([candidateHoveredLayer], e, 'mouseover');

          this._hoveredLayer = candidateHoveredLayer;
        }
      }

      if (this._hoveredLayer) {
        this._fireEvent([this._hoveredLayer], e);
      }

      this._mouseHoverThrottled = true;
      setTimeout(bind(function () {
        this._mouseHoverThrottled = false;
      }, this), 32);
    },
    _fireEvent: function (layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    },
    _bringToFront: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        // Already last
        return;
      }

      if (prev) {
        prev.next = next;
      } else if (next) {
        // Update first entry unless this is the
        // single entry
        this._drawFirst = next;
      }

      order.prev = this._drawLast;
      this._drawLast.next = order;
      order.next = null;
      this._drawLast = order;

      this._requestRedraw(layer);
    },
    _bringToBack: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (prev) {
        prev.next = next;
      } else {
        // Already first
        return;
      }

      if (next) {
        next.prev = prev;
      } else if (prev) {
        // Update last entry unless this is the
        // single entry
        this._drawLast = prev;
      }

      order.prev = null;
      order.next = this._drawFirst;
      this._drawFirst.prev = order;
      this._drawFirst = order;

      this._requestRedraw(layer);
    }
  }); // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.

  function canvas$1(options) {
    return canvas ? new Canvas(options) : null;
  }
  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = function () {
    try {
      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
      return function (name) {
        return document.createElement('<lvml:' + name + ' class="lvml">');
      };
    } catch (e) {
      return function (name) {
        return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }
  }();
  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */
  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences


  var vmlMixin = {
    _initContainer: function () {
      this._container = create$1('div', 'leaflet-vml-container');
    },
    _update: function () {
      if (this._map._animatingZoom) {
        return;
      }

      Renderer.prototype._update.call(this);

      this.fire('update');
    },
    _initPath: function (layer) {
      var container = layer._container = vmlCreate('shape');
      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));
      container.coordsize = '1 1';
      layer._path = vmlCreate('path');
      container.appendChild(layer._path);

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      var container = layer._container;

      this._container.appendChild(container);

      if (layer.options.interactive) {
        layer.addInteractiveTarget(container);
      }
    },
    _removePath: function (layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    },
    _updateStyle: function (layer) {
      var stroke = layer._stroke,
          fill = layer._fill,
          options = layer.options,
          container = layer._container;
      container.stroked = !!options.stroke;
      container.filled = !!options.fill;

      if (options.stroke) {
        if (!stroke) {
          stroke = layer._stroke = vmlCreate('stroke');
        }

        container.appendChild(stroke);
        stroke.weight = options.weight + 'px';
        stroke.color = options.color;
        stroke.opacity = options.opacity;

        if (options.dashArray) {
          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
        } else {
          stroke.dashStyle = '';
        }

        stroke.endcap = options.lineCap.replace('butt', 'flat');
        stroke.joinstyle = options.lineJoin;
      } else if (stroke) {
        container.removeChild(stroke);
        layer._stroke = null;
      }

      if (options.fill) {
        if (!fill) {
          fill = layer._fill = vmlCreate('fill');
        }

        container.appendChild(fill);
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        layer._fill = null;
      }
    },
    _updateCircle: function (layer) {
      var p = layer._point.round(),
          r = Math.round(layer._radius),
          r2 = Math.round(layer._radiusY || r);

      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
    },
    _setPath: function (layer, path) {
      layer._path.v = path;
    },
    _bringToFront: function (layer) {
      toFront(layer._container);
    },
    _bringToBack: function (layer) {
      toBack(layer._container);
    }
  };
  var create$2 = vml ? vmlCreate : svgCreate;
  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.zoomstart = this._onZoomStart;
      return events;
    },
    _initContainer: function () {
      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths

      this._container.setAttribute('pointer-events', 'none');

      this._rootGroup = create$2('g');

      this._container.appendChild(this._rootGroup);
    },
    _destroyContainer: function () {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    },
    _onZoomStart: function () {
      // Drag-then-pinch interactions might mess up the center and zoom.
      // In this case, the easiest way to prevent this is re-do the renderer
      //   bounds and padding when the zooming starts.
      this._update();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          size = b.getSize(),
          container = this._container; // set size of svg-container if changed

      if (!this._svgSize || !this._svgSize.equals(size)) {
        this._svgSize = size;
        container.setAttribute('width', size.x);
        container.setAttribute('height', size.y);
      } // movement: update container viewBox so that we don't have to change coordinates of individual layers


      setPosition(container, b.min);
      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
      this.fire('update');
    },
    // methods below are called by vector layers implementations
    _initPath: function (layer) {
      var path = layer._path = create$2('path'); // @namespace Path
      // @option className: String = null
      // Custom class name set on an element. Only for SVG renderer.

      if (layer.options.className) {
        addClass(path, layer.options.className);
      }

      if (layer.options.interactive) {
        addClass(path, 'leaflet-interactive');
      }

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      if (!this._rootGroup) {
        this._initContainer();
      }

      this._rootGroup.appendChild(layer._path);

      layer.addInteractiveTarget(layer._path);
    },
    _removePath: function (layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    },
    _updatePath: function (layer) {
      layer._project();

      layer._update();
    },
    _updateStyle: function (layer) {
      var path = layer._path,
          options = layer.options;

      if (!path) {
        return;
      }

      if (options.stroke) {
        path.setAttribute('stroke', options.color);
        path.setAttribute('stroke-opacity', options.opacity);
        path.setAttribute('stroke-width', options.weight);
        path.setAttribute('stroke-linecap', options.lineCap);
        path.setAttribute('stroke-linejoin', options.lineJoin);

        if (options.dashArray) {
          path.setAttribute('stroke-dasharray', options.dashArray);
        } else {
          path.removeAttribute('stroke-dasharray');
        }

        if (options.dashOffset) {
          path.setAttribute('stroke-dashoffset', options.dashOffset);
        } else {
          path.removeAttribute('stroke-dashoffset');
        }
      } else {
        path.setAttribute('stroke', 'none');
      }

      if (options.fill) {
        path.setAttribute('fill', options.fillColor || options.color);
        path.setAttribute('fill-opacity', options.fillOpacity);
        path.setAttribute('fill-rule', options.fillRule || 'evenodd');
      } else {
        path.setAttribute('fill', 'none');
      }
    },
    _updatePoly: function (layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    },
    _updateCircle: function (layer) {
      var p = layer._point,
          r = Math.max(Math.round(layer._radius), 1),
          r2 = Math.max(Math.round(layer._radiusY), 1) || r,
          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs

      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

      this._setPath(layer, d);
    },
    _setPath: function (layer, path) {
      layer._path.setAttribute('d', path);
    },
    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
    _bringToFront: function (layer) {
      toFront(layer._path);
    },
    _bringToBack: function (layer) {
      toBack(layer._path);
    }
  });

  if (vml) {
    SVG.include(vmlMixin);
  } // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.


  function svg$1(options) {
    return svg || vml ? new SVG(options) : null;
  }

  Map.include({
    // @namespace Map; @method getRenderer(layer: Path): Renderer
    // Returns the instance of `Renderer` that should be used to render the given
    // `Path`. It will ensure that the `renderer` options of the map and paths
    // are respected, and that the renderers do exist on the map.
    getRenderer: function (layer) {
      // @namespace Path; @option renderer: Renderer
      // Use this specific instance of `Renderer` for this path. Takes
      // precedence over the map's [default renderer](#map-renderer).
      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

      if (!renderer) {
        renderer = this._renderer = this._createRenderer();
      }

      if (!this.hasLayer(renderer)) {
        this.addLayer(renderer);
      }

      return renderer;
    },
    _getPaneRenderer: function (name) {
      if (name === 'overlayPane' || name === undefined) {
        return false;
      }

      var renderer = this._paneRenderers[name];

      if (renderer === undefined) {
        renderer = this._createRenderer({
          pane: name
        });
        this._paneRenderers[name] = renderer;
      }

      return renderer;
    },
    _createRenderer: function (options) {
      // @namespace Map; @option preferCanvas: Boolean = false
      // Whether `Path`s should be rendered on a `Canvas` renderer.
      // By default, all `Path`s are rendered in a `SVG` renderer.
      return this.options.preferCanvas && canvas$1(options) || svg$1(options);
    }
  });
  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */

  var Rectangle = Polygon.extend({
    initialize: function (latLngBounds, options) {
      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    },
    // @method setBounds(latLngBounds: LatLngBounds): this
    // Redraws the rectangle with the passed bounds.
    setBounds: function (latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },
    _boundsToLatLngs: function (latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }
  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)

  function rectangle(latLngBounds, options) {
    return new Rectangle(latLngBounds, options);
  }

  SVG.create = create$2;
  SVG.pointsToPath = pointsToPath;
  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;
  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option boxZoom: Boolean = true
    // Whether the map can be zoomed to a rectangular area specified by
    // dragging the mouse while pressing the shift key.
    boxZoom: true
  });
  var BoxZoom = Handler.extend({
    initialize: function (map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on('unload', this._destroy, this);
    },
    addHooks: function () {
      on(this._container, 'mousedown', this._onMouseDown, this);
    },
    removeHooks: function () {
      off(this._container, 'mousedown', this._onMouseDown, this);
    },
    moved: function () {
      return this._moved;
    },
    _destroy: function () {
      remove(this._pane);
      delete this._pane;
    },
    _resetState: function () {
      this._resetStateTimeout = 0;
      this._moved = false;
    },
    _clearDeferredResetState: function () {
      if (this._resetStateTimeout !== 0) {
        clearTimeout(this._resetStateTimeout);
        this._resetStateTimeout = 0;
      }
    },
    _onMouseDown: function (e) {
      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
        return false;
      } // Clear the deferred resetState if it hasn't executed yet, otherwise it
      // will interrupt the interaction and orphan a box element in the container.


      this._clearDeferredResetState();

      this._resetState();

      disableTextSelection();
      disableImageDrag();
      this._startPoint = this._map.mouseEventToContainerPoint(e);
      on(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseMove: function (e) {
      if (!this._moved) {
        this._moved = true;
        this._box = create$1('div', 'leaflet-zoom-box', this._container);
        addClass(this._container, 'leaflet-crosshair');

        this._map.fire('boxzoomstart');
      }

      this._point = this._map.mouseEventToContainerPoint(e);
      var bounds = new Bounds(this._point, this._startPoint),
          size = bounds.getSize();
      setPosition(this._box, bounds.min);
      this._box.style.width = size.x + 'px';
      this._box.style.height = size.y + 'px';
    },
    _finish: function () {
      if (this._moved) {
        remove(this._box);
        removeClass(this._container, 'leaflet-crosshair');
      }

      enableTextSelection();
      enableImageDrag();
      off(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseUp: function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }

      this._finish();

      if (!this._moved) {
        return;
      } // Postpone to next JS tick so internal click event handling
      // still see it as "moved".


      this._clearDeferredResetState();

      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

      this._map.fitBounds(bounds).fire('boxzoomend', {
        boxZoomBounds: bounds
      });
    },
    _onKeyDown: function (e) {
      if (e.keyCode === 27) {
        this._finish();
      }
    }
  }); // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.

  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);
  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option doubleClickZoom: Boolean|String = true
    // Whether the map can be zoomed in by double clicking on it and
    // zoomed out by double clicking while holding shift. If passed
    // `'center'`, double-click zoom will zoom to the center of the
    //  view regardless of where the mouse was.
    doubleClickZoom: true
  });
  var DoubleClickZoom = Handler.extend({
    addHooks: function () {
      this._map.on('dblclick', this._onDoubleClick, this);
    },
    removeHooks: function () {
      this._map.off('dblclick', this._onDoubleClick, this);
    },
    _onDoubleClick: function (e) {
      var map = this._map,
          oldZoom = map.getZoom(),
          delta = map.options.zoomDelta,
          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

      if (map.options.doubleClickZoom === 'center') {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    }
  }); // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.

  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);
  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option dragging: Boolean = true
    // Whether the map be draggable with mouse/touch or not.
    dragging: true,
    // @section Panning Inertia Options
    // @option inertia: Boolean = *
    // If enabled, panning of the map will have an inertia effect where
    // the map builds momentum while dragging and continues moving in
    // the same direction for some time. Feels especially nice on touch
    // devices. Enabled by default unless running on old Android devices.
    inertia: !android23,
    // @option inertiaDeceleration: Number = 3000
    // The rate with which the inertial movement slows down, in pixels/second².
    inertiaDeceleration: 3400,
    // px/s^2
    // @option inertiaMaxSpeed: Number = Infinity
    // Max speed of the inertial movement, in pixels/second.
    inertiaMaxSpeed: Infinity,
    // px/s
    // @option easeLinearity: Number = 0.2
    easeLinearity: 0.2,
    // TODO refactor, move to CRS
    // @option worldCopyJump: Boolean = false
    // With this option enabled, the map tracks when you pan to another "copy"
    // of the world and seamlessly jumps to the original one so that all overlays
    // like markers and vector layers are still visible.
    worldCopyJump: false,
    // @option maxBoundsViscosity: Number = 0.0
    // If `maxBounds` is set, this option will control how solid the bounds
    // are when dragging the map around. The default value of `0.0` allows the
    // user to drag outside the bounds at normal speed, higher values will
    // slow down map dragging outside bounds, and `1.0` makes the bounds fully
    // solid, preventing the user from dragging outside the bounds.
    maxBoundsViscosity: 0.0
  });
  var Drag = Handler.extend({
    addHooks: function () {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new Draggable(map._mapPane, map._container);

        this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this);

        this._draggable.on('predrag', this._onPreDragLimit, this);

        if (map.options.worldCopyJump) {
          this._draggable.on('predrag', this._onPreDragWrap, this);

          map.on('zoomend', this._onZoomEnd, this);
          map.whenReady(this._onZoomEnd, this);
        }
      }

      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');

      this._draggable.enable();

      this._positions = [];
      this._times = [];
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-grab');
      removeClass(this._map._container, 'leaflet-touch-drag');

      this._draggable.disable();
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    moving: function () {
      return this._draggable && this._draggable._moving;
    },
    _onDragStart: function () {
      var map = this._map;

      map._stop();

      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);
        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
      } else {
        this._offsetLimit = null;
      }

      map.fire('movestart').fire('dragstart');

      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },
    _onDrag: function (e) {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

        this._positions.push(pos);

        this._times.push(time);

        this._prunePositions(time);
      }

      this._map.fire('move', e).fire('drag', e);
    },
    _prunePositions: function (time) {
      while (this._positions.length > 1 && time - this._times[0] > 50) {
        this._positions.shift();

        this._times.shift();
      }
    },
    _onZoomEnd: function () {
      var pxCenter = this._map.getSize().divideBy(2),
          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    },
    _viscousLimit: function (value, threshold) {
      return value - (value - threshold) * this._viscosity;
    },
    _onPreDragLimit: function () {
      if (!this._viscosity || !this._offsetLimit) {
        return;
      }

      var offset = this._draggable._newPos.subtract(this._draggable._startPos);

      var limit = this._offsetLimit;

      if (offset.x < limit.min.x) {
        offset.x = this._viscousLimit(offset.x, limit.min.x);
      }

      if (offset.y < limit.min.y) {
        offset.y = this._viscousLimit(offset.y, limit.min.y);
      }

      if (offset.x > limit.max.x) {
        offset.x = this._viscousLimit(offset.x, limit.max.x);
      }

      if (offset.y > limit.max.y) {
        offset.y = this._viscousLimit(offset.y, limit.max.y);
      }

      this._draggable._newPos = this._draggable._startPos.add(offset);
    },
    _onPreDragWrap: function () {
      // TODO refactor to be able to adjust map pane position after zoom
      var worldWidth = this._worldWidth,
          halfWidth = Math.round(worldWidth / 2),
          dx = this._initialWorldOffset,
          x = this._draggable._newPos.x,
          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = newX;
    },
    _onDragEnd: function (e) {
      var map = this._map,
          options = map.options,
          noInertia = !options.inertia || this._times.length < 2;
      map.fire('dragend', e);

      if (noInertia) {
        map.fire('moveend');
      } else {
        this._prunePositions(+new Date());

        var direction = this._lastPos.subtract(this._positions[0]),
            duration = (this._lastTime - this._times[0]) / 1000,
            ease = options.easeLinearity,
            speedVector = direction.multiplyBy(ease / duration),
            speed = speedVector.distanceTo([0, 0]),
            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

        if (!offset.x && !offset.y) {
          map.fire('moveend');
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);
          requestAnimFrame(function () {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true,
              animate: true
            });
          });
        }
      }
    }
  }); // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).

  Map.addInitHook('addHandler', 'dragging', Drag);
  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */
  // @namespace Map
  // @section Keyboard Navigation Options

  Map.mergeOptions({
    // @option keyboard: Boolean = true
    // Makes the map focusable and allows users to navigate the map with keyboard
    // arrows and `+`/`-` keys.
    keyboard: true,
    // @option keyboardPanDelta: Number = 80
    // Amount of pixels to pan when pressing an arrow key.
    keyboardPanDelta: 80
  });
  var Keyboard = Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173]
    },
    initialize: function (map) {
      this._map = map;

      this._setPanDelta(map.options.keyboardPanDelta);

      this._setZoomDelta(map.options.zoomDelta);
    },
    addHooks: function () {
      var container = this._map._container; // make the container focusable by tabbing

      if (container.tabIndex <= 0) {
        container.tabIndex = '0';
      }

      on(container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.on({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    removeHooks: function () {
      this._removeHooks();

      off(this._map._container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.off({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    _onMouseDown: function () {
      if (this._focused) {
        return;
      }

      var body = document.body,
          docEl = document.documentElement,
          top = body.scrollTop || docEl.scrollTop,
          left = body.scrollLeft || docEl.scrollLeft;

      this._map._container.focus();

      window.scrollTo(left, top);
    },
    _onFocus: function () {
      this._focused = true;

      this._map.fire('focus');
    },
    _onBlur: function () {
      this._focused = false;

      this._map.fire('blur');
    },
    _setPanDelta: function (panDelta) {
      var keys = this._panKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }

      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }

      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }

      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    },
    _setZoomDelta: function (zoomDelta) {
      var keys = this._zoomKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }

      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    },
    _addHooks: function () {
      on(document, 'keydown', this._onKeyDown, this);
    },
    _removeHooks: function () {
      off(document, 'keydown', this._onKeyDown, this);
    },
    _onKeyDown: function (e) {
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var key = e.keyCode,
          map = this._map,
          offset;

      if (key in this._panKeys) {
        if (!map._panAnim || !map._panAnim._inProgress) {
          offset = this._panKeys[key];

          if (e.shiftKey) {
            offset = toPoint(offset).multiplyBy(3);
          }

          map.panBy(offset);

          if (map.options.maxBounds) {
            map.panInsideBounds(map.options.maxBounds);
          }
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
        map.closePopup();
      } else {
        return;
      }

      stop(e);
    }
  }); // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.

  Map.addInitHook('addHandler', 'keyboard', Keyboard);
  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Mouse wheel options
    // @option scrollWheelZoom: Boolean|String = true
    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
    // it will zoom to the center of the view regardless of where the mouse was.
    scrollWheelZoom: true,
    // @option wheelDebounceTime: Number = 40
    // Limits the rate at which a wheel can fire (in milliseconds). By default
    // user can't zoom via wheel more often than once per 40 ms.
    wheelDebounceTime: 40,
    // @option wheelPxPerZoomLevel: Number = 60
    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
    // mean a change of one full zoom level. Smaller values will make wheel-zooming
    // faster (and vice versa).
    wheelPxPerZoomLevel: 60
  });
  var ScrollWheelZoom = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'wheel', this._onWheelScroll, this);
      this._delta = 0;
    },
    removeHooks: function () {
      off(this._map._container, 'wheel', this._onWheelScroll, this);
    },
    _onWheelScroll: function (e) {
      var delta = getWheelDelta(e);
      var debounce = this._map.options.wheelDebounceTime;
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);

      if (!this._startTime) {
        this._startTime = +new Date();
      }

      var left = Math.max(debounce - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), left);
      stop(e);
    },
    _performZoom: function () {
      var map = this._map,
          zoom = map.getZoom(),
          snap = this._map.options.zoomSnap || 0;

      map._stop(); // stop panning and fly animations if any
      // map the delta with a sigmoid function to -4..4 range leaning on -1..1


      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
      this._delta = 0;
      this._startTime = null;

      if (!delta) {
        return;
      }

      if (map.options.scrollWheelZoom === 'center') {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    }
  }); // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.

  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);
  /*
   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Touch interaction options
    // @option tap: Boolean = true
    // Enables mobile hacks for supporting instant taps (fixing 200ms click
    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).
    tap: true,
    // @option tapTolerance: Number = 15
    // The max number of pixels a user can shift his finger during touch
    // for it to be considered a valid tap.
    tapTolerance: 15
  });
  var Tap = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'touchstart', this._onDown, this);
    },
    removeHooks: function () {
      off(this._map._container, 'touchstart', this._onDown, this);
    },
    _onDown: function (e) {
      if (!e.touches) {
        return;
      }

      preventDefault(e);
      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch

      if (e.touches.length > 1) {
        this._fireClick = false;
        clearTimeout(this._holdTimeout);
        return;
      }

      var first = e.touches[0],
          el = first.target;
      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it

      if (el.tagName && el.tagName.toLowerCase() === 'a') {
        addClass(el, 'leaflet-active');
      } // simulate long hold but setting a timeout


      this._holdTimeout = setTimeout(bind(function () {
        if (this._isTapValid()) {
          this._fireClick = false;

          this._onUp();

          this._simulateEvent('contextmenu', first);
        }
      }, this), 1000);

      this._simulateEvent('mousedown', first);

      on(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);
    },
    _onUp: function (e) {
      clearTimeout(this._holdTimeout);
      off(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);

      if (this._fireClick && e && e.changedTouches) {
        var first = e.changedTouches[0],
            el = first.target;

        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
          removeClass(el, 'leaflet-active');
        }

        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much


        if (this._isTapValid()) {
          this._simulateEvent('click', first);
        }
      }
    },
    _isTapValid: function () {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    },
    _onMove: function (e) {
      var first = e.touches[0];
      this._newPos = new Point(first.clientX, first.clientY);

      this._simulateEvent('mousemove', first);
    },
    _simulateEvent: function (type, e) {
      var simulatedEvent = document.createEvent('MouseEvents');
      simulatedEvent._simulated = true;
      e.target._simulatedClick = true;
      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
      e.target.dispatchEvent(simulatedEvent);
    }
  }); // @section Handlers
  // @property tap: Handler
  // Mobile touch hacks (quick tap and touch hold) handler.

  if (touch && (!pointer || safari)) {
    Map.addInitHook('addHandler', 'tap', Tap);
  }
  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */
  // @namespace Map
  // @section Interaction Options


  Map.mergeOptions({
    // @section Touch interaction options
    // @option touchZoom: Boolean|String = *
    // Whether the map can be zoomed by touch-dragging with two fingers. If
    // passed `'center'`, it will zoom to the center of the view regardless of
    // where the touch events (fingers) were. Enabled for touch-capable web
    // browsers except for old Androids.
    touchZoom: touch && !android23,
    // @option bounceAtZoomLimits: Boolean = true
    // Set it to false if you don't want the map to zoom beyond min/max zoom
    // and then bounce back when pinch-zooming.
    bounceAtZoomLimits: true
  });
  var TouchZoom = Handler.extend({
    addHooks: function () {
      addClass(this._map._container, 'leaflet-touch-zoom');
      on(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-touch-zoom');
      off(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    _onTouchStart: function (e) {
      var map = this._map;

      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
        return;
      }

      var p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]);
      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);

      if (map.options.touchZoom !== 'center') {
        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
      }

      this._startDist = p1.distanceTo(p2);
      this._startZoom = map.getZoom();
      this._moved = false;
      this._zooming = true;

      map._stop();

      on(document, 'touchmove', this._onTouchMove, this);
      on(document, 'touchend', this._onTouchEnd, this);
      preventDefault(e);
    },
    _onTouchMove: function (e) {
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }

      var map = this._map,
          p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]),
          scale = p1.distanceTo(p2) / this._startDist;

      this._zoom = map.getScaleZoom(scale, this._startZoom);

      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
        this._zoom = map._limitZoom(this._zoom);
      }

      if (map.options.touchZoom === 'center') {
        this._center = this._startLatLng;

        if (scale === 1) {
          return;
        }
      } else {
        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);

        if (scale === 1 && delta.x === 0 && delta.y === 0) {
          return;
        }

        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
      }

      if (!this._moved) {
        map._moveStart(true, false);

        this._moved = true;
      }

      cancelAnimFrame(this._animRequest);
      var moveFn = bind(map._move, map, this._center, this._zoom, {
        pinch: true,
        round: false
      });
      this._animRequest = requestAnimFrame(moveFn, this, true);
      preventDefault(e);
    },
    _onTouchEnd: function () {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }

      this._zooming = false;
      cancelAnimFrame(this._animRequest);
      off(document, 'touchmove', this._onTouchMove, this);
      off(document, 'touchend', this._onTouchEnd, this); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.

      if (this._map.options.zoomAnimation) {
        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
      } else {
        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    }
  }); // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.

  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);
  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.Tap = Tap;
  Map.TouchZoom = TouchZoom;
  exports.version = version;
  exports.Control = Control;
  exports.control = control;
  exports.Browser = Browser;
  exports.Evented = Evented;
  exports.Mixin = Mixin;
  exports.Util = Util;
  exports.Class = Class;
  exports.Handler = Handler;
  exports.extend = extend;
  exports.bind = bind;
  exports.stamp = stamp;
  exports.setOptions = setOptions;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.PosAnimation = PosAnimation;
  exports.Draggable = Draggable;
  exports.LineUtil = LineUtil;
  exports.PolyUtil = PolyUtil;
  exports.Point = Point;
  exports.point = toPoint;
  exports.Bounds = Bounds;
  exports.bounds = toBounds;
  exports.Transformation = Transformation;
  exports.transformation = toTransformation;
  exports.Projection = index;
  exports.LatLng = LatLng;
  exports.latLng = toLatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.latLngBounds = toLatLngBounds;
  exports.CRS = CRS;
  exports.GeoJSON = GeoJSON;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.layerGroup = layerGroup;
  exports.FeatureGroup = FeatureGroup;
  exports.featureGroup = featureGroup;
  exports.ImageOverlay = ImageOverlay;
  exports.imageOverlay = imageOverlay;
  exports.VideoOverlay = VideoOverlay;
  exports.videoOverlay = videoOverlay;
  exports.SVGOverlay = SVGOverlay;
  exports.svgOverlay = svgOverlay;
  exports.DivOverlay = DivOverlay;
  exports.Popup = Popup;
  exports.popup = popup;
  exports.Tooltip = Tooltip;
  exports.tooltip = tooltip;
  exports.Icon = Icon;
  exports.icon = icon;
  exports.DivIcon = DivIcon;
  exports.divIcon = divIcon;
  exports.Marker = Marker;
  exports.marker = marker;
  exports.TileLayer = TileLayer;
  exports.tileLayer = tileLayer;
  exports.GridLayer = GridLayer;
  exports.gridLayer = gridLayer;
  exports.SVG = SVG;
  exports.svg = svg$1;
  exports.Renderer = Renderer;
  exports.Canvas = Canvas;
  exports.canvas = canvas$1;
  exports.Path = Path;
  exports.CircleMarker = CircleMarker;
  exports.circleMarker = circleMarker;
  exports.Circle = Circle;
  exports.circle = circle;
  exports.Polyline = Polyline;
  exports.polyline = polyline;
  exports.Polygon = Polygon;
  exports.polygon = polygon;
  exports.Rectangle = Rectangle;
  exports.rectangle = rectangle;
  exports.Map = Map;
  exports.map = createMap;
  var oldL = window.L;

  exports.noConflict = function () {
    window.L = oldL;
    return this;
  }; // Always export us to window global (see #2364)


  window.L = exports;
});

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon-2x.png":
/*!*************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon-2x.png ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "680f69f3c2e6b90c1812.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "2b3e1faf89f94a483539.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-shadow.png":
/*!************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-shadow.png ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "a0c6cc1401c107b501ef.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./style.css");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ "./node_modules/leaflet/dist/leaflet.css");



/* This code is needed to properly load the images in the Leaflet CSS */

delete (leaflet__WEBPACK_IMPORTED_MODULE_1___default().Icon.Default.prototype._getIconUrl);
leaflet__WEBPACK_IMPORTED_MODULE_1___default().Icon.Default.mergeOptions({
  iconRetinaUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ "./node_modules/leaflet/dist/images/marker-icon-2x.png"),
  iconUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ "./node_modules/leaflet/dist/images/marker-icon.png"),
  shadowUrl: __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ "./node_modules/leaflet/dist/images/marker-shadow.png")
});
'use strict'; // prettier-ignore


const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
const form = document.querySelector('.form');
const containerWorkouts = document.querySelector('.workouts');
const inputType = document.querySelector('.form__input--type');
const inputDistance = document.querySelector('.form__input--distance');
const inputDuration = document.querySelector('.form__input--duration');
const inputCadence = document.querySelector('.form__input--cadence');
const inputElevation = document.querySelector('.form__input--elevation');
let map, mapEvent;

class App {
  constructor() {
    this._getPosition();

    this.map = document.querySelector('#map');
    this.mapEvent = document.querySelector('#mapEvent');
  }

  _getPosition() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(this._loadMap.bind(this), function () {
        alert('no location');
      });
    }
  }

  _loadMap(position) {
    const {
      latitude
    } = position.coords;
    const {
      longitude
    } = position.coords;
    const coords = [latitude, longitude];
    this.map = leaflet__WEBPACK_IMPORTED_MODULE_1___default().map('map').setView(coords, 15);
    leaflet__WEBPACK_IMPORTED_MODULE_1___default().tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(this.map);
    this.map.on('click', this._showForm.bind(this));
  }

  _showForm(mapEvt) {
    this.mapEvent = mapEvt;
    form.classList.remove('hidden');
    inputDistance.focus();
  }

  _toggleElevationField() {
    inputElevation.closest('.form__row').classList.toggle('form__row--hidden');
    inputCadence.closest('.form__row').classList.toggle('form__row--hidden');
  }

  _newWorkout(evt) {
    evt.preventDefault(); //clear input fields

    inputDistance.value = inputDuration.value = inputCadence.value = inputElevation.value = ''; //display marker

    const {
      lat,
      lng
    } = this.mapEvent.latlng;
    leaflet__WEBPACK_IMPORTED_MODULE_1___default().marker([lat, lng]).addTo(this.map).bindPopup(leaflet__WEBPACK_IMPORTED_MODULE_1___default().popup({
      maxWidth: 250,
      minWidth: 100,
      autoClose: false,
      closeOnClick: false,
      className: 'running-popup'
    })).setPopupContent('work-our').openPopup();
  }

  setEventListeners() {
    form.addEventListener('submit', this._newWorkout.bind(this));
    inputType.addEventListener('change', this._toggleElevationField);
  }

}

const app = new App();
app.setEventListeners();
}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDJhLEVBQUFBLGlCQUFpQixHQUFHO0FBQ2xCbkIsSUFBQUEsSUFBSSxDQUFDdHBELGdCQUFMLENBQXNCLFFBQXRCLEVBQWdDLEtBQUt1cUQsV0FBTCxDQUFpQmh6RCxJQUFqQixDQUFzQixJQUF0QixDQUFoQztBQUNBa3lELElBQUFBLFNBQVMsQ0FBQ3pwRCxnQkFBVixDQUEyQixRQUEzQixFQUFxQyxLQUFLcXFELHFCQUExQztBQUNEOztBQXRFTzs7QUF5RVYsTUFBTUssR0FBRyxHQUFHLElBQUlYLEdBQUosRUFBWjtBQUNBVyxHQUFHLENBQUNELGlCQUFKLEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29yZS9VdGlsLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb3JlL0NsYXNzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvbWV0cnkvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL0xhdExuZy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL2Nycy9DUlMuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9jcnMvQ1JTLkVhcnRoLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzM4NTcuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuVXRpbC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29yZS9Ccm93c2VyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9kb20vRG9tRXZlbnQuUG9pbnRlci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZG9tL0RvbUV2ZW50LkRvdWJsZVRhcC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZG9tL0RvbVV0aWwuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2RvbS9Eb21FdmVudC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZG9tL1Bvc0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL01hcC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29udHJvbC9Db250cm9sLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuTGF5ZXJzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuWm9vbS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvbnRyb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvcmUvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZG9tL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlb21ldHJ5L1BvbHlVdGlsLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czMzk1LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHNDMyNi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL2Nycy9DUlMuU2ltcGxlLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vY3JzL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9MYXllci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvTGF5ZXJHcm91cC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvSWNvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5EcmFnLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvTWFya2VyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUGF0aC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlsaW5lLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9WaWRlb092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL1NWR092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL0Rpdk92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL1BvcHVwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9Ub29sdGlwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvRGl2SWNvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdGlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvQ2FudmFzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlZNTC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuQm94Wm9vbS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkRyYWcuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5LZXlib2FyZC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRhcC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRvdWNoWm9vbS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzcz84M2NiIiwid2VicGFjazovL21hcHR5Ly4vc3R5bGUuY3NzP2ViMmEiLCJ3ZWJwYWNrOi8vbWFwdHkvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbWFwdHkvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vbWFwdHkvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL21hcHR5L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbWFwdHkvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9tYXB0eS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9tYXB0eS8uL3NjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5leHBvcnQgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBGKCkge31cclxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4vLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRpZiAoZm4uYmluZCkge1xyXG5cdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbi8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbmV4cG9ydCB2YXIgbGFzdElkID0gMDtcclxuXHJcbi8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRvYmouX2xlYWZsZXRfaWQgPSBvYmouX2xlYWZsZXRfaWQgfHwgKytsYXN0SWQ7XHJcblx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbi8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4vLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4vLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB3cmFwcGVyRm47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbi8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5leHBvcnQgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4vLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgdG8gYGRpZ2l0c2AgZGVjaW1hbHMsIG9yIHRvIDYgZGVjaW1hbHMgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIGRpZ2l0cykge1xyXG5cdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgKGRpZ2l0cyA9PT0gdW5kZWZpbmVkID8gNiA6IGRpZ2l0cykpO1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG4vLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cikge1xyXG5cdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xyXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0fVxyXG5cdHJldHVybiBvYmoub3B0aW9ucztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbi8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0fVxyXG5cdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG59XHJcblxyXG52YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3Xy1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gVXRpbC5leHRlbmQoVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG4iLCJpbXBvcnQge2lzQXJyYXksIGZvcm1hdE51bX0gZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcblx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcblx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4vTGF0TG5nJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9jcnMvQ1JTLkVhcnRoJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuaW1wb3J0IHtzdmdDcmVhdGV9IGZyb20gJy4uL2xheWVyL3ZlY3Rvci9TVkcuVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbmV4cG9ydCB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5leHBvcnQgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuZXhwb3J0IHZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuZXhwb3J0IHZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47IGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbmV4cG9ydCB2YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG5leHBvcnQgdmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBjaHJvbWUgPSAhZWRnZSAmJiB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5leHBvcnQgdmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG5leHBvcnQgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuZXhwb3J0IHZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbmV4cG9ydCB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbmV4cG9ydCB2YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG5leHBvcnQgdmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuLy8gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbmV4cG9ydCB2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHQod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuLy8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuIG9yIG9uIGFueSBzY3JlZW4gd2hlbiBicm93c2VyJ3MgZGlzcGxheSB6b29tIGlzIG1vcmUgdGhhbiAxMDAlLlxyXG5leHBvcnQgdmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG5leHBvcnQgdmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuXHR0cnkge1xyXG5cdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxyXG5leHBvcnQgdmFyIGNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcclxufSgpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cclxuZXhwb3J0IHZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG5leHBvcnQgdmFyIHZtbCA9ICFzdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5cclxuZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcblx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuXG52YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xudmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xudmFyIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0X2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKSB7XG5cdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgaGFuZGxlciwgZmFsc2UpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25Eb3duID0gVXRpbC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG5cdFx0aWYgKGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggJiYgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkge1xuXHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH0pO1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG5cdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xufVxuXG5mdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKSB7XG5cdGUudG91Y2hlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG5cdH1cblx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRoYW5kbGVyKGUpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gKGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgJ21vdXNlJykpICYmIGUuYnV0dG9ucyA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25VcCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG59XG4iLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxudmFyIF90b3VjaHN0YXJ0ID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcmRvd24nIDogJ3RvdWNoc3RhcnQnO1xyXG52YXIgX3RvdWNoZW5kID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xyXG52YXIgX3ByZSA9ICdfbGVhZmxldF8nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpIHtcclxuXHR2YXIgbGFzdCwgdG91Y2gsXHJcblx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdCAgICBkZWxheSA9IDI1MDtcclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHJcblx0XHRpZiAoQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGlmICghZS5pc1ByaW1hcnkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfSAvLyBtb3VzZSBmaXJlcyBuYXRpdmUgZGJsY2xpY2tcclxuXHRcdH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRkb3VibGVUYXAgPSAoZGVsdGEgPiAwICYmIGRlbHRhIDw9IGRlbGF5KTtcclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoRW5kKGUpIHtcclxuXHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoLmNhbmNlbEJ1YmJsZSkge1xyXG5cdFx0XHRpZiAoQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdHByb3AgPSB0b3VjaFtpXTtcclxuXHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG91Y2ggPSBuZXdUb3VjaDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0dG91Y2guYnV0dG9uID0gMDtcclxuXHRcdFx0aGFuZGxlcih0b3VjaCk7XHJcblx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblx0b2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWU8NTUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdC8vIEVkZ2UgMTQgYWxzbyBmaXJlcyBuYXRpdmUgZGJsY2xpY2tzLCBidXQgb25seSBmb3IgcG9pbnRlclR5cGUgbW91c2UsIHNlZSAjNTE4MC5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCkge1xyXG5cdHZhciB0b3VjaHN0YXJ0ID0gb2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSxcclxuXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuXHQgICAgZGJsY2xpY2sgPSBvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChCcm93c2VyLmFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuZXhwb3J0IHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xyXG5cdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcclxuXHREb21FdmVudC5vbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XHJcblx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcblx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuXHRkbyB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG5cdHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbi8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4vLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge2FkZFBvaW50ZXJMaXN0ZW5lciwgcmVtb3ZlUG9pbnRlckxpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5pbXBvcnQge2FkZERvdWJsZVRhcExpc3RlbmVyLCByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Eb3VibGVUYXAnO1xyXG5pbXBvcnQge2dldFNjYWxlfSBmcm9tICcuL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4vLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4vLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4vLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmV4cG9ydCBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbi8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmV4cG9ydCBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKHR5cGVzKSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGogaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgaiwgb2JqW2V2ZW50c0tleV1bal0pO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrKCkge1xyXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL3BvaW50ZXJldmVudHMvaXNzdWVzLzE3MVxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdHJldHVybiAhKEJyb3dzZXIuZWRnZSB8fCBCcm93c2VyLnNhZmFyaSk7XHJcblx0fVxyXG59XHJcblxyXG52YXIgbW91c2VTdWJzdCA9IHtcclxuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiAhYnJvd3NlckZpcmVzTmF0aXZlRGJsQ2xpY2soKSkge1xyXG5cdFx0YWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiAhYnJvd3NlckZpcmVzTmF0aXZlRGJsQ2xpY2soKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4vLyBgYGBqc1xyXG4vLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbi8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4vLyB9KTtcclxuLy8gYGBgXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9XHJcblx0c2tpcHBlZChlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci53aW4gJiYgQnJvd3Nlci5jaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG5cdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG52YXIgc2tpcEV2ZW50cyA9IHt9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZha2VTdG9wKGUpIHtcclxuXHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIHNraXBwZWQoZSlcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSB0cnVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2tpcHBlZChlKSB7XHJcblx0dmFyIGV2ZW50cyA9IHNraXBFdmVudHNbZS50eXBlXTtcclxuXHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdHJldHVybiBldmVudHM7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbmV4cG9ydCB7b24gYXMgYWRkTGlzdGVuZXJ9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbmV4cG9ydCB7b2ZmIGFzIHJlbW92ZUxpc3RlbmVyfTtcclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbmV4cG9ydCB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCB7RVBTRzM4NTd9IGZyb20gJy4uL2dlby9jcnMvQ1JTLkVQU0czODU3JztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge0JvdW5kcywgdG9Cb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdFx0em9vbTogem9vbVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG5cdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcblx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXHJcblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFCcm93c2VyLmFueTNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcblx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcblx0XHQgICAgcmhvID0gMS40MixcclxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcblx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuXHRcdFx0aWYgKHQgPD0gMSkge1xyXG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuXHQvLyBgcGFkZGluZ2AsIGBwYWRkaW5nVG9wTGVmdGAgYW5kIGBwYWRkaW5nVG9wUmlnaHRgIG9wdGlvbnMgdG8gZml0XHJcblx0Ly8gdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcywgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KGNlbnRlciksXHJcblx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIGhhbGZQaXhlbEJvdW5kcyA9IHBpeGVsQm91bmRzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBkaWZmID0gcGl4ZWxDZW50ZXIuc3VidHJhY3QocGl4ZWxQb2ludCksXHJcblx0XHRcdCAgICBuZXdDZW50ZXIgPSB0b1BvaW50KHBpeGVsUG9pbnQueCArIGRpZmYueCwgcGl4ZWxQb2ludC55ICsgZGlmZi55KTtcclxuXHJcblx0XHRcdGlmIChwaXhlbFBvaW50LnggPCBwYWRkZWRCb3VuZHMubWluLnggfHwgcGl4ZWxQb2ludC54ID4gcGFkZGVkQm91bmRzLm1heC54KSB7XHJcblx0XHRcdFx0bmV3Q2VudGVyLnggPSBwaXhlbENlbnRlci54IC0gZGlmZi54O1xyXG5cdFx0XHRcdGlmIChkaWZmLnggPiAwKSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueCArPSBoYWxmUGl4ZWxCb3VuZHMueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueCAtPSBoYWxmUGl4ZWxCb3VuZHMueCAtIHBhZGRpbmdCUi54O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC55IDwgcGFkZGVkQm91bmRzLm1pbi55IHx8IHBpeGVsUG9pbnQueSA+IHBhZGRlZEJvdW5kcy5tYXgueSkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci55ID0gcGl4ZWxDZW50ZXIueSAtIGRpZmYueTtcclxuXHRcdFx0XHRpZiAoZGlmZi55ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnkgKz0gaGFsZlBpeGVsQm91bmRzLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnkgLT0gaGFsZlBpeGVsQm91bmRzLnkgLSBwYWRkaW5nQlIueTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChuZXdDZW50ZXIpLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zdG9wTG9jYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xyXG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGk7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcblx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBEb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly9cclxuXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcblx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcblx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcblx0XHQvL1xyXG5cdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcblx0XHQvL1xyXG5cdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG5cdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcblx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFRvb2x0aXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgZmFsc2UpXHJcblx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcblx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcblx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcblx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkLCBub01vdmVTdGFydCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhKSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsIGluY2x1ZGluZyB6b29tXHJcblx0XHQvLyBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsIGluY2x1ZGluZyBwYW4gYW5kXHJcblx0XHQvLyBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBoYXMgY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuXHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG5cdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcblx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG5cdFx0ICAgIHRhcmdldCxcclxuXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcblx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR3aGlsZSAoc3JjKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIERvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgRG9tRXZlbnQuc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ2tleXByZXNzJyB8fCB0eXBlID09PSAna2V5dXAnIHx8IHR5cGUgPT09ICdrZXlkb3duJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCB0YXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS5fc3RvcHBlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJyAmJiBlLnR5cGUgIT09ICdrZXlkb3duJyAmJiBlLnR5cGUgIT09ICdrZXl1cCcpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSlcclxuXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChzdGFydEFuaW0pIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb20sXHJcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcblx0fSxcclxuXHJcblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbWFwUGFuZSkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhbmltIGZyYW1lIHNob3VsZCBwcmV2ZW50IGFuIG9ic2N1cmUgaU9TIHdlYmtpdCB0aWxlIGxvYWRpbmcgcmFjZSBjb25kaXRpb24uXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxufVxyXG4iLCJcclxuaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBEb21VdGlsLmNyZWF0ZSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG5cdH1cclxufSk7XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG5cdFx0Ly8gaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBjb250cm9sLlxyXG5cdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG5cdFx0Ly8gQSBbY29tcGFyZSBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydClcclxuXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuXHRcdC8vIGBzb3J0RnVuY3Rpb24obGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQilgLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcblx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcblx0XHRcdHJldHVybiBuYW1lQSA8IG5hbWVCID8gLTEgOiAobmFtZUIgPCBuYW1lQSA/IDEgOiAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IERvbVV0aWwuY3JlYXRlKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5leHBhbmQsXHJcblx0XHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHJcblx0XHRpZiAoQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2ZvY3VzJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgc2VjdGlvbik7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBVdGlsLnN0YW1wKHRoaXMuX2xheWVyc1tpXS5sYXllcikgPT09IGlkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc29ydChVdGlsLmJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnNvcnRGdW5jdGlvbihhLmxheWVyLCBiLmxheWVyLCBhLm5hbWUsIGIubmFtZSk7XHJcblx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHZhciBiYXNlTGF5ZXJzUHJlc2VudCwgb3ZlcmxheXNQcmVzZW50LCBpLCBvYmosIGJhc2VMYXllcnNDb3VudCA9IDA7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSkge1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcblx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcblx0XHRpZiAodHlwZSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSh0eXBlLCBvYmopO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIElFNyBidWdzIG91dCBpZiB5b3UgY3JlYXRlIGEgcmFkaW8gZHluYW1pY2FsbHksIHNvIHlvdSBoYXZlIHRvIGRvIGl0IHRoaXMgaGFja3kgd2F5IChzZWUgaHR0cDovL2JpdC5seS9QcVlMQmUpXHJcblx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcblx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcblx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuXHRcdCAgICBpbnB1dDtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgVXRpbC5zdGFtcCh0aGlzKSwgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IFV0aWwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHREb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQoKTtcclxuXHR9LFxyXG5cclxuXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5jb2xsYXBzZSgpO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICcmI3gyMjEyOydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJyYjeDIyMTI7JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG5cdFx0dmFyIGxpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuXHRcdCAqL1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG5cdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcblx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5leHBvcnQgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxufTtcclxuIiwiXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICogQGluaGVyaXRzIENvbnRyb2xcbiAqXG4gKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG59O1xuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcblx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuZXhwb3J0IHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtDb250cm9sLCBjb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0IHtMYXllcnMsIGxheWVyc30gZnJvbSAnLi9Db250cm9sLkxheWVycyc7XG5pbXBvcnQge1pvb20sIHpvb219IGZyb20gJy4vQ29udHJvbC5ab29tJztcbmltcG9ydCB7U2NhbGUsIHNjYWxlfSBmcm9tICcuL0NvbnRyb2wuU2NhbGUnO1xuaW1wb3J0IHtBdHRyaWJ1dGlvbiwgYXR0cmlidXRpb259IGZyb20gJy4vQ29udHJvbC5BdHRyaWJ1dGlvbic7XG5cbkNvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuQ29udHJvbC5ab29tID0gWm9vbTtcbkNvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbkNvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5jb250cm9sLnpvb20gPSB6b29tO1xuY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG5leHBvcnQge0NvbnRyb2wsIGNvbnRyb2x9O1xuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbmV4cG9ydCB2YXIgSGFuZGxlciA9IENsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbi8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbkhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG5cdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG4iLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBTVEFSVCA9IEJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcbnZhciBFTkQgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcbn07XHJcbnZhciBNT1ZFID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcclxuXHRcdCAgICBzaXplZFBhcmVudCA9IERvbVV0aWwuZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIHNjYWxlLCBzbyB0aGF0IHdlIGNhbiBjb250aW51b3VzbHkgY29tcGVuc2F0ZSBmb3IgaXQgZHVyaW5nIGRyYWcgKF9vbk1vdmUpLlxyXG5cdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBEb21VdGlsLmdldFNjYWxlKHNpemVkUGFyZW50KTtcclxuXHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIEVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmlzaERyYWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gTU9WRSkge1xyXG5cdFx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIE1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG5cdFx0XHQvLyBlbnN1cmUgZHJhZyBpcyBub3QgZmlyZWQgYWZ0ZXIgZHJhZ2VuZFxyXG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHR2YXIgaSxcclxuXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXdQb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5mdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdHByZXYgPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxufVxyXG5cclxudmFyIF9sYXN0Q29kZTtcclxuXHJcbi8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4vLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbi8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4vLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHQgICAgeCwgeTtcclxuXHJcblx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1heC55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1pbi55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcblx0XHR4ID0gbWF4Lng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0eCA9IG1pbi54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuXHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0Y29kZSB8PSAxO1xyXG5cdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRjb2RlIHw9IDI7XHJcblx0fVxyXG5cclxuXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0Y29kZSB8PSA0O1xyXG5cdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0Y29kZSB8PSA4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvZGU7XHJcbn1cclxuXHJcbi8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5mdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG5cdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbmV4cG9ydCBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcblx0cmV0dXJuICFVdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG5cdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwYXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpcyBhbiBlbGxpcHNvaWQuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG4iLCIvKlxuICogQGNsYXNzIFByb2plY3Rpb25cblxuICogQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgcHJvamVjdGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIG9udG9cbiAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdC8vXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cdFx0cmV0dXJuIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG5cdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBwb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBwb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIHJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuXHRcdFx0cGF0aCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1wiJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1wiJ10/XFwpJC8sICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG5cdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuXHRcdHRoaXMuX21hcmtlclxuXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge01hcmtlckRyYWd9IGZyb20gJy4vTWFya2VyLkRyYWcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbmV4cG9ydCB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsICd3ZWlnaHQnKSkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjY2lyY2xlbWFya2VyLXNldGxhdGxuZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5pbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVhcnRoJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gKiBcdFszNy43NywgLTEyMi40M10sXG4gKiBcdFszNC4wNCwgLTExOC4yXVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcblx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbyxcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWxpbmUgY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcblx0XHR9XG5cblx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG5cdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcblx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcblxuXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW1xuXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPzogTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG5cdFx0XSk7XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IExpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKExpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblBvbHlsaW5lLl9mbGF0ID0gTGluZVV0aWwuX2ZsYXQ7XG4iLCJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IFV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG5cdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0cHJlY2lzaW9uID0gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiA2O1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuXHQvLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuXHQvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBCcm93c2VyIGNvbXBhdGliaWxpdHktIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0XHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtdXRlZDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgb24gbXV0ZSB3aGVuIGxvYWRlZC5cclxuXHRcdG11dGVkOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ1ZJREVPJztcclxuXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCd2aWRlbycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKHZpZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHR2aWQub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdHZpZC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGhhcyBmaW5pc2hlZCBsb2FkaW5nIHRoZSBmaXJzdCBmcmFtZVxyXG5cdFx0dmlkLm9ubG9hZGVkZGF0YSA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG5cdFx0XHR2YXIgc291cmNlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3VybCA9IChzb3VyY2VFbGVtZW50cy5sZW5ndGggPiAwKSA/IHNvdXJjZXMgOiBbdmlkLnNyY107XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIVV0aWwuaXNBcnJheSh0aGlzLl91cmwpKSB7IHRoaXMuX3VybCA9IFt0aGlzLl91cmxdOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aWQuc3R5bGUsICdvYmplY3RGaXQnKSkge1xyXG5cdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG5cdFx0fVxyXG5cdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcblx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcblx0XHR2aWQubXV0ZWQgPSAhIXRoaXMub3B0aW9ucy5tdXRlZDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gcG9wdXAgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5leHBvcnQgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKERvbVV0aWwucmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHBvcHVwLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cC5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBwb3B1cC5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCBpbiBmcm9udCBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKHBhcmVudCwgbGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XHJcblx0XHRcdGxheWVyID0gcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiBwYXJlbnQuX2xheWVycykge1xyXG5cdFx0XHRcdGxheWVyID0gcGFyZW50Ll9sYXllcnNbaWRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKGxheWVyLmdldENlbnRlcikge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChEb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG5leHBvcnQgdmFyIHBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIShwb3B1cCBpbnN0YW5jZW9mIFBvcHVwKSkge1xyXG5cdFx0XHRwb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zKS5zZXRDb250ZW50KHBvcHVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF0bG5nKSB7XHJcblx0XHRcdHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHBvcHVwKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcG9wdXAgPSBwb3B1cDtcclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAocG9wdXA/OiBQb3B1cCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuXHRcdGlmICghcG9wdXAgfHwgcG9wdXAgPT09IHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHBvcHVwID0gdGhpcy5fcG9wdXA7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHBvcHVwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExheWVyXHJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxyXG4gKlxyXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XHJcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xyXG4gKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICovXHJcblxyXG4vLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXHJcbkxheWVyLmluY2x1ZGUoe1xyXG5cclxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXHJcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBQb3B1cCkge1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghdGhpcy5fcG9wdXAgfHwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcclxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XHJcblxyXG5cdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxyXG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgUGF0aCkge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UgdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkgJiYgdGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChsYXllciwgZS5sYXRsbmcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuIiwiXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbmV4cG9ydCB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoQnJvd3Nlci50b3VjaCAmJiAhdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0dmFyIHN1YlgsIHN1YlksXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gMDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAodG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggKyAob2Zmc2V0LnggKyBhbmNob3IueCkgKiAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHN1YlgsIHN1YlksIHRydWUpKS5hZGQob2Zmc2V0KS5hZGQoYW5jaG9yKTtcblxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbmV4cG9ydCB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRpZiAoISh0b29sdGlwIGluc3RhbmNlb2YgVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuXHRcdH1cblxuXHRcdGlmIChsYXRsbmcpIHtcblx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIodG9vbHRpcCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHRvb2x0aXApO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA/OiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodG9vbHRpcCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgVG9vbHRpcCkge1xuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHRcdH1cblx0XHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl90b29sdGlwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcblxuXHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCwgbGF0bG5nKTtcblxuXHRcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgbWF5IG5vdCBiZSBkZWZpbmVkIGlmIG5vdCBwZXJtYW5lbnQgYW5kIG5ldmVyXG5cdFx0XHQvLyBvcGVuZWQuXG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLl9jbG9zZSgpO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vcGVuVG9vbHRpcChsYXllciwgdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge2VtcHR5fSBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG5leHBvcnQgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZ3xIVE1MRWxlbWVudCA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcblx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuXHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cblx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG5cdFx0YmdQb3M6IG51bGwsXG5cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuaHRtbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0XHRcdGVtcHR5KGRpdik7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gcG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmV4cG9ydCB7aWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0Jztcbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuZXhwb3J0IHtJY29ufTtcblxuZXhwb3J0IHtEaXZJY29uLCBkaXZJY29ufSBmcm9tICcuL0Rpdkljb24nO1xuZXhwb3J0IHtNYXJrZXIsIG1hcmtlcn0gZnJvbSAnLi9NYXJrZXInO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5leHBvcnQgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcblx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG5cdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcblx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSBVdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk9wYXF1ZVRpbGU6IFV0aWwuZmFsc2VGbixcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR6ID0gTnVtYmVyKHopO1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuXHR9LFxuXG5cdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gem9vbTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcblx0XHR9XG5cblx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG5cdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9QcnVuZSkge1xuXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG5cdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG5cdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHR9XG5cblx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0fSxcblxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cblx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcblx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHF1ZXVlID0gW10sXG5cdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG5cdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG5cdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cblx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBsYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblx0XHRyZXR1cm4gW253LCBzZV07XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcblx0XHRpZiAoQnJvd3Nlci5hbmRyb2lkICYmICFCcm93c2VyLmFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IFV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IFV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtHcmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnTWFwIGRhdGEgJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9cIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMsIDxhIGhyZWY9XCJodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1wiPkNDLUJZLVNBPC9hPid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcblx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIFV0aWwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHQgQWx0IHRhZyBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGtlZXAgc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIFVSTCBhbmQgZm9yIGNvbXBsaWFuY2UgcmVhc29uc1xyXG5cdFx0IGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9INjdcclxuXHRcdCovXHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgU2V0IHJvbGU9XCJwcmVzZW50YXRpb25cIiB0byBmb3JjZSBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhpc1xyXG5cdFx0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS9yb2xlcyN0ZXh0YWx0ZXJuYXRpdmVjb21wdXRhdGlvblxyXG5cdFx0Ki9cclxuXHRcdHRpbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIENhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbGVcclxuXHRcdC8vIHVubGVzcyB3ZSdyZSBvbiBBbmRyb2lkJ3Mgc3RvY2sgYnJvd3NlcixcclxuXHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghQnJvd3Nlci5hbmRyb2lkU3RvY2spIHtcclxuXHRcdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIFV0aWwuZW1wdHlJbWFnZVVybCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBVdGlsLmVtcHR5SW1hZ2VVcmwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fdGlsZVJlYWR5LmNhbGwodGhpcywgY29vcmRzLCBlcnIsIHRpbGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcih1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7VGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XHJcbmltcG9ydCB7ZXh0ZW5kLCBzZXRPcHRpb25zLCBnZXRQYXJhbVN0cmluZ30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVQU0c0MzI2JztcclxuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cDovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiByZXRpbmEgPyAyIDogMTtcclxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcclxuXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG5cdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG5cdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuXHRcdCAgICBib3VuZHMgPSB0b0JvdW5kcyhjcnMucHJvamVjdCh0aWxlQm91bmRzWzBdKSwgY3JzLnByb2plY3QodGlsZUJvdW5kc1sxXSkpLFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gRVBTRzQzMjYgP1xyXG5cdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG5cdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuXHRcdCAgICB1cmwgPSBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG59XHJcbiIsImV4cG9ydCB7R3JpZExheWVyLCBncmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcbmltcG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcbmltcG9ydCB7VGlsZUxheWVyV01TLCB0aWxlTGF5ZXJXTVN9IGZyb20gJy4vVGlsZUxheWVyLldNUyc7XG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcbmV4cG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9O1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG5cbi8qXG4gKiBAY2xhc3MgUmVuZGVyZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLlJlbmRlcmVyXG4gKlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICpcbiAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gKlxuICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICovXG5cbmV4cG9ydCB2YXIgUmVuZGVyZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjEsXG5cblx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCBjbGljayB0b2xlcmFuY2Ugcm91bmQgYSBwYXRoL29iamVjdCBvbiB0aGUgbWFwXG5cdFx0dG9sZXJhbmNlIDogMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFV0aWwuc3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG5cdFx0XHR6b29tZW5kOiB0aGlzLl9vblpvb21FbmRcblx0XHR9O1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG5cdFx0fVxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuXHR9LFxuXG5cdF9vblpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0fSxcblxuXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcblx0XHQgICAgcG9zaXRpb24gPSBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciksXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblx0XHQgICAgZGVzdENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyLCB6b29tKSxcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gZGVzdENlbnRlclBvaW50LnN1YnRyYWN0KGN1cnJlbnRDZW50ZXJQb2ludCksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQocG9zaXRpb24pLmFkZCh2aWV3SGFsZikuc3VidHJhY3QoY2VudGVyT2Zmc2V0KTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG5cdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cblx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3JlZHJhd1JlcXVlc3QpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxheWVyO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZHJhdygpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcblx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cblx0XHRpZiAoQnJvd3Nlci5yZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cblx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcblx0XHRcdGxheWVyOiBsYXllcixcblx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuXHRcdFx0bmV4dDogbnVsbFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcblx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0Ly8gVGhlIHJlZHJhdyB3aWxsIGV4dGVuZCB0aGUgcmVkcmF3IGJvdW5kc1xuXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICh0eXBlb2YgbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBkYXNoVmFsdWUsXG5cdFx0XHQgICAgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkYXNoVmFsdWUgPSBOdW1iZXIocGFydHNbaV0pO1xuXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuXHRcdFx0XHRpZiAoaXNOYU4oZGFzaFZhbHVlKSkgeyByZXR1cm47IH1cblx0XHRcdFx0ZGFzaEFycmF5LnB1c2goZGFzaFZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRpZiAoIShlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlICE9PSAncHJlY2xpY2snKSB8fCAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpY2tlZExheWVyKSAge1xuXHRcdFx0RG9tRXZlbnQuZmFrZVN0b3AoZSk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NsaWNrZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH1cbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHIyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5pZiAoQnJvd3Nlci52bWwpIHtcblx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xufVxuXG4vLyBAbmFtZXNwYWNlIFNWR1xuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge2NhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiZXhwb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5leHBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgY3JlYXRlLCBwb2ludHNUb1BhdGgsIHN2Z30gZnJvbSAnLi9TVkcnO1xuU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5leHBvcnQge1NWRywgc3ZnfTtcbmltcG9ydCAnLi9SZW5kZXJlci5nZXRSZW5kZXJlcic7XHQvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IG5lZWRlZCBiZWNhdXNlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5leHBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5leHBvcnQge0NpcmNsZU1hcmtlciwgY2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5leHBvcnQge0NpcmNsZSwgY2lyY2xlfSBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQge1BvbHlsaW5lLCBwb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5leHBvcnQge1BvbHlnb24sIHBvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5leHBvcnQge1JlY3RhbmdsZSwgcmVjdGFuZ2xlfSBmcm9tICcuL1JlY3RhbmdsZSc7XG4iLCJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5leHBvcnQge1NWR092ZXJsYXksIHN2Z092ZXJsYXl9IGZyb20gJy4vU1ZHT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoQnJvd3Nlci50b3VjaCAmJiAoIUJyb3dzZXIucG9pbnRlciB8fCBCcm93c2VyLnNhZmFyaSkpIHtcblx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIFRhcCk7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzIGV4Y2VwdCBmb3Igb2xkIEFuZHJvaWRzLlxuXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2ggJiYgIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IFV0aWwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4vTWFwJztcbmltcG9ydCB7Qm94Wm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Cb3hab29tJztcbk1hcC5Cb3hab29tID0gQm94Wm9vbTtcbmltcG9ydCB7RG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbSc7XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuaW1wb3J0IHtEcmFnfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRyYWcnO1xuTWFwLkRyYWcgPSBEcmFnO1xuaW1wb3J0IHtLZXlib2FyZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5LZXlib2FyZCc7XG5NYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbmltcG9ydCB7U2Nyb2xsV2hlZWxab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbSc7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuaW1wb3J0IHtUYXB9IGZyb20gJy4vaGFuZGxlci9NYXAuVGFwJztcbk1hcC5UYXAgPSBUYXA7XG5pbXBvcnQge1RvdWNoWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Ub3VjaFpvb20nO1xuTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuZXhwb3J0IHtNYXAsIGNyZWF0ZU1hcCBhcyBtYXB9IGZyb20gJy4vTWFwJztcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiOyIsImltcG9ydCAnLi9zdHlsZS5jc3MnO1xuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCc7XG5pbXBvcnQgJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzcyc7XG4vKiBUaGlzIGNvZGUgaXMgbmVlZGVkIHRvIHByb3Blcmx5IGxvYWQgdGhlIGltYWdlcyBpbiB0aGUgTGVhZmxldCBDU1MgKi9cbmRlbGV0ZSBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUuX2dldEljb25Vcmw7XG5MLkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xuICBpY29uUmV0aW5hVXJsOiByZXF1aXJlKCdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLTJ4LnBuZycpLFxuICBpY29uVXJsOiByZXF1aXJlKCdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZycpLFxuICBzaGFkb3dVcmw6IHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmcnKSxcbn0pO1xuXG4oJ3VzZSBzdHJpY3QnKTtcblxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBtb250aHMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcblxuY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3JtJyk7XG5jb25zdCBjb250YWluZXJXb3Jrb3V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy53b3Jrb3V0cycpO1xuY29uc3QgaW5wdXRUeXBlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm1fX2lucHV0LS10eXBlJyk7XG5jb25zdCBpbnB1dERpc3RhbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm1fX2lucHV0LS1kaXN0YW5jZScpO1xuY29uc3QgaW5wdXREdXJhdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3JtX19pbnB1dC0tZHVyYXRpb24nKTtcbmNvbnN0IGlucHV0Q2FkZW5jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3JtX19pbnB1dC0tY2FkZW5jZScpO1xuY29uc3QgaW5wdXRFbGV2YXRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybV9faW5wdXQtLWVsZXZhdGlvbicpO1xubGV0IG1hcCwgbWFwRXZlbnQ7XG5cbmNsYXNzIEFwcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2dldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5tYXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWFwJyk7XG4gICAgdGhpcy5tYXBFdmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYXBFdmVudCcpO1xuICB9XG5cbiAgX2dldFBvc2l0aW9uKCkge1xuICAgIGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgIHRoaXMuX2xvYWRNYXAuYmluZCh0aGlzKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFsZXJ0KCdubyBsb2NhdGlvbicpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9sb2FkTWFwKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBsYXRpdHVkZSB9ID0gcG9zaXRpb24uY29vcmRzO1xuICAgIGNvbnN0IHsgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgY29uc3QgY29vcmRzID0gW2xhdGl0dWRlLCBsb25naXR1ZGVdO1xuICAgIHRoaXMubWFwID0gTC5tYXAoJ21hcCcpLnNldFZpZXcoY29vcmRzLCAxNSk7XG5cbiAgICBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLmZyL2hvdC97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICBhdHRyaWJ1dGlvbjpcbiAgICAgICAgJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJyxcbiAgICB9KS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgdGhpcy5tYXAub24oJ2NsaWNrJywgdGhpcy5fc2hvd0Zvcm0uYmluZCh0aGlzKSk7XG4gIH1cblxuICBfc2hvd0Zvcm0obWFwRXZ0KSB7XG4gICAgdGhpcy5tYXBFdmVudCA9IG1hcEV2dDtcbiAgICBmb3JtLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIGlucHV0RGlzdGFuY2UuZm9jdXMoKTtcbiAgfVxuXG4gIF90b2dnbGVFbGV2YXRpb25GaWVsZCgpIHtcbiAgICBpbnB1dEVsZXZhdGlvbi5jbG9zZXN0KCcuZm9ybV9fcm93JykuY2xhc3NMaXN0LnRvZ2dsZSgnZm9ybV9fcm93LS1oaWRkZW4nKTtcbiAgICBpbnB1dENhZGVuY2UuY2xvc2VzdCgnLmZvcm1fX3JvdycpLmNsYXNzTGlzdC50b2dnbGUoJ2Zvcm1fX3Jvdy0taGlkZGVuJyk7XG4gIH1cblxuICBfbmV3V29ya291dChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvL2NsZWFyIGlucHV0IGZpZWxkc1xuICAgIGlucHV0RGlzdGFuY2UudmFsdWUgPVxuICAgICAgaW5wdXREdXJhdGlvbi52YWx1ZSA9XG4gICAgICBpbnB1dENhZGVuY2UudmFsdWUgPVxuICAgICAgaW5wdXRFbGV2YXRpb24udmFsdWUgPVxuICAgICAgICAnJztcbiAgICAvL2Rpc3BsYXkgbWFya2VyXG4gICAgY29uc3QgeyBsYXQsIGxuZyB9ID0gdGhpcy5tYXBFdmVudC5sYXRsbmc7XG4gICAgTC5tYXJrZXIoW2xhdCwgbG5nXSlcbiAgICAgIC5hZGRUbyh0aGlzLm1hcClcbiAgICAgIC5iaW5kUG9wdXAoXG4gICAgICAgIEwucG9wdXAoe1xuICAgICAgICAgIG1heFdpZHRoOiAyNTAsXG4gICAgICAgICAgbWluV2lkdGg6IDEwMCxcbiAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgIGNsb3NlT25DbGljazogZmFsc2UsXG4gICAgICAgICAgY2xhc3NOYW1lOiAncnVubmluZy1wb3B1cCcsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAuc2V0UG9wdXBDb250ZW50KCd3b3JrLW91cicpXG4gICAgICAub3BlblBvcHVwKCk7XG4gIH1cblxuICBzZXRFdmVudExpc3RlbmVycygpIHtcbiAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuX25ld1dvcmtvdXQuYmluZCh0aGlzKSk7XG4gICAgaW5wdXRUeXBlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3RvZ2dsZUVsZXZhdGlvbkZpZWxkKTtcbiAgfVxufVxuXG5jb25zdCBhcHAgPSBuZXcgQXBwKCk7XG5hcHAuc2V0RXZlbnRMaXN0ZW5lcnMoKTtcbiJdLCJuYW1lcyI6WyJleHRlbmQiLCJkZXN0IiwiaSIsImoiLCJsZW4iLCJzcmMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjcmVhdGUiLCJPYmplY3QiLCJGIiwicHJvdG8iLCJwcm90b3R5cGUiLCJiaW5kIiwiZm4iLCJvYmoiLCJzbGljZSIsIkFycmF5IiwiYXBwbHkiLCJjYWxsIiwiYXJncyIsImNvbmNhdCIsImxhc3RJZCIsInN0YW1wIiwiX2xlYWZsZXRfaWQiLCJ0aHJvdHRsZSIsInRpbWUiLCJjb250ZXh0IiwibG9jayIsIndyYXBwZXJGbiIsImxhdGVyIiwic2V0VGltZW91dCIsIndyYXBOdW0iLCJ4IiwicmFuZ2UiLCJpbmNsdWRlTWF4IiwibWF4IiwibWluIiwiZCIsImZhbHNlRm4iLCJmb3JtYXROdW0iLCJudW0iLCJkaWdpdHMiLCJwb3ciLCJNYXRoIiwidW5kZWZpbmVkIiwicm91bmQiLCJ0cmltIiwic3RyIiwicmVwbGFjZSIsInNwbGl0V29yZHMiLCJzcGxpdCIsInNldE9wdGlvbnMiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJnZXRQYXJhbVN0cmluZyIsImV4aXN0aW5nVXJsIiwidXBwZXJjYXNlIiwicGFyYW1zIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsImpvaW4iLCJ0ZW1wbGF0ZVJlIiwidGVtcGxhdGUiLCJkYXRhIiwia2V5IiwidmFsdWUiLCJFcnJvciIsImlzQXJyYXkiLCJ0b1N0cmluZyIsImFycmF5IiwiZWwiLCJlbXB0eUltYWdlVXJsIiwiZ2V0UHJlZml4ZWQiLCJuYW1lIiwid2luZG93IiwibGFzdFRpbWUiLCJ0aW1lb3V0RGVmZXIiLCJEYXRlIiwidGltZVRvQ2FsbCIsInJlcXVlc3RGbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEZuIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpZCIsImNsZWFyVGltZW91dCIsInJlcXVlc3RBbmltRnJhbWUiLCJpbW1lZGlhdGUiLCJjYW5jZWxBbmltRnJhbWUiLCJDbGFzcyIsInByb3BzIiwiTmV3Q2xhc3MiLCJpbml0aWFsaXplIiwiY2FsbEluaXRIb29rcyIsInBhcmVudFByb3RvIiwiX19zdXBlcl9fIiwiVXRpbC5jcmVhdGUiLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJVdGlsLmV4dGVuZCIsImluY2x1ZGVzIiwiY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMiLCJfaW5pdEhvb2tzIiwiX2luaXRIb29rc0NhbGxlZCIsImluY2x1ZGUiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJVdGlsLmlzQXJyYXkiLCJFdmVudHMiLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwib24iLCJ0eXBlcyIsInR5cGUiLCJfb24iLCJVdGlsLnNwbGl0V29yZHMiLCJvZmYiLCJfZXZlbnRzIiwiX29mZiIsInR5cGVMaXN0ZW5lcnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsImxpc3RlbmVycyIsIlV0aWwuZmFsc2VGbiIsImwiLCJfZmlyaW5nQ291bnQiLCJzcGxpY2UiLCJmaXJlIiwicHJvcGFnYXRlIiwibGlzdGVucyIsImV2ZW50IiwidGFyZ2V0Iiwic291cmNlVGFyZ2V0IiwiX3Byb3BhZ2F0ZUV2ZW50IiwiX2V2ZW50UGFyZW50cyIsIm9uY2UiLCJoYW5kbGVyIiwiVXRpbC5iaW5kIiwiYWRkRXZlbnRQYXJlbnQiLCJVdGlsLnN0YW1wIiwicmVtb3ZlRXZlbnRQYXJlbnQiLCJlIiwibGF5ZXIiLCJwcm9wYWdhdGVkRnJvbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJBbGxFdmVudExpc3RlbmVycyIsImFkZE9uZVRpbWVFdmVudExpc3RlbmVyIiwiZmlyZUV2ZW50IiwiaGFzRXZlbnRMaXN0ZW5lcnMiLCJFdmVudGVkIiwiUG9pbnQiLCJ5IiwidHJ1bmMiLCJ2IiwiZmxvb3IiLCJjZWlsIiwiY2xvbmUiLCJhZGQiLCJwb2ludCIsIl9hZGQiLCJ0b1BvaW50Iiwic3VidHJhY3QiLCJfc3VidHJhY3QiLCJkaXZpZGVCeSIsIl9kaXZpZGVCeSIsIm11bHRpcGx5QnkiLCJfbXVsdGlwbHlCeSIsInNjYWxlQnkiLCJ1bnNjYWxlQnkiLCJfcm91bmQiLCJfZmxvb3IiLCJfY2VpbCIsIl90cnVuYyIsImRpc3RhbmNlVG8iLCJzcXJ0IiwiZXF1YWxzIiwiY29udGFpbnMiLCJhYnMiLCJCb3VuZHMiLCJhIiwiYiIsInBvaW50cyIsImdldENlbnRlciIsImdldEJvdHRvbUxlZnQiLCJnZXRUb3BSaWdodCIsImdldFRvcExlZnQiLCJnZXRCb3R0b21SaWdodCIsImdldFNpemUiLCJ0b0JvdW5kcyIsImludGVyc2VjdHMiLCJib3VuZHMiLCJtaW4yIiwibWF4MiIsInhJbnRlcnNlY3RzIiwieUludGVyc2VjdHMiLCJvdmVybGFwcyIsInhPdmVybGFwcyIsInlPdmVybGFwcyIsImlzVmFsaWQiLCJMYXRMbmdCb3VuZHMiLCJjb3JuZXIxIiwiY29ybmVyMiIsImxhdGxuZ3MiLCJzdyIsIl9zb3V0aFdlc3QiLCJuZSIsIl9ub3J0aEVhc3QiLCJzdzIiLCJuZTIiLCJMYXRMbmciLCJ0b0xhdExuZyIsInRvTGF0TG5nQm91bmRzIiwibGF0IiwibG5nIiwicGFkIiwiYnVmZmVyUmF0aW8iLCJoZWlnaHRCdWZmZXIiLCJ3aWR0aEJ1ZmZlciIsImdldFNvdXRoV2VzdCIsImdldE5vcnRoRWFzdCIsImdldE5vcnRoV2VzdCIsImdldE5vcnRoIiwiZ2V0V2VzdCIsImdldFNvdXRoRWFzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImxhdEludGVyc2VjdHMiLCJsbmdJbnRlcnNlY3RzIiwibGF0T3ZlcmxhcHMiLCJsbmdPdmVybGFwcyIsInRvQkJveFN0cmluZyIsIm1heE1hcmdpbiIsImFsdCIsImlzTmFOIiwibWFyZ2luIiwicHJlY2lzaW9uIiwiVXRpbC5mb3JtYXROdW0iLCJvdGhlciIsIkVhcnRoIiwiZGlzdGFuY2UiLCJ3cmFwIiwid3JhcExhdExuZyIsInNpemVJbk1ldGVycyIsImxhdEFjY3VyYWN5IiwibG5nQWNjdXJhY3kiLCJjb3MiLCJQSSIsImMiLCJsb24iLCJDUlMiLCJsYXRMbmdUb1BvaW50IiwibGF0bG5nIiwiem9vbSIsInByb2plY3RlZFBvaW50IiwicHJvamVjdGlvbiIsInByb2plY3QiLCJzY2FsZSIsInRyYW5zZm9ybWF0aW9uIiwiX3RyYW5zZm9ybSIsInBvaW50VG9MYXRMbmciLCJ1bnRyYW5zZm9ybWVkUG9pbnQiLCJ1bnRyYW5zZm9ybSIsInVucHJvamVjdCIsImxvZyIsIkxOMiIsImdldFByb2plY3RlZEJvdW5kcyIsImluZmluaXRlIiwicyIsInRyYW5zZm9ybSIsIndyYXBMbmciLCJVdGlsLndyYXBOdW0iLCJ3cmFwTGF0Iiwid3JhcExhdExuZ0JvdW5kcyIsImNlbnRlciIsIm5ld0NlbnRlciIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwiUiIsImxhdGxuZzEiLCJsYXRsbmcyIiwicmFkIiwibGF0MSIsImxhdDIiLCJzaW5ETGF0Iiwic2luIiwic2luRExvbiIsImF0YW4yIiwiZWFydGhSYWRpdXMiLCJTcGhlcmljYWxNZXJjYXRvciIsIk1BWF9MQVRJVFVERSIsImF0YW4iLCJleHAiLCJUcmFuc2Zvcm1hdGlvbiIsIl9hIiwiX2IiLCJfYyIsIl9kIiwidG9UcmFuc2Zvcm1hdGlvbiIsIkVQU0czODU3IiwiY29kZSIsIkVQU0c5MDA5MTMiLCJzdmdDcmVhdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiY2xvc2VkIiwibGVuMiIsInAiLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiZG9jdW1lbnRFbGVtZW50IiwiaWUiLCJpZWx0OSIsImVkZ2UiLCJuYXZpZ2F0b3IiLCJ3ZWJraXQiLCJ1c2VyQWdlbnRDb250YWlucyIsImFuZHJvaWQiLCJhbmRyb2lkMjMiLCJ3ZWJraXRWZXIiLCJwYXJzZUludCIsImV4ZWMiLCJ1c2VyQWdlbnQiLCJhbmRyb2lkU3RvY2siLCJvcGVyYSIsImNocm9tZSIsImdlY2tvIiwic2FmYXJpIiwicGhhbnRvbSIsIm9wZXJhMTIiLCJ3aW4iLCJwbGF0Zm9ybSIsImllM2QiLCJ3ZWJraXQzZCIsIldlYktpdENTU01hdHJpeCIsImdlY2tvM2QiLCJhbnkzZCIsIkxfRElTQUJMRV8zRCIsIm1vYmlsZSIsIm9yaWVudGF0aW9uIiwibW9iaWxlV2Via2l0IiwibW9iaWxlV2Via2l0M2QiLCJtc1BvaW50ZXIiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsInBvaW50ZXIiLCJ0b3VjaCIsIkxfTk9fVE9VQ0giLCJEb2N1bWVudFRvdWNoIiwibW9iaWxlT3BlcmEiLCJtb2JpbGVHZWNrbyIsInJldGluYSIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJwYXNzaXZlRXZlbnRzIiwic3VwcG9ydHNQYXNzaXZlT3B0aW9uIiwib3B0cyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJzdmciLCJjcmVhdGVTVkdSZWN0Iiwidm1sIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hhcGUiLCJmaXJzdENoaWxkIiwiYmVoYXZpb3IiLCJhZGoiLCJ0b0xvd2VyQ2FzZSIsIlBPSU5URVJfRE9XTiIsIkJyb3dzZXIubXNQb2ludGVyIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwiX3BvaW50ZXJzIiwiX3BvaW50ZXJEb2NMaXN0ZW5lciIsImFkZFBvaW50ZXJMaXN0ZW5lciIsIl9hZGRQb2ludGVyU3RhcnQiLCJfYWRkUG9pbnRlck1vdmUiLCJfYWRkUG9pbnRlckVuZCIsInJlbW92ZVBvaW50ZXJMaXN0ZW5lciIsIm9uRG93biIsIk1TUE9JTlRFUl9UWVBFX1RPVUNIIiwicG9pbnRlclR5cGUiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIl9oYW5kbGVQb2ludGVyIiwiX2dsb2JhbFBvaW50ZXJEb3duIiwiX2dsb2JhbFBvaW50ZXJNb3ZlIiwiX2dsb2JhbFBvaW50ZXJVcCIsInBvaW50ZXJJZCIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIm9uTW92ZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiYnV0dG9ucyIsIm9uVXAiLCJfdG91Y2hzdGFydCIsIkJyb3dzZXIucG9pbnRlciIsIl90b3VjaGVuZCIsIl9wcmUiLCJhZGREb3VibGVUYXBMaXN0ZW5lciIsImxhc3QiLCJkb3VibGVUYXAiLCJkZWxheSIsIm9uVG91Y2hTdGFydCIsImlzUHJpbWFyeSIsIm5vdyIsImRlbHRhIiwib25Ub3VjaEVuZCIsImNhbmNlbEJ1YmJsZSIsIm5ld1RvdWNoIiwicHJvcCIsImJ1dHRvbiIsIkJyb3dzZXIucGFzc2l2ZUV2ZW50cyIsInBhc3NpdmUiLCJyZW1vdmVEb3VibGVUYXBMaXN0ZW5lciIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsImRibGNsaWNrIiwiVFJBTlNGT1JNIiwidGVzdFByb3AiLCJUUkFOU0lUSU9OIiwiVFJBTlNJVElPTl9FTkQiLCJnZXRFbGVtZW50QnlJZCIsImdldFN0eWxlIiwiY3VycmVudFN0eWxlIiwiZGVmYXVsdFZpZXciLCJjc3MiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwicmVtb3ZlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW1wdHkiLCJ0b0Zyb250IiwibGFzdENoaWxkIiwidG9CYWNrIiwiaW5zZXJ0QmVmb3JlIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRDbGFzcyIsIlJlZ0V4cCIsInRlc3QiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJzZXRDbGFzcyIsInJlbW92ZUNsYXNzIiwiVXRpbC50cmltIiwiYmFzZVZhbCIsImNvcnJlc3BvbmRpbmdFbGVtZW50Iiwic2V0T3BhY2l0eSIsIm9wYWNpdHkiLCJfc2V0T3BhY2l0eUlFIiwiZmlsdGVyIiwiZmlsdGVyTmFtZSIsImZpbHRlcnMiLCJpdGVtIiwiRW5hYmxlZCIsIk9wYWNpdHkiLCJzZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJwb3MiLCJCcm93c2VyLmllM2QiLCJzZXRQb3NpdGlvbiIsIl9sZWFmbGV0X3BvcyIsIkJyb3dzZXIuYW55M2QiLCJsZWZ0IiwidG9wIiwiZ2V0UG9zaXRpb24iLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJfdXNlclNlbGVjdCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwidXNlclNlbGVjdFByb3BlcnR5IiwiZGlzYWJsZUltYWdlRHJhZyIsImVuYWJsZUltYWdlRHJhZyIsIl9vdXRsaW5lRWxlbWVudCIsIl9vdXRsaW5lU3R5bGUiLCJwcmV2ZW50T3V0bGluZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsInJlc3RvcmVPdXRsaW5lIiwib3V0bGluZSIsImdldFNpemVkUGFyZW50Tm9kZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiYm9keSIsImdldFNjYWxlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRpbmdDbGllbnRSZWN0IiwiYWRkT25lIiwiZXZlbnRzS2V5IiwicmVtb3ZlT25lIiwiYnJvd3NlckZpcmVzTmF0aXZlRGJsQ2xpY2siLCJCcm93c2VyLmVkZ2UiLCJCcm93c2VyLnNhZmFyaSIsIm1vdXNlU3Vic3QiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIndoZWVsIiwib3JpZ2luYWxIYW5kbGVyIiwiQnJvd3Nlci50b3VjaCIsImlzRXh0ZXJuYWxUYXJnZXQiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ2luYWxFdmVudCIsIl9zdG9wcGVkIiwic2tpcHBlZCIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiZmFrZVN0b3AiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwic3RvcCIsImdldE1vdXNlUG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJ3aGVlbFB4RmFjdG9yIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmNocm9tZSIsIkJyb3dzZXIuZ2Vja28iLCJnZXRXaGVlbERlbHRhIiwid2hlZWxEZWx0YVkiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVoiLCJ3aGVlbERlbHRhIiwiZGV0YWlsIiwic2tpcEV2ZW50cyIsImV2ZW50cyIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwiZXJyIiwiUG9zQW5pbWF0aW9uIiwicnVuIiwibmV3UG9zIiwiZHVyYXRpb24iLCJlYXNlTGluZWFyaXR5IiwiX2VsIiwiX2luUHJvZ3Jlc3MiLCJfZHVyYXRpb24iLCJfZWFzZU91dFBvd2VyIiwiX3N0YXJ0UG9zIiwiRG9tVXRpbC5nZXRQb3NpdGlvbiIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJVdGlsLnJlcXVlc3RBbmltRnJhbWUiLCJlbGFwc2VkIiwiX3J1bkZyYW1lIiwiX2Vhc2VPdXQiLCJwcm9ncmVzcyIsIkRvbVV0aWwuc2V0UG9zaXRpb24iLCJVdGlsLmNhbmNlbEFuaW1GcmFtZSIsInQiLCJNYXAiLCJjcnMiLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiVXRpbC5zZXRPcHRpb25zIiwiX2hhbmRsZXJzIiwiX2xheWVycyIsIl96b29tQm91bmRMYXllcnMiLCJfc2l6ZUNoYW5nZWQiLCJfaW5pdENvbnRhaW5lciIsIl9pbml0TGF5b3V0IiwiX29uUmVzaXplIiwiX2luaXRFdmVudHMiLCJzZXRNYXhCb3VuZHMiLCJfem9vbSIsIl9saW1pdFpvb20iLCJzZXRWaWV3IiwicmVzZXQiLCJfem9vbUFuaW1hdGVkIiwiRG9tVXRpbC5UUkFOU0lUSU9OIiwiQnJvd3Nlci5tb2JpbGVPcGVyYSIsIl9jcmVhdGVBbmltUHJveHkiLCJfcHJveHkiLCJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwiX2NhdGNoVHJhbnNpdGlvbkVuZCIsIl9hZGRMYXllcnMiLCJfbGltaXRDZW50ZXIiLCJfc3RvcCIsIl9sb2FkZWQiLCJhbmltYXRlIiwicGFuIiwibW92ZWQiLCJfdHJ5QW5pbWF0ZWRab29tIiwiX3RyeUFuaW1hdGVkUGFuIiwiX3NpemVUaW1lciIsIl9yZXNldFZpZXciLCJzZXRab29tIiwiem9vbUluIiwiem9vbU91dCIsInNldFpvb21Bcm91bmQiLCJnZXRab29tU2NhbGUiLCJ2aWV3SGFsZiIsImNvbnRhaW5lclBvaW50IiwibGF0TG5nVG9Db250YWluZXJQb2ludCIsImNlbnRlck9mZnNldCIsImNvbnRhaW5lclBvaW50VG9MYXRMbmciLCJfZ2V0Qm91bmRzQ2VudGVyWm9vbSIsImdldEJvdW5kcyIsInBhZGRpbmdUTCIsInBhZGRpbmdUb3BMZWZ0IiwicGFkZGluZyIsInBhZGRpbmdCUiIsInBhZGRpbmdCb3R0b21SaWdodCIsImdldEJvdW5kc1pvb20iLCJJbmZpbml0eSIsInBhZGRpbmdPZmZzZXQiLCJzd1BvaW50IiwibmVQb2ludCIsImZpdEJvdW5kcyIsImZpdFdvcmxkIiwicGFuVG8iLCJwYW5CeSIsImdldFpvb20iLCJfcGFuQW5pbSIsIl9vblBhblRyYW5zaXRpb25TdGVwIiwiX29uUGFuVHJhbnNpdGlvbkVuZCIsIm5vTW92ZVN0YXJ0IiwiRG9tVXRpbC5hZGRDbGFzcyIsIl9tYXBQYW5lIiwiX2dldE1hcFBhbmVQb3MiLCJfcmF3UGFuQnkiLCJmbHlUbyIsInRhcmdldENlbnRlciIsInRhcmdldFpvb20iLCJmcm9tIiwidG8iLCJzaXplIiwic3RhcnRab29tIiwidzAiLCJ3MSIsInUxIiwicmhvIiwicmhvMiIsInIiLCJzMSIsInMyIiwidDEiLCJiMSIsInNxIiwic2luaCIsIm4iLCJjb3NoIiwidGFuaCIsInIwIiwidyIsInUiLCJlYXNlT3V0Iiwic3RhcnQiLCJTIiwiZnJhbWUiLCJfZmx5VG9GcmFtZSIsIl9tb3ZlIiwiZ2V0U2NhbGVab29tIiwiX21vdmVFbmQiLCJfbW92ZVN0YXJ0IiwiZmx5VG9Cb3VuZHMiLCJfcGFuSW5zaWRlTWF4Qm91bmRzIiwic2V0TWluWm9vbSIsIm9sZFpvb20iLCJzZXRNYXhab29tIiwicGFuSW5zaWRlQm91bmRzIiwiX2VuZm9yY2luZ0JvdW5kcyIsInBhbkluc2lkZSIsInBpeGVsQ2VudGVyIiwicGl4ZWxQb2ludCIsInBpeGVsQm91bmRzIiwiZ2V0UGl4ZWxCb3VuZHMiLCJoYWxmUGl4ZWxCb3VuZHMiLCJwYWRkZWRCb3VuZHMiLCJkaWZmIiwiaW52YWxpZGF0ZVNpemUiLCJvbGRTaXplIiwiX2xhc3RDZW50ZXIiLCJuZXdTaXplIiwib2xkQ2VudGVyIiwiZGVib3VuY2VNb3ZlZW5kIiwibG9jYXRlIiwiX2xvY2F0ZU9wdGlvbnMiLCJ0aW1lb3V0Iiwid2F0Y2giLCJfaGFuZGxlR2VvbG9jYXRpb25FcnJvciIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJjb29yZHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jb250YWluZXIiLCJEb21VdGlsLnJlbW92ZSIsIl9jbGVhckNvbnRyb2xQb3MiLCJfcmVzaXplUmVxdWVzdCIsIl9jbGVhckhhbmRsZXJzIiwiX3BhbmVzIiwiX3JlbmRlcmVyIiwiY3JlYXRlUGFuZSIsInBhbmUiLCJEb21VdGlsLmNyZWF0ZSIsIl9jaGVja0lmTG9hZGVkIiwiX21vdmVkIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2dldENlbnRlckxheWVyUG9pbnQiLCJnZXRNaW5ab29tIiwiX2xheWVyc01pblpvb20iLCJnZXRNYXhab29tIiwiX2xheWVyc01heFpvb20iLCJpbnNpZGUiLCJudyIsInNlIiwiYm91bmRzU2l6ZSIsInNuYXAiLCJzY2FsZXgiLCJzY2FsZXkiLCJfc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidG9wTGVmdFBvaW50IiwiX2dldFRvcExlZnRQb2ludCIsImdldFBpeGVsT3JpZ2luIiwiX3BpeGVsT3JpZ2luIiwiZ2V0UGl4ZWxXb3JsZEJvdW5kcyIsImdldFBhbmUiLCJnZXRQYW5lcyIsImdldENvbnRhaW5lciIsInRvWm9vbSIsImZyb21ab29tIiwibGF0TG5nVG9MYXllclBvaW50IiwiY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQiLCJsYXllclBvaW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsIkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24iLCJtb3VzZUV2ZW50VG9MYXllclBvaW50IiwibW91c2VFdmVudFRvTGF0TG5nIiwiRG9tVXRpbC5nZXQiLCJfb25TY3JvbGwiLCJfZmFkZUFuaW1hdGVkIiwiQnJvd3Nlci5yZXRpbmEiLCJCcm93c2VyLmllbHQ5IiwicG9zaXRpb24iLCJEb21VdGlsLmdldFN0eWxlIiwiX2luaXRQYW5lcyIsIl9pbml0Q29udHJvbFBvcyIsInBhbmVzIiwiX3BhbmVSZW5kZXJlcnMiLCJtYXJrZXJQYW5lIiwic2hhZG93UGFuZSIsImxvYWRpbmciLCJ6b29tQ2hhbmdlZCIsIl9nZXROZXdQaXhlbE9yaWdpbiIsInBpbmNoIiwiX2dldFpvb21TcGFuIiwiX3RhcmdldHMiLCJvbk9mZiIsIl9oYW5kbGVET01FdmVudCIsIl9vbk1vdmVFbmQiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiX2ZpbmRFdmVudFRhcmdldHMiLCJ0YXJnZXRzIiwiaXNIb3ZlciIsInNyY0VsZW1lbnQiLCJkcmFnZ2luZyIsIl9zaW11bGF0ZWQiLCJfZHJhZ2dhYmxlTW92ZWQiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJfZmlyZURPTUV2ZW50IiwiX21vdXNlRXZlbnRzIiwic3ludGgiLCJpc01hcmtlciIsImdldExhdExuZyIsIl9yYWRpdXMiLCJidWJibGluZ01vdXNlRXZlbnRzIiwiVXRpbC5pbmRleE9mIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwicHJveHkiLCJtYXBQYW5lIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIl9hbmltYXRpbmdab29tIiwiX29uWm9vbVRyYW5zaXRpb25FbmQiLCJfYW5pbU1vdmVFbmQiLCJfZGVzdHJveUFuaW1Qcm94eSIsInoiLCJwcm9wZXJ0eU5hbWUiLCJfbm90aGluZ1RvQW5pbWF0ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYW5pbWF0ZVpvb20iLCJzdGFydEFuaW0iLCJub1VwZGF0ZSIsIl9hbmltYXRlVG9DZW50ZXIiLCJfYW5pbWF0ZVRvWm9vbSIsImNyZWF0ZU1hcCIsIkNvbnRyb2wiLCJtYXAiLCJfbWFwIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJhZGRUbyIsIm9uQWRkIiwiY29ybmVyIiwiX2NvbnRyb2xDb3JuZXJzIiwib25SZW1vdmUiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiTGF5ZXJzIiwiY29sbGFwc2VkIiwiYXV0b1pJbmRleCIsImhpZGVTaW5nbGVCYXNlIiwic29ydExheWVycyIsInNvcnRGdW5jdGlvbiIsImxheWVyQSIsImxheWVyQiIsIm5hbWVBIiwibmFtZUIiLCJiYXNlTGF5ZXJzIiwib3ZlcmxheXMiLCJfbGF5ZXJDb250cm9sSW5wdXRzIiwiX2xhc3RaSW5kZXgiLCJfaGFuZGxpbmdDbGljayIsIl9hZGRMYXllciIsIl91cGRhdGUiLCJfY2hlY2tEaXNhYmxlZExheWVycyIsIl9vbkxheWVyQ2hhbmdlIiwiX2V4cGFuZElmTm90Q29sbGFwc2VkIiwiYWRkQmFzZUxheWVyIiwiYWRkT3ZlcmxheSIsInJlbW92ZUxheWVyIiwiX2dldExheWVyIiwiZXhwYW5kIiwiX3NlY3Rpb24iLCJhY2NlcHRhYmxlSGVpZ2h0Iiwib2Zmc2V0VG9wIiwiY29sbGFwc2UiLCJzZXRBdHRyaWJ1dGUiLCJEb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsIkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsInNlY3Rpb24iLCJCcm93c2VyLmFuZHJvaWQiLCJsaW5rIiwiX2xheWVyc0xpbmsiLCJocmVmIiwidGl0bGUiLCJEb21FdmVudC5zdG9wIiwiX2Jhc2VMYXllcnNMaXN0IiwiX3NlcGFyYXRvciIsIl9vdmVybGF5c0xpc3QiLCJvdmVybGF5Iiwic29ydCIsInNldFpJbmRleCIsIkRvbVV0aWwuZW1wdHkiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiZGlzcGxheSIsIl9jcmVhdGVSYWRpb0VsZW1lbnQiLCJjaGVja2VkIiwicmFkaW9IdG1sIiwicmFkaW9GcmFnbWVudCIsImxhYmVsIiwiaGFzTGF5ZXIiLCJpbnB1dCIsImRlZmF1bHRDaGVja2VkIiwibGF5ZXJJZCIsIl9vbklucHV0Q2xpY2siLCJob2xkZXIiLCJpbnB1dHMiLCJhZGRlZExheWVycyIsInJlbW92ZWRMYXllcnMiLCJhZGRMYXllciIsImRpc2FibGVkIiwiX2V4cGFuZCIsIl9jb2xsYXBzZSIsIlpvb20iLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsInNoaWZ0S2V5IiwiaHRtbCIsInpvb21Db250cm9sIiwiU2NhbGUiLCJtYXhXaWR0aCIsIm1ldHJpYyIsImltcGVyaWFsIiwiX2FkZFNjYWxlcyIsInVwZGF0ZVdoZW5JZGxlIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInRleHQiLCJyYXRpbyIsInBvdzEwIiwiQXR0cmlidXRpb24iLCJwcmVmaXgiLCJfYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb25Db250cm9sIiwiZ2V0QXR0cmlidXRpb24iLCJhZGRBdHRyaWJ1dGlvbiIsInNldFByZWZpeCIsInJlbW92ZUF0dHJpYnV0aW9uIiwiYXR0cmlicyIsInByZWZpeEFuZEF0dHJpYnMiLCJhdHRyaWJ1dGlvbiIsIkhhbmRsZXIiLCJfZW5hYmxlZCIsImFkZEhvb2tzIiwicmVtb3ZlSG9va3MiLCJTVEFSVCIsIkVORCIsIm1vdXNlZG93biIsInBvaW50ZXJkb3duIiwiTVNQb2ludGVyRG93biIsIk1PVkUiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwiRG9tVXRpbC5oYXNDbGFzcyIsIndoaWNoIiwiRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnIiwiRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiIsIl9tb3ZpbmciLCJmaXJzdCIsInNpemVkUGFyZW50IiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJfc3RhcnRQb2ludCIsIl9wYXJlbnRTY2FsZSIsIkRvbVV0aWwuZ2V0U2NhbGUiLCJfb25Nb3ZlIiwiX29uVXAiLCJfbGFzdFRhcmdldCIsIlNWR0VsZW1lbnRJbnN0YW5jZSIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwiX25ld1BvcyIsIl9hbmltUmVxdWVzdCIsIl9sYXN0RXZlbnQiLCJfdXBkYXRlUG9zaXRpb24iLCJEb21VdGlsLmVuYWJsZUltYWdlRHJhZyIsIkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiIsInNpbXBsaWZ5IiwidG9sZXJhbmNlIiwic3FUb2xlcmFuY2UiLCJfcmVkdWNlUG9pbnRzIiwiX3NpbXBsaWZ5RFAiLCJwb2ludFRvU2VnbWVudERpc3RhbmNlIiwicDEiLCJwMiIsIl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCIsImNsb3Nlc3RQb2ludE9uU2VnbWVudCIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsIm1heFNxRGlzdCIsImluZGV4Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwiY2xpcFNlZ21lbnQiLCJ1c2VMYXN0Q29kZSIsImNvZGVBIiwiX2dldEJpdENvZGUiLCJjb2RlQiIsImNvZGVPdXQiLCJuZXdDb2RlIiwiX2dldEVkZ2VJbnRlcnNlY3Rpb24iLCJkb3QiLCJpc0ZsYXQiLCJfZmxhdCIsImNsaXBQb2x5Z29uIiwiY2xpcHBlZFBvaW50cyIsImVkZ2VzIiwiayIsIl9jb2RlIiwiTGluZVV0aWwuX2dldEJpdENvZGUiLCJMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbiIsIkxvbkxhdCIsIk1lcmNhdG9yIiwiUl9NSU5PUiIsInRtcCIsImNvbiIsInRzIiwidGFuIiwicGhpIiwiZHBoaSIsIkVQU0czMzk1IiwiRVBTRzQzMjYiLCJTaW1wbGUiLCJMYXllciIsInJlbW92ZUZyb20iLCJfbWFwVG9BZGQiLCJhZGRJbnRlcmFjdGl2ZVRhcmdldCIsInRhcmdldEVsIiwicmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQiLCJfbGF5ZXJBZGQiLCJnZXRFdmVudHMiLCJiZWZvcmVBZGQiLCJlYWNoTGF5ZXIiLCJtZXRob2QiLCJfYWRkWm9vbUxpbWl0IiwiX3VwZGF0ZVpvb21MZXZlbHMiLCJfcmVtb3ZlWm9vbUxpbWl0Iiwib2xkWm9vbVNwYW4iLCJMYXllckdyb3VwIiwiZ2V0TGF5ZXJJZCIsImNsZWFyTGF5ZXJzIiwiaW52b2tlIiwibWV0aG9kTmFtZSIsImdldExheWVyIiwiZ2V0TGF5ZXJzIiwiekluZGV4IiwibGF5ZXJHcm91cCIsIkZlYXR1cmVHcm91cCIsInNldFN0eWxlIiwiYnJpbmdUb0Zyb250IiwiYnJpbmdUb0JhY2siLCJmZWF0dXJlR3JvdXAiLCJJY29uIiwicG9wdXBBbmNob3IiLCJ0b29sdGlwQW5jaG9yIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsImFuY2hvciIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiaWNvbiIsIkljb25EZWZhdWx0IiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsInNoYWRvd1NpemUiLCJpbWFnZVBhdGgiLCJfZGV0ZWN0SWNvblBhdGgiLCJwYXRoIiwiTWFya2VyRHJhZyIsIm1hcmtlciIsIl9tYXJrZXIiLCJfaWNvbiIsIl9kcmFnZ2FibGUiLCJkcmFnc3RhcnQiLCJfb25EcmFnU3RhcnQiLCJwcmVkcmFnIiwiX29uUHJlRHJhZyIsImRyYWciLCJfb25EcmFnIiwiZHJhZ2VuZCIsIl9vbkRyYWdFbmQiLCJfYWRqdXN0UGFuIiwic3BlZWQiLCJhdXRvUGFuU3BlZWQiLCJhdXRvUGFuUGFkZGluZyIsImljb25Qb3MiLCJvcmlnaW4iLCJwYW5Cb3VuZHMiLCJtb3ZlbWVudCIsIl9wYW5SZXF1ZXN0IiwiX29sZExhdExuZyIsImNsb3NlUG9wdXAiLCJhdXRvUGFuIiwic2hhZG93IiwiX3NoYWRvdyIsIl9sYXRsbmciLCJvbGRMYXRMbmciLCJNYXJrZXIiLCJpbnRlcmFjdGl2ZSIsImtleWJvYXJkIiwiekluZGV4T2Zmc2V0IiwicmlzZU9uSG92ZXIiLCJyaXNlT2Zmc2V0IiwiZHJhZ2dhYmxlIiwibGF0TG5nIiwiX2luaXRJY29uIiwidXBkYXRlIiwiX3JlbW92ZUljb24iLCJfcmVtb3ZlU2hhZG93Iiwidmlld3Jlc2V0Iiwic2V0TGF0TG5nIiwic2V0WkluZGV4T2Zmc2V0IiwiZ2V0SWNvbiIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJnZXRFbGVtZW50IiwiX3NldFBvcyIsImNsYXNzVG9BZGQiLCJhZGRJY29uIiwibW91c2VvdmVyIiwiX2JyaW5nVG9Gcm9udCIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwibmV3U2hhZG93IiwiYWRkU2hhZG93IiwiX3VwZGF0ZU9wYWNpdHkiLCJfaW5pdEludGVyYWN0aW9uIiwiX3pJbmRleCIsIl91cGRhdGVaSW5kZXgiLCJvcHQiLCJEb21VdGlsLnNldE9wYWNpdHkiLCJfZ2V0UG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsIlBhdGgiLCJzdHJva2UiLCJjb2xvciIsIndlaWdodCIsImxpbmVDYXAiLCJsaW5lSm9pbiIsImRhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJmaWxsUnVsZSIsImdldFJlbmRlcmVyIiwiX2luaXRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBhdGgiLCJfcmVtb3ZlUGF0aCIsInJlZHJhdyIsIl91cGRhdGVQYXRoIiwiX3VwZGF0ZVN0eWxlIiwiX3VwZGF0ZUJvdW5kcyIsIl9icmluZ1RvQmFjayIsIl9wYXRoIiwiX3Byb2plY3QiLCJfY2xpY2tUb2xlcmFuY2UiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJzZXRSYWRpdXMiLCJnZXRSYWRpdXMiLCJfcG9pbnQiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9ib3VuZHMiLCJfY29udGFpbnNQb2ludCIsImNpcmNsZU1hcmtlciIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwiYm90dG9tIiwibG5nUiIsImFjb3MiLCJjaXJjbGUiLCJQb2x5bGluZSIsInNtb290aEZhY3RvciIsIm5vQ2xpcCIsIl9zZXRMYXRMbmdzIiwiZ2V0TGF0TG5ncyIsIl9sYXRsbmdzIiwic2V0TGF0TG5ncyIsImlzRW1wdHkiLCJjbG9zZXN0TGF5ZXJQb2ludCIsIm1pbkRpc3RhbmNlIiwibWluUG9pbnQiLCJjbG9zZXN0IiwiTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50IiwiakxlbiIsIl9wYXJ0cyIsImhhbGZEaXN0Iiwic2VnRGlzdCIsImRpc3QiLCJfcmluZ3MiLCJhZGRMYXRMbmciLCJfZGVmYXVsdFNoYXBlIiwiX2NvbnZlcnRMYXRMbmdzIiwiTGluZVV0aWwuaXNGbGF0IiwicmVzdWx0IiwiZmxhdCIsIl9wcm9qZWN0TGF0bG5ncyIsIl9yYXdQeEJvdW5kcyIsInByb2plY3RlZEJvdW5kcyIsInJpbmciLCJfY2xpcFBvaW50cyIsInBhcnRzIiwic2VnbWVudCIsIkxpbmVVdGlsLmNsaXBTZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiTGluZVV0aWwuc2ltcGxpZnkiLCJfdXBkYXRlUG9seSIsInBhcnQiLCJMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlIiwicG9seWxpbmUiLCJMaW5lVXRpbC5fZmxhdCIsIlBvbHlnb24iLCJmIiwiYXJlYSIsInBvcCIsImNsaXBwZWQiLCJQb2x5VXRpbC5jbGlwUG9seWdvbiIsInBvbHlnb24iLCJHZW9KU09OIiwiZ2VvanNvbiIsImFkZERhdGEiLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJnZW9tZXRyaWVzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImdlb21ldHJ5VG9MYXllciIsImFzRmVhdHVyZSIsImRlZmF1bHRPcHRpb25zIiwicmVzZXRTdHlsZSIsIm9uRWFjaEZlYXR1cmUiLCJfc2V0TGF5ZXJTdHlsZSIsInBvaW50VG9MYXllciIsIl9jb29yZHNUb0xhdExuZyIsImNvb3Jkc1RvTGF0TG5nIiwiX3BvaW50VG9MYXllciIsImNvb3Jkc1RvTGF0TG5ncyIsInByb3BlcnRpZXMiLCJwb2ludFRvTGF5ZXJGbiIsIm1hcmtlcnNJbmhlcml0T3B0aW9ucyIsImxldmVsc0RlZXAiLCJsYXRMbmdUb0Nvb3JkcyIsImxhdExuZ3NUb0Nvb3JkcyIsImdldEZlYXR1cmUiLCJuZXdHZW9tZXRyeSIsIlBvaW50VG9HZW9KU09OIiwidG9HZW9KU09OIiwibXVsdGkiLCJob2xlcyIsInRvTXVsdGlQb2ludCIsImlzR2VvbWV0cnlDb2xsZWN0aW9uIiwianNvbnMiLCJqc29uIiwiZ2VvSlNPTiIsImdlb0pzb24iLCJJbWFnZU92ZXJsYXkiLCJjcm9zc09yaWdpbiIsImVycm9yT3ZlcmxheVVybCIsInVybCIsIl91cmwiLCJfaW1hZ2UiLCJfaW5pdEltYWdlIiwic3R5bGVPcHRzIiwiRG9tVXRpbC50b0Zyb250IiwiRG9tVXRpbC50b0JhY2siLCJzZXRVcmwiLCJzZXRCb3VuZHMiLCJ6b29tYW5pbSIsIndhc0VsZW1lbnRTdXBwbGllZCIsIm9uc2VsZWN0c3RhcnQiLCJvbm1vdXNlbW92ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfb3ZlcmxheU9uRXJyb3IiLCJpbWFnZSIsImVycm9yVXJsIiwiaW1hZ2VPdmVybGF5IiwiVmlkZW9PdmVybGF5IiwiYXV0b3BsYXkiLCJsb29wIiwia2VlcEFzcGVjdFJhdGlvIiwibXV0ZWQiLCJ2aWQiLCJvbmxvYWRlZGRhdGEiLCJzb3VyY2VFbGVtZW50cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic291cmNlcyIsInNvdXJjZSIsInZpZGVvT3ZlcmxheSIsInZpZGVvIiwiU1ZHT3ZlcmxheSIsInN2Z092ZXJsYXkiLCJEaXZPdmVybGF5IiwiX3NvdXJjZSIsIl9yZW1vdmVUaW1lb3V0IiwiZ2V0Q29udGVudCIsIl9jb250ZW50Iiwic2V0Q29udGVudCIsImNvbnRlbnQiLCJ2aXNpYmlsaXR5IiwiX3VwZGF0ZUNvbnRlbnQiLCJfdXBkYXRlTGF5b3V0IiwiaXNPcGVuIiwiX3ByZXBhcmVPcGVuIiwibm9kZSIsIl9jb250ZW50Tm9kZSIsImhhc0NoaWxkTm9kZXMiLCJfZ2V0QW5jaG9yIiwiX2NvbnRhaW5lckJvdHRvbSIsIl9jb250YWluZXJMZWZ0IiwiX2NvbnRhaW5lcldpZHRoIiwiUG9wdXAiLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImF1dG9QYW5QYWRkaW5nVG9wTGVmdCIsImF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQiLCJrZWVwSW5WaWV3IiwiY2xvc2VCdXR0b24iLCJhdXRvQ2xvc2UiLCJjbG9zZU9uRXNjYXBlS2V5Iiwib3Blbk9uIiwib3BlblBvcHVwIiwicG9wdXAiLCJEb21FdmVudC5zdG9wUHJvcGFnYXRpb24iLCJjbG9zZU9uQ2xpY2siLCJjbG9zZVBvcHVwT25DbGljayIsInByZWNsaWNrIiwiX2Nsb3NlIiwibW92ZWVuZCIsIndyYXBwZXIiLCJfd3JhcHBlciIsIl90aXBDb250YWluZXIiLCJfdGlwIiwiX2Nsb3NlQnV0dG9uIiwiX29uQ2xvc2VCdXR0b25DbGljayIsIndoaXRlU3BhY2UiLCJzY3JvbGxlZENsYXNzIiwibWFyZ2luQm90dG9tIiwiY29udGFpbmVySGVpZ2h0IiwiY29udGFpbmVyV2lkdGgiLCJsYXllclBvcyIsImNvbnRhaW5lclBvcyIsIl9wb3B1cEhhbmRsZXJzQWRkZWQiLCJjbGljayIsIl9vcGVuUG9wdXAiLCJrZXlwcmVzcyIsIl9vbktleVByZXNzIiwibW92ZSIsIl9tb3ZlUG9wdXAiLCJ1bmJpbmRQb3B1cCIsInRvZ2dsZVBvcHVwIiwiaXNQb3B1cE9wZW4iLCJzZXRQb3B1cENvbnRlbnQiLCJnZXRQb3B1cCIsImtleUNvZGUiLCJUb29sdGlwIiwiZGlyZWN0aW9uIiwicGVybWFuZW50Iiwic3RpY2t5IiwidG9vbHRpcCIsImNsb3NlVG9vbHRpcCIsIl9zZXRQb3NpdGlvbiIsInN1YlgiLCJzdWJZIiwidG9vbHRpcFBvaW50IiwidG9vbHRpcFdpZHRoIiwidG9vbHRpcEhlaWdodCIsIm9wZW5Ub29sdGlwIiwiYmluZFRvb2x0aXAiLCJfdG9vbHRpcCIsIl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyIsInVuYmluZFRvb2x0aXAiLCJfdG9vbHRpcEhhbmRsZXJzQWRkZWQiLCJfbW92ZVRvb2x0aXAiLCJfb3BlblRvb2x0aXAiLCJtb3VzZW1vdmUiLCJ0b2dnbGVUb29sdGlwIiwiaXNUb29sdGlwT3BlbiIsInNldFRvb2x0aXBDb250ZW50IiwiZ2V0VG9vbHRpcCIsIkRpdkljb24iLCJiZ1BvcyIsIkVsZW1lbnQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJkaXZJY29uIiwiRGVmYXVsdCIsIkdyaWRMYXllciIsInRpbGVTaXplIiwiQnJvd3Nlci5tb2JpbGUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl90aWxlcyIsIl9yZW1vdmVBbGxUaWxlcyIsIl90aWxlWm9vbSIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ2aWV3cHJlcmVzZXQiLCJfaW52YWxpZGF0ZUFsbCIsIlV0aWwudGhyb3R0bGUiLCJjcmVhdGVUaWxlIiwiZ2V0VGlsZVNpemUiLCJjb21wYXJlIiwiY2hpbGRyZW4iLCJlZGdlWkluZGV4IiwiaXNGaW5pdGUiLCJuZXh0RnJhbWUiLCJ3aWxsUHJ1bmUiLCJ0aWxlIiwiY3VycmVudCIsImxvYWRlZCIsImZhZGUiLCJhY3RpdmUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJfdXBkYXRlTGV2ZWxzIiwiTnVtYmVyIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsImxldmVsIiwiX3NldFpvb21UcmFuc2Zvcm0iLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJfY2xhbXBab29tIiwibm9QcnVuZSIsInRpbGVab29tIiwidGlsZVpvb21DaGFuZ2VkIiwiX2Fib3J0TG9hZGluZyIsIl9yZXNldEdyaWQiLCJfc2V0Wm9vbVRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJfdGlsZVNpemUiLCJfZ2xvYmFsVGlsZVJhbmdlIiwiX3B4Qm91bmRzVG9UaWxlUmFuZ2UiLCJfd3JhcFgiLCJfd3JhcFkiLCJfZ2V0VGlsZWRQaXhlbEJvdW5kcyIsIm1hcFpvb20iLCJoYWxmU2l6ZSIsInRpbGVSYW5nZSIsInRpbGVDZW50ZXIiLCJxdWV1ZSIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwidGlsZUJvdW5kcyIsIl90aWxlQ29vcmRzVG9Cb3VuZHMiLCJfa2V5VG9Cb3VuZHMiLCJfa2V5VG9UaWxlQ29vcmRzIiwiX3RpbGVDb29yZHNUb053U2UiLCJud1BvaW50Iiwic2VQb2ludCIsImJwIiwiX2luaXRUaWxlIiwiQnJvd3Nlci5hbmRyb2lkMjMiLCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkiLCJ0aWxlUG9zIiwiX2dldFRpbGVQb3MiLCJfd3JhcENvb3JkcyIsIl90aWxlUmVhZHkiLCJfbm9UaWxlc1RvTG9hZCIsIm5ld0Nvb3JkcyIsImdyaWRMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJfb25UaWxlUmVtb3ZlIiwibm9SZWRyYXciLCJkb25lIiwiX3RpbGVPbkxvYWQiLCJfdGlsZU9uRXJyb3IiLCJnZXRUaWxlVXJsIiwiX2dldFN1YmRvbWFpbiIsIl9nZXRab29tRm9yVXJsIiwiaW52ZXJ0ZWRZIiwiVXRpbC50ZW1wbGF0ZSIsImdldEF0dHJpYnV0ZSIsInRpbGVQb2ludCIsImNvbXBsZXRlIiwiVXRpbC5lbXB0eUltYWdlVXJsIiwiQnJvd3Nlci5hbmRyb2lkU3RvY2siLCJ0aWxlTGF5ZXIiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsInZlcnNpb24iLCJ3bXNQYXJhbXMiLCJyZWFsUmV0aW5hIiwiX2NycyIsIl93bXNWZXJzaW9uIiwicGFyc2VGbG9hdCIsInByb2plY3Rpb25LZXkiLCJiYm94Iiwic2V0UGFyYW1zIiwidGlsZUxheWVyV01TIiwiV01TIiwid21zIiwiUmVuZGVyZXIiLCJfdXBkYXRlUGF0aHMiLCJfZGVzdHJveUNvbnRhaW5lciIsIl9vblpvb20iLCJ6b29tZW5kIiwiX29uWm9vbUVuZCIsIl9vbkFuaW1ab29tIiwiZXYiLCJfdXBkYXRlVHJhbnNmb3JtIiwiY3VycmVudENlbnRlclBvaW50IiwiX2NlbnRlciIsImRlc3RDZW50ZXJQb2ludCIsInRvcExlZnRPZmZzZXQiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd1JlcXVlc3QiLCJfcmVkcmF3Qm91bmRzIiwiX3JlZHJhdyIsIm0iLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJuZXh0IiwiX2RyYXdGaXJzdCIsIl9yZXF1ZXN0UmVkcmF3IiwiX2V4dGVuZFJlZHJhd0JvdW5kcyIsImRhc2hWYWx1ZSIsIl9kYXNoQXJyYXkiLCJfY2xlYXIiLCJjbGVhclJlY3QiLCJzYXZlIiwicmVzdG9yZSIsImJlZ2luUGF0aCIsImNsaXAiLCJfZHJhd2luZyIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJfZmlyZUV2ZW50IiwibW92aW5nIiwiX2hhbmRsZU1vdXNlSG92ZXIiLCJfaG92ZXJlZExheWVyIiwiX21vdXNlSG92ZXJUaHJvdHRsZWQiLCJjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIiLCJCcm93c2VyLmNhbnZhcyIsInZtbENyZWF0ZSIsIm5hbWVzcGFjZXMiLCJ2bWxNaXhpbiIsImNvb3Jkc2l6ZSIsIl9zdHJva2UiLCJfZmlsbCIsInN0cm9rZWQiLCJmaWxsZWQiLCJkYXNoU3R5bGUiLCJlbmRjYXAiLCJqb2luc3R5bGUiLCJfc2V0UGF0aCIsIkJyb3dzZXIudm1sIiwiU1ZHIiwiem9vbXN0YXJ0IiwiX29uWm9vbVN0YXJ0IiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwicmVtb3ZlQXR0cmlidXRlIiwiX2dldFBhbmVSZW5kZXJlciIsIl9jcmVhdGVSZW5kZXJlciIsInByZWZlckNhbnZhcyIsIlJlY3RhbmdsZSIsIl9ib3VuZHNUb0xhdExuZ3MiLCJyZWN0YW5nbGUiLCJCb3hab29tIiwiX3BhbmUiLCJvdmVybGF5UGFuZSIsIl9yZXNldFN0YXRlVGltZW91dCIsIl9kZXN0cm95IiwiX29uTW91c2VEb3duIiwiX3Jlc2V0U3RhdGUiLCJfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUiLCJjb250ZXh0bWVudSIsIm1vdXNldXAiLCJfb25Nb3VzZVVwIiwia2V5ZG93biIsIl9vbktleURvd24iLCJfYm94IiwiX2ZpbmlzaCIsImJveFpvb21Cb3VuZHMiLCJkb3VibGVDbGlja1pvb20iLCJEb3VibGVDbGlja1pvb20iLCJfb25Eb3VibGVDbGljayIsImluZXJ0aWEiLCJpbmVydGlhRGVjZWxlcmF0aW9uIiwiaW5lcnRpYU1heFNwZWVkIiwid29ybGRDb3B5SnVtcCIsIm1heEJvdW5kc1Zpc2Nvc2l0eSIsIkRyYWciLCJfb25QcmVEcmFnTGltaXQiLCJfb25QcmVEcmFnV3JhcCIsIl9wb3NpdGlvbnMiLCJfdGltZXMiLCJfb2Zmc2V0TGltaXQiLCJfdmlzY29zaXR5IiwiX2xhc3RUaW1lIiwiX2xhc3RQb3MiLCJfYWJzUG9zIiwiX3BydW5lUG9zaXRpb25zIiwic2hpZnQiLCJweENlbnRlciIsInB4V29ybGRDZW50ZXIiLCJfaW5pdGlhbFdvcmxkT2Zmc2V0IiwiX3dvcmxkV2lkdGgiLCJfdmlzY291c0xpbWl0IiwidGhyZXNob2xkIiwibGltaXQiLCJ3b3JsZFdpZHRoIiwiaGFsZldpZHRoIiwibmV3WDEiLCJuZXdYMiIsIm5ld1giLCJub0luZXJ0aWEiLCJlYXNlIiwic3BlZWRWZWN0b3IiLCJsaW1pdGVkU3BlZWQiLCJsaW1pdGVkU3BlZWRWZWN0b3IiLCJkZWNlbGVyYXRpb25EdXJhdGlvbiIsImtleWJvYXJkUGFuRGVsdGEiLCJLZXlib2FyZCIsImtleUNvZGVzIiwiZG93biIsInVwIiwiX3NldFBhbkRlbHRhIiwiX3NldFpvb21EZWx0YSIsIl9vbkZvY3VzIiwiYmx1ciIsIl9vbkJsdXIiLCJfYWRkSG9va3MiLCJfcmVtb3ZlSG9va3MiLCJfZm9jdXNlZCIsImRvY0VsIiwic2Nyb2xsVG8iLCJwYW5EZWx0YSIsImtleXMiLCJfcGFuS2V5cyIsImNvZGVzIiwiX3pvb21LZXlzIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzY3JvbGxXaGVlbFpvb20iLCJ3aGVlbERlYm91bmNlVGltZSIsIndoZWVsUHhQZXJab29tTGV2ZWwiLCJTY3JvbGxXaGVlbFpvb20iLCJfb25XaGVlbFNjcm9sbCIsIl9kZWx0YSIsIkRvbUV2ZW50LmdldFdoZWVsRGVsdGEiLCJkZWJvdW5jZSIsIl9sYXN0TW91c2VQb3MiLCJfdGltZXIiLCJfcGVyZm9ybVpvb20iLCJkMiIsImQzIiwiZDQiLCJ0YXAiLCJ0YXBUb2xlcmFuY2UiLCJUYXAiLCJfZmlyZUNsaWNrIiwiX2hvbGRUaW1lb3V0IiwiX2lzVGFwVmFsaWQiLCJfc2ltdWxhdGVFdmVudCIsInRvdWNobW92ZSIsInNpbXVsYXRlZEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJfc2ltdWxhdGVkQ2xpY2siLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJ0b3VjaFpvb20iLCJib3VuY2VBdFpvb21MaW1pdHMiLCJUb3VjaFpvb20iLCJfb25Ub3VjaFN0YXJ0IiwiX3pvb21pbmciLCJfY2VudGVyUG9pbnQiLCJfc3RhcnRMYXRMbmciLCJfcGluY2hTdGFydExhdExuZyIsIl9zdGFydERpc3QiLCJfc3RhcnRab29tIiwiX29uVG91Y2hNb3ZlIiwiX29uVG91Y2hFbmQiLCJtb3ZlRm4iLCJyZXF1aXJlIiwibW9udGhzIiwiZm9ybSIsInF1ZXJ5U2VsZWN0b3IiLCJjb250YWluZXJXb3Jrb3V0cyIsImlucHV0VHlwZSIsImlucHV0RGlzdGFuY2UiLCJpbnB1dER1cmF0aW9uIiwiaW5wdXRDYWRlbmNlIiwiaW5wdXRFbGV2YXRpb24iLCJtYXBFdmVudCIsIkFwcCIsIl9nZXRQb3NpdGlvbiIsIl9sb2FkTWFwIiwiYWxlcnQiLCJfc2hvd0Zvcm0iLCJtYXBFdnQiLCJfdG9nZ2xlRWxldmF0aW9uRmllbGQiLCJ0b2dnbGUiLCJfbmV3V29ya291dCIsImV2dCIsInNldEV2ZW50TGlzdGVuZXJzIiwiYXBwIl0sInNvdXJjZVJvb3QiOiIifQ==