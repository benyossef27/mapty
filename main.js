/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  var version = "1.7.1";
  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */
  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.

  function extend(dest) {
    var i, j, len, src;

    for (j = 1, len = arguments.length; j < len; j++) {
      src = arguments[j];

      for (i in src) {
        dest[i] = src[i];
      }
    }

    return dest;
  } // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)


  var create = Object.create || function () {
    function F() {}

    return function (proto) {
      F.prototype = proto;
      return new F();
    };
  }(); // @function bind(fn: Function, …): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.


  function bind(fn, obj) {
    var slice = Array.prototype.slice;

    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1));
    }

    var args = slice.call(arguments, 2);
    return function () {
      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
    };
  } // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)


  var lastId = 0; // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.

  function stamp(obj) {
    /*eslint-disable */
    obj._leaflet_id = obj._leaflet_id || ++lastId;
    return obj._leaflet_id;
    /* eslint-enable */
  } // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.


  function throttle(fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
      // reset lock and call if queued
      lock = false;

      if (args) {
        wrapperFn.apply(context, args);
        args = false;
      }
    };

    wrapperFn = function () {
      if (lock) {
        // called too soon, queue to call later
        args = arguments;
      } else {
        // call and lock until later
        fn.apply(context, arguments);
        setTimeout(later, time);
        lock = true;
      }
    };

    return wrapperFn;
  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.


  function wrapNum(x, range, includeMax) {
    var max = range[1],
        min = range[0],
        d = max - min;
    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  } // @function falseFn(): Function
  // Returns a function which always returns `false`.


  function falseFn() {
    return false;
  } // @function formatNum(num: Number, digits?: Number): Number
  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.


  function formatNum(num, digits) {
    var pow = Math.pow(10, digits === undefined ? 6 : digits);
    return Math.round(num * pow) / pow;
  } // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)


  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  } // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.


  function splitWords(str) {
    return trim(str).split(/\s+/);
  } // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.


  function setOptions(obj, options) {
    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
      obj.options = obj.options ? create(obj.options) : {};
    }

    for (var i in options) {
      obj.options[i] = options[i];
    }

    return obj.options;
  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)


  function getParamString(obj, existingUrl, uppercase) {
    var params = [];

    for (var i in obj) {
      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
    }

    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_-]+) *\}/g; // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values — they will be evaluated passing `data` as an argument.

  function template(str, data) {
    return str.replace(templateRe, function (str, key) {
      var value = data[key];

      if (value === undefined) {
        throw new Error('No value provided for variable ' + str);
      } else if (typeof value === 'function') {
        value = value(data);
      }

      return value;
    });
  } // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)


  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }; // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)


  function indexOf(array, el) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === el) {
        return i;
      }
    }

    return -1;
  } // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).


  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0; // fallback for IE 7-8

  function timeoutDefer(fn) {
    var time = +new Date(),
        timeToCall = Math.max(0, 16 - (time - lastTime));
    lastTime = time + timeToCall;
    return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;

  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
    window.clearTimeout(id);
  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.


  function requestAnimFrame(fn, context, immediate) {
    if (immediate && requestFn === timeoutDefer) {
      fn.call(context);
    } else {
      return requestFn.call(window, bind(fn, context));
    }
  } // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).


  function cancelAnimFrame(id) {
    if (id) {
      cancelFn.call(window, id);
    }
  }

  var Util = {
    extend: extend,
    create: create,
    bind: bind,
    lastId: lastId,
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  }; // @class Class
  // @aka L.Class
  // @section
  // @uninheritable
  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {
    // @function extend(props: Object): Function
    // [Extends the current class](#class-inheritance) given the properties to be included.
    // Returns a Javascript function that is a class constructor (to be called with `new`).
    var NewClass = function () {
      // call the constructor
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      } // call all constructor hooks


      this.callInitHooks();
    };

    var parentProto = NewClass.__super__ = this.prototype;
    var proto = create(parentProto);
    proto.constructor = NewClass;
    NewClass.prototype = proto; // inherit parent's statics

    for (var i in this) {
      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
        NewClass[i] = this[i];
      }
    } // mix static properties into the class


    if (props.statics) {
      extend(NewClass, props.statics);
      delete props.statics;
    } // mix includes into the prototype


    if (props.includes) {
      checkDeprecatedMixinEvents(props.includes);
      extend.apply(null, [proto].concat(props.includes));
      delete props.includes;
    } // merge options


    if (proto.options) {
      props.options = extend(create(proto.options), props.options);
    } // mix given properties into the prototype


    extend(proto, props);
    proto._initHooks = []; // add method for calling all hooks

    proto.callInitHooks = function () {
      if (this._initHooksCalled) {
        return;
      }

      if (parentProto.callInitHooks) {
        parentProto.callInitHooks.call(this);
      }

      this._initHooksCalled = true;

      for (var i = 0, len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };

    return NewClass;
  }; // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.


  Class.include = function (props) {
    extend(this.prototype, props);
    return this;
  }; // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.


  Class.mergeOptions = function (options) {
    extend(this.prototype.options, options);
    return this;
  }; // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.


  Class.addInitHook = function (fn) {
    // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);
    var init = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    this.prototype._initHooks = this.prototype._initHooks || [];

    this.prototype._initHooks.push(init);

    return this;
  };

  function checkDeprecatedMixinEvents(includes) {
    if (typeof L === 'undefined' || !L || !L.Mixin) {
      return;
    }

    includes = isArray(includes) ? includes : [includes];

    for (var i = 0; i < includes.length; i++) {
      if (includes[i] === L.Mixin.Events) {
        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
      }
    }
  }
  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */


  var Events = {
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
    on: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === 'object') {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }

      return this;
    },

    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object. This includes implicitly attached events.
     */
    off: function (types, fn, context) {
      if (!types) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (typeof types === 'object') {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      }

      return this;
    },
    // attach listener (without syntactic sugar now)
    _on: function (type, fn, context) {
      this._events = this._events || {};
      /* get/init listeners for type */

      var typeListeners = this._events[type];

      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }

      var newListener = {
        fn: fn,
        ctx: context
      },
          listeners = typeListeners; // check if fn already there

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return;
        }
      }

      listeners.push(newListener);
    },
    _off: function (type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];

      if (!listeners) {
        return;
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        } // clear all listeners for a type if function isn't specified


        delete this._events[type];
        return;
      }

      if (context === this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];

          if (l.ctx !== context) {
            continue;
          }

          if (l.fn === fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }

            listeners.splice(i, 1);
            return;
          }
        }
      }
    },
    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide an data
    // object — the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.
    fire: function (type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });

      if (this._events) {
        var listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;

          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    },
    // @method listens(type: String): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.
    listens: function (type, propagate) {
      var listeners = this._events && this._events[type];

      if (listeners && listeners.length) {
        return true;
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true;
          }
        }
      }

      return false;
    },
    // @method once(…): this
    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
    once: function (types, fn, context) {
      if (typeof types === 'object') {
        for (var type in types) {
          this.once(type, types[type], fn);
        }

        return this;
      }

      var handler = bind(function () {
        this.off(types, fn, context).off(types, handler, context);
      }, this); // add a listener that's executed once and removed after that

      return this.on(types, fn, context).on(types, handler, context);
    },
    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events
    addEventParent: function (obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    },
    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events
    removeEventParent: function (obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }

      return this;
    },
    _propagateEvent: function (e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  }; // aliases; we should ditch those eventually
  // @method addEventListener(…): this
  // Alias to [`on(…)`](#evented-on)

  Events.addEventListener = Events.on; // @method removeEventListener(…): this
  // Alias to [`off(…)`](#evented-off)
  // @method clearAllEventListeners(…): this
  // Alias to [`off()`](#evented-off)

  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this
  // Alias to [`once(…)`](#evented-once)

  Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this
  // Alias to [`fire(…)`](#evented-fire)

  Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean
  // Alias to [`listens(…)`](#evented-listens)

  Events.hasEventListeners = Events.listens;
  var Evented = Class.extend(Events);
  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
    // @property x: Number; The `x` coordinate of the point
    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point

    this.y = round ? Math.round(y) : y;
  }

  var trunc = Math.trunc || function (v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {
    // @method clone(): Point
    // Returns a copy of the current point.
    clone: function () {
      return new Point(this.x, this.y);
    },
    // @method add(otherPoint: Point): Point
    // Returns the result of addition of the current and the given points.
    add: function (point) {
      // non-destructive, returns a new point
      return this.clone()._add(toPoint(point));
    },
    _add: function (point) {
      // destructive, used directly for performance in situations where it's safe to modify existing point
      this.x += point.x;
      this.y += point.y;
      return this;
    },
    // @method subtract(otherPoint: Point): Point
    // Returns the result of subtraction of the given point from the current.
    subtract: function (point) {
      return this.clone()._subtract(toPoint(point));
    },
    _subtract: function (point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },
    // @method divideBy(num: Number): Point
    // Returns the result of division of the current point by the given number.
    divideBy: function (num) {
      return this.clone()._divideBy(num);
    },
    _divideBy: function (num) {
      this.x /= num;
      this.y /= num;
      return this;
    },
    // @method multiplyBy(num: Number): Point
    // Returns the result of multiplication of the current point by the given number.
    multiplyBy: function (num) {
      return this.clone()._multiplyBy(num);
    },
    _multiplyBy: function (num) {
      this.x *= num;
      this.y *= num;
      return this;
    },
    // @method scaleBy(scale: Point): Point
    // Multiply each coordinate of the current point by each coordinate of
    // `scale`. In linear algebra terms, multiply the point by the
    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
    // defined by `scale`.
    scaleBy: function (point) {
      return new Point(this.x * point.x, this.y * point.y);
    },
    // @method unscaleBy(scale: Point): Point
    // Inverse of `scaleBy`. Divide each coordinate of the current point by
    // each coordinate of `scale`.
    unscaleBy: function (point) {
      return new Point(this.x / point.x, this.y / point.y);
    },
    // @method round(): Point
    // Returns a copy of the current point with rounded coordinates.
    round: function () {
      return this.clone()._round();
    },
    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    // @method floor(): Point
    // Returns a copy of the current point with floored coordinates (rounded down).
    floor: function () {
      return this.clone()._floor();
    },
    _floor: function () {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    // @method ceil(): Point
    // Returns a copy of the current point with ceiled coordinates (rounded up).
    ceil: function () {
      return this.clone()._ceil();
    },
    _ceil: function () {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    // @method trunc(): Point
    // Returns a copy of the current point with truncated coordinates (rounded towards zero).
    trunc: function () {
      return this.clone()._trunc();
    },
    _trunc: function () {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    },
    // @method distanceTo(otherPoint: Point): Number
    // Returns the cartesian distance between the current and the given points.
    distanceTo: function (point) {
      point = toPoint(point);
      var x = point.x - this.x,
          y = point.y - this.y;
      return Math.sqrt(x * x + y * y);
    },
    // @method equals(otherPoint: Point): Boolean
    // Returns `true` if the given point has the same coordinates.
    equals: function (point) {
      point = toPoint(point);
      return point.x === this.x && point.y === this.y;
    },
    // @method contains(otherPoint: Point): Boolean
    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
    contains: function (point) {
      point = toPoint(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    },
    // @method toString(): String
    // Returns a string representation of the point for debugging purposes.
    toString: function () {
      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
    }
  }; // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.
  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.
  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.

  function toPoint(x, y, round) {
    if (x instanceof Point) {
      return x;
    }

    if (isArray(x)) {
      return new Point(x[0], x[1]);
    }

    if (x === undefined || x === null) {
      return x;
    }

    if (typeof x === 'object' && 'x' in x && 'y' in x) {
      return new Point(x.x, x.y);
    }

    return new Point(x, y, round);
  }
  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function Bounds(a, b) {
    if (!a) {
      return;
    }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  }

  Bounds.prototype = {
    // @method extend(point: Point): this
    // Extends the bounds to contain the given point.
    extend: function (point) {
      // (Point)
      point = toPoint(point); // @property min: Point
      // The top left corner of the rectangle.
      // @property max: Point
      // The bottom right corner of the rectangle.

      if (!this.min && !this.max) {
        this.min = point.clone();
        this.max = point.clone();
      } else {
        this.min.x = Math.min(point.x, this.min.x);
        this.max.x = Math.max(point.x, this.max.x);
        this.min.y = Math.min(point.y, this.min.y);
        this.max.y = Math.max(point.y, this.max.y);
      }

      return this;
    },
    // @method getCenter(round?: Boolean): Point
    // Returns the center point of the bounds.
    getCenter: function (round) {
      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    },
    // @method getBottomLeft(): Point
    // Returns the bottom-left point of the bounds.
    getBottomLeft: function () {
      return new Point(this.min.x, this.max.y);
    },
    // @method getTopRight(): Point
    // Returns the top-right point of the bounds.
    getTopRight: function () {
      // -> Point
      return new Point(this.max.x, this.min.y);
    },
    // @method getTopLeft(): Point
    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
    getTopLeft: function () {
      return this.min; // left, top
    },
    // @method getBottomRight(): Point
    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
    getBottomRight: function () {
      return this.max; // right, bottom
    },
    // @method getSize(): Point
    // Returns the size of the given bounds
    getSize: function () {
      return this.max.subtract(this.min);
    },
    // @method contains(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains(point: Point): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      var min, max;

      if (typeof obj[0] === 'number' || obj instanceof Point) {
        obj = toPoint(obj);
      } else {
        obj = toBounds(obj);
      }

      if (obj instanceof Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }

      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
    },
    // @method intersects(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds
    // intersect if they have at least one point in common.
    intersects: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xIntersects = max2.x >= min.x && min2.x <= max.x,
          yIntersects = max2.y >= min.y && min2.y <= max.y;
      return xIntersects && yIntersects;
    },
    // @method overlaps(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds
    // overlap if their intersection is an area.
    overlaps: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xOverlaps = max2.x > min.x && min2.x < max.x,
          yOverlaps = max2.y > min.y && min2.y < max.y;
      return xOverlaps && yOverlaps;
    },
    isValid: function () {
      return !!(this.min && this.max);
    }
  }; // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.

  function toBounds(a, b) {
    if (!a || a instanceof Bounds) {
      return a;
    }

    return new Bounds(a, b);
  }
  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLngBounds(corner1, corner2) {
    // (LatLng, LatLng) or (LatLng[])
    if (!corner1) {
      return;
    }

    var latlngs = corner2 ? [corner1, corner2] : corner1;

    for (var i = 0, len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  }

  LatLngBounds.prototype = {
    // @method extend(latlng: LatLng): this
    // Extend the bounds to contain the given point
    // @alternative
    // @method extend(otherBounds: LatLngBounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLng) {
        sw2 = obj;
        ne2 = obj;
      } else if (obj instanceof LatLngBounds) {
        sw2 = obj._southWest;
        ne2 = obj._northEast;

        if (!sw2 || !ne2) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }

      if (!sw && !ne) {
        this._southWest = new LatLng(sw2.lat, sw2.lng);
        this._northEast = new LatLng(ne2.lat, ne2.lng);
      } else {
        sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
      }

      return this;
    },
    // @method pad(bufferRatio: Number): LatLngBounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var sw = this._southWest,
          ne = this._northEast,
          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
    },
    // @method getCenter(): LatLng
    // Returns the center point of the bounds.
    getCenter: function () {
      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    },
    // @method getSouthWest(): LatLng
    // Returns the south-west point of the bounds.
    getSouthWest: function () {
      return this._southWest;
    },
    // @method getNorthEast(): LatLng
    // Returns the north-east point of the bounds.
    getNorthEast: function () {
      return this._northEast;
    },
    // @method getNorthWest(): LatLng
    // Returns the north-west point of the bounds.
    getNorthWest: function () {
      return new LatLng(this.getNorth(), this.getWest());
    },
    // @method getSouthEast(): LatLng
    // Returns the south-east point of the bounds.
    getSouthEast: function () {
      return new LatLng(this.getSouth(), this.getEast());
    },
    // @method getWest(): Number
    // Returns the west longitude of the bounds
    getWest: function () {
      return this._southWest.lng;
    },
    // @method getSouth(): Number
    // Returns the south latitude of the bounds
    getSouth: function () {
      return this._southWest.lat;
    },
    // @method getEast(): Number
    // Returns the east longitude of the bounds
    getEast: function () {
      return this._northEast.lng;
    },
    // @method getNorth(): Number
    // Returns the north latitude of the bounds
    getNorth: function () {
      return this._northEast.lat;
    },
    // @method contains(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains (latlng: LatLng): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      // (LatLngBounds) or (LatLng) -> Boolean
      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
        obj = toLatLng(obj);
      } else {
        obj = toLatLngBounds(obj);
      }

      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }

      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
    },
    // @method intersects(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
    intersects: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
      return latIntersects && lngIntersects;
    },
    // @method overlaps(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
    overlaps: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
      return latOverlaps && lngOverlaps;
    },
    // @method toBBoxString(): String
    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
    toBBoxString: function () {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
    },
    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (bounds, maxMargin) {
      if (!bounds) {
        return false;
      }

      bounds = toLatLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
    },
    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this._southWest && this._northEast);
    }
  }; // TODO International date line?
  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.
  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).

  function toLatLngBounds(a, b) {
    if (a instanceof LatLngBounds) {
      return a;
    }

    return new LatLngBounds(a, b);
  }
  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLng(lat, lng, alt) {
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    } // @property lat: Number
    // Latitude in degrees


    this.lat = +lat; // @property lng: Number
    // Longitude in degrees

    this.lng = +lng; // @property alt: Number
    // Altitude in meters (optional)

    if (alt !== undefined) {
      this.alt = +alt;
    }
  }

  LatLng.prototype = {
    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (obj, maxMargin) {
      if (!obj) {
        return false;
      }

      obj = toLatLng(obj);
      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
    },
    // @method toString(): String
    // Returns a string representation of the point (for debugging purposes).
    toString: function (precision) {
      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
    },
    // @method distanceTo(otherLatLng: LatLng): Number
    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
    distanceTo: function (other) {
      return Earth.distance(this, toLatLng(other));
    },
    // @method wrap(): LatLng
    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
    wrap: function () {
      return Earth.wrapLatLng(this);
    },
    // @method toBounds(sizeInMeters: Number): LatLngBounds
    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
    toBounds: function (sizeInMeters) {
      var latAccuracy = 180 * sizeInMeters / 40075017,
          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
    },
    clone: function () {
      return new LatLng(this.lat, this.lng, this.alt);
    }
  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
    if (a instanceof LatLng) {
      return a;
    }

    if (isArray(a) && typeof a[0] !== 'object') {
      if (a.length === 3) {
        return new LatLng(a[0], a[1], a[2]);
      }

      if (a.length === 2) {
        return new LatLng(a[0], a[1]);
      }

      return null;
    }

    if (a === undefined || a === null) {
      return a;
    }

    if (typeof a === 'object' && 'lat' in a) {
      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
    }

    if (b === undefined) {
      return null;
    }

    return new LatLng(a, b, c);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */


  var CRS = {
    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
    // Projects geographical coordinates into pixel coordinates for a given zoom.
    latLngToPoint: function (latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
          scale = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale);
    },
    // @method pointToLatLng(point: Point, zoom: Number): LatLng
    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
    // zoom into geographical coordinates.
    pointToLatLng: function (point, zoom) {
      var scale = this.scale(zoom),
          untransformedPoint = this.transformation.untransform(point, scale);
      return this.projection.unproject(untransformedPoint);
    },
    // @method project(latlng: LatLng): Point
    // Projects geographical coordinates into coordinates in units accepted for
    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
    project: function (latlng) {
      return this.projection.project(latlng);
    },
    // @method unproject(point: Point): LatLng
    // Given a projected coordinate returns the corresponding LatLng.
    // The inverse of `project`.
    unproject: function (point) {
      return this.projection.unproject(point);
    },
    // @method scale(zoom: Number): Number
    // Returns the scale used when transforming projected coordinates into
    // pixel coordinates for a particular zoom. For example, it returns
    // `256 * 2^zoom` for Mercator-based CRS.
    scale: function (zoom) {
      return 256 * Math.pow(2, zoom);
    },
    // @method zoom(scale: Number): Number
    // Inverse of `scale()`, returns the zoom level corresponding to a scale
    // factor of `scale`.
    zoom: function (scale) {
      return Math.log(scale / 256) / Math.LN2;
    },
    // @method getProjectedBounds(zoom: Number): Bounds
    // Returns the projection's bounds scaled and transformed for the provided `zoom`.
    getProjectedBounds: function (zoom) {
      if (this.infinite) {
        return null;
      }

      var b = this.projection.bounds,
          s = this.scale(zoom),
          min = this.transformation.transform(b.min, s),
          max = this.transformation.transform(b.max, s);
      return new Bounds(min, max);
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates.
    // @property code: String
    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
    //
    // @property wrapLng: Number[]
    // An array of two numbers defining whether the longitude (horizontal) coordinate
    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
    //
    // @property wrapLat: Number[]
    // Like `wrapLng`, but for the latitude (vertical) axis.
    // wrapLng: [min, max],
    // wrapLat: [min, max],
    // @property infinite: Boolean
    // If true, the coordinate space will be unbounded (infinite in both axes)
    infinite: false,
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where lat and lng has been wrapped according to the
    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
    wrapLatLng: function (latlng) {
      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
          alt = latlng.alt;
      return new LatLng(lat, lng, alt);
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring
    // that its center is within the CRS's bounds.
    // Only accepts actual `L.LatLngBounds` instances, not arrays.
    wrapLatLngBounds: function (bounds) {
      var center = bounds.getCenter(),
          newCenter = this.wrapLatLng(center),
          latShift = center.lat - newCenter.lat,
          lngShift = center.lng - newCenter.lng;

      if (latShift === 0 && lngShift === 0) {
        return bounds;
      }

      var sw = bounds.getSouthWest(),
          ne = bounds.getNorthEast(),
          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
      return new LatLngBounds(newSw, newNe);
    }
  };
  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
    wrapLng: [-180, 180],
    // Mean Earth Radius, as recommended for use by
    // the International Union of Geodesy and Geophysics,
    // see http://rosettacode.org/wiki/Haversine_formula
    R: 6371000,
    // distance between two geographical points using spherical law of cosines approximation
    distance: function (latlng1, latlng2) {
      var rad = Math.PI / 180,
          lat1 = latlng1.lat * rad,
          lat2 = latlng2.lat * rad,
          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return this.R * c;
    }
  });
  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection — the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;
  var SphericalMercator = {
    R: earthRadius,
    MAX_LATITUDE: 85.0511287798,
    project: function (latlng) {
      var d = Math.PI / 180,
          max = this.MAX_LATITUDE,
          lat = Math.max(Math.min(max, latlng.lat), -max),
          sin = Math.sin(lat * d);
      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
    },
    unproject: function (point) {
      var d = 180 / Math.PI;
      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
    },
    bounds: function () {
      var d = earthRadius * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    }()
  };
  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */
  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.

  function Transformation(a, b, c, d) {
    if (isArray(a)) {
      // use array properties
      this._a = a[0];
      this._b = a[1];
      this._c = a[2];
      this._d = a[3];
      return;
    }

    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  }

  Transformation.prototype = {
    // @method transform(point: Point, scale?: Number): Point
    // Returns a transformed point, optionally multiplied by the given scale.
    // Only accepts actual `L.Point` instances, not arrays.
    transform: function (point, scale) {
      // (Point, Number) -> Point
      return this._transform(point.clone(), scale);
    },
    // destructive transform (faster)
    _transform: function (point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },
    // @method untransform(point: Point, scale?: Number): Point
    // Returns the reverse transformation of the given point, optionally divided
    // by the given scale. Only accepts actual `L.Point` instances, not arrays.
    untransform: function (point, scale) {
      scale = scale || 1;
      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }
  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.
  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
    return new Transformation(a, b, c, d);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */


  var EPSG3857 = extend({}, Earth, {
    code: 'EPSG:3857',
    projection: SphericalMercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  var EPSG900913 = extend({}, EPSG3857, {
    code: 'EPSG:900913'
  }); // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:
  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).

  function svgCreate(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  } // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions


  function pointsToPath(rings, closed) {
    var str = '',
        i,
        j,
        len,
        len2,
        points,
        p;

    for (i = 0, len = rings.length; i < len; i++) {
      points = rings[i];

      for (j = 0, len2 = points.length; j < len2; j++) {
        p = points[j];
        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
      } // closes the ring for polygons; "x" is VML syntax


      str += closed ? svg ? 'z' : 'x' : '';
    } // SVG complains about empty path strings


    return str || 'M0 0';
  }
  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */


  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).

  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.

  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.

  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).

  var webkit = userAgentContains('webkit'); // @property android: Boolean
  // `true` for any browser running on an Android platform.

  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.

  var android23 = userAgentContains('android 2') || userAgentContains('android 3');
  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */

  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)

  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser

  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.

  var chrome = !edge && userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.

  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.

  var safari = !chrome && userAgentContains('safari');
  var phantom = userAgentContains('phantom'); // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).

  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform

  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.

  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.

  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.

  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.

  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.

  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.

  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.

  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).

  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).

  var pointer = !!(window.PointerEvent || msPointer); // @property touch: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // This does not necessarily mean that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.

  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.

  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.

  var mobileGecko = mobile && gecko; // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.

  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.

  var passiveEvents = function () {
    var supportsPassiveOption = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function () {
          // eslint-disable-line getter-return
          supportsPassiveOption = true;
        }
      });
      window.addEventListener('testPassiveEventSupport', falseFn, opts);
      window.removeEventListener('testPassiveEventSupport', falseFn, opts);
    } catch (e) {// Errors can safely be ignored since this is only a browser support test.
    }

    return supportsPassiveOption;
  }(); // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).


  var canvas = function () {
    return !!document.createElement('canvas').getContext;
  }(); // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).


  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).

  var vml = !svg && function () {
    try {
      var div = document.createElement('div');
      div.innerHTML = '<v:shape adj="1"/>';
      var shape = div.firstChild;
      shape.style.behavior = 'url(#default#VML)';
      return shape && typeof shape.adj === 'object';
    } catch (e) {
      return false;
    }
  }();

  function userAgentContains(str) {
    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }

  var Browser = {
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas,
    svg: svg,
    vml: vml
  };
  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';
  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';
  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';
  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
  var _pointers = {};
  var _pointerDocListener = false; // Provides a touch events wrapper for (ms)pointer events.
  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler, id) {
    if (type === 'touchstart') {
      _addPointerStart(obj, handler, id);
    } else if (type === 'touchmove') {
      _addPointerMove(obj, handler, id);
    } else if (type === 'touchend') {
      _addPointerEnd(obj, handler, id);
    }

    return this;
  }

  function removePointerListener(obj, type, id) {
    var handler = obj['_leaflet_' + type + id];

    if (type === 'touchstart') {
      obj.removeEventListener(POINTER_DOWN, handler, false);
    } else if (type === 'touchmove') {
      obj.removeEventListener(POINTER_MOVE, handler, false);
    } else if (type === 'touchend') {
      obj.removeEventListener(POINTER_UP, handler, false);
      obj.removeEventListener(POINTER_CANCEL, handler, false);
    }

    return this;
  }

  function _addPointerStart(obj, handler, id) {
    var onDown = bind(function (e) {
      // IE10 specific: MsTouch needs preventDefault. See #2000
      if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
        preventDefault(e);
      }

      _handlePointer(e, handler);
    });
    obj['_leaflet_touchstart' + id] = onDown;
    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation

    if (!_pointerDocListener) {
      // we listen document as any drags that end by moving the touch off the screen get fired there
      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
      document.addEventListener(POINTER_UP, _globalPointerUp, true);
      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
      _pointerDocListener = true;
    }
  }

  function _globalPointerDown(e) {
    _pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
    if (_pointers[e.pointerId]) {
      _pointers[e.pointerId] = e;
    }
  }

  function _globalPointerUp(e) {
    delete _pointers[e.pointerId];
  }

  function _handlePointer(e, handler) {
    e.touches = [];

    for (var i in _pointers) {
      e.touches.push(_pointers[i]);
    }

    e.changedTouches = [e];
    handler(e);
  }

  function _addPointerMove(obj, handler, id) {
    var onMove = function (e) {
      // don't fire touch moves when mouse isn't down
      if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse') && e.buttons === 0) {
        return;
      }

      _handlePointer(e, handler);
    };

    obj['_leaflet_touchmove' + id] = onMove;
    obj.addEventListener(POINTER_MOVE, onMove, false);
  }

  function _addPointerEnd(obj, handler, id) {
    var onUp = function (e) {
      _handlePointer(e, handler);
    };

    obj['_leaflet_touchend' + id] = onUp;
    obj.addEventListener(POINTER_UP, onUp, false);
    obj.addEventListener(POINTER_CANCEL, onUp, false);
  }
  /*
   * Extends the event handling code with double tap support for mobile browsers.
   */


  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';

  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';

  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs

  function addDoubleTapListener(obj, handler, id) {
    var last,
        touch$$1,
        doubleTap = false,
        delay = 250;

    function onTouchStart(e) {
      if (pointer) {
        if (!e.isPrimary) {
          return;
        }

        if (e.pointerType === 'mouse') {
          return;
        } // mouse fires native dblclick

      } else if (e.touches.length > 1) {
        return;
      }

      var now = Date.now(),
          delta = now - (last || now);
      touch$$1 = e.touches ? e.touches[0] : e;
      doubleTap = delta > 0 && delta <= delay;
      last = now;
    }

    function onTouchEnd(e) {
      if (doubleTap && !touch$$1.cancelBubble) {
        if (pointer) {
          if (e.pointerType === 'mouse') {
            return;
          } // work around .type being readonly with MSPointer* events


          var newTouch = {},
              prop,
              i;

          for (i in touch$$1) {
            prop = touch$$1[i];
            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
          }

          touch$$1 = newTouch;
        }

        touch$$1.type = 'dblclick';
        touch$$1.button = 0;
        handler(touch$$1);
        last = null;
      }
    }

    obj[_pre + _touchstart + id] = onTouchStart;
    obj[_pre + _touchend + id] = onTouchEnd;
    obj[_pre + 'dblclick' + id] = handler;
    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {
      passive: false
    } : false);
    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {
      passive: false
    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
    // the browser doesn't fire touchend/pointerup events but does fire
    // native dblclicks. See #4127.
    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.

    obj.addEventListener('dblclick', handler, false);
    return this;
  }

  function removeDoubleTapListener(obj, id) {
    var touchstart = obj[_pre + _touchstart + id],
        touchend = obj[_pre + _touchend + id],
        dblclick = obj[_pre + 'dblclick' + id];
    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener(_touchend, touchend, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener('dblclick', dblclick, false);
    return this;
  }
  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */
  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).


  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser
  // @property TRANSITION: String
  // Vendor-prefixed transition style name.

  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.

  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.

  function get(id) {
    return typeof id === 'string' ? document.getElementById(id) : id;
  } // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.


  function getStyle(el, style) {
    var value = el.style[style] || el.currentStyle && el.currentStyle[style];

    if ((!value || value === 'auto') && document.defaultView) {
      var css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }

    return value === 'auto' ? null : value;
  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.


  function create$1(tagName, className, container) {
    var el = document.createElement(tagName);
    el.className = className || '';

    if (container) {
      container.appendChild(el);
    }

    return el;
  } // @function remove(el: HTMLElement)
  // Removes `el` from its parent element


  function remove(el) {
    var parent = el.parentNode;

    if (parent) {
      parent.removeChild(el);
    }
  } // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`


  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  } // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.


  function toFront(el) {
    var parent = el.parentNode;

    if (parent && parent.lastChild !== el) {
      parent.appendChild(el);
    }
  } // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.


  function toBack(el) {
    var parent = el.parentNode;

    if (parent && parent.firstChild !== el) {
      parent.insertBefore(el, parent.firstChild);
    }
  } // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.


  function hasClass(el, name) {
    if (el.classList !== undefined) {
      return el.classList.contains(name);
    }

    var className = getClass(el);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  } // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.


  function addClass(el, name) {
    if (el.classList !== undefined) {
      var classes = splitWords(name);

      for (var i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      var className = getClass(el);
      setClass(el, (className ? className + ' ' : '') + name);
    }
  } // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.


  function removeClass(el, name) {
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
    }
  } // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.


  function setClass(el, name) {
    if (el.className.baseVal === undefined) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  } // @function getClass(el: HTMLElement): String
  // Returns the element's class.


  function getClass(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }

    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  } // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.


  function setOpacity(el, value) {
    if ('opacity' in el.style) {
      el.style.opacity = value;
    } else if ('filter' in el.style) {
      _setOpacityIE(el, value);
    }
  }

  function _setOpacityIE(el, value) {
    var filter = false,
        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist

    try {
      filter = el.filters.item(filterName);
    } catch (e) {
      // don't set opacity to 1 if we haven't already set an opacity,
      // it isn't needed and breaks transparent pngs.
      if (value === 1) {
        return;
      }
    }

    value = Math.round(value * 100);

    if (filter) {
      filter.Enabled = value !== 100;
      filter.Opacity = value;
    } else {
      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
    }
  } // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.


  function testProp(props) {
    var style = document.documentElement.style;

    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }

    return false;
  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.


  function setTransform(el, offset, scale) {
    var pos = offset || new Point(0, 0);
    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
  } // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).


  function setPosition(el, point) {
    /*eslint-disable */
    el._leaflet_pos = point;
    /* eslint-enable */

    if (any3d) {
      setTransform(el, point);
    } else {
      el.style.left = point.x + 'px';
      el.style.top = point.y + 'px';
    }
  } // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.


  function getPosition(el) {
    // this method is only used for elements previously positioned using setPosition,
    // so it's safe to cache the position for performance
    return el._leaflet_pos || new Point(0, 0);
  } // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.
  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).


  var disableTextSelection;
  var enableTextSelection;

  var _userSelect;

  if ('onselectstart' in document) {
    disableTextSelection = function () {
      on(window, 'selectstart', preventDefault);
    };

    enableTextSelection = function () {
      off(window, 'selectstart', preventDefault);
    };
  } else {
    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

    disableTextSelection = function () {
      if (userSelectProperty) {
        var style = document.documentElement.style;
        _userSelect = style[userSelectProperty];
        style[userSelectProperty] = 'none';
      }
    };

    enableTextSelection = function () {
      if (userSelectProperty) {
        document.documentElement.style[userSelectProperty] = _userSelect;
        _userSelect = undefined;
      }
    };
  } // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.


  function disableImageDrag() {
    on(window, 'dragstart', preventDefault);
  } // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).


  function enableImageDrag() {
    off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle; // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.


  function preventOutline(element) {
    while (element.tabIndex === -1) {
      element = element.parentNode;
    }

    if (!element.style) {
      return;
    }

    restoreOutline();
    _outlineElement = element;
    _outlineStyle = element.style.outline;
    element.style.outline = 'none';
    on(window, 'keydown', restoreOutline);
  } // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().


  function restoreOutline() {
    if (!_outlineElement) {
      return;
    }

    _outlineElement.style.outline = _outlineStyle;
    _outlineElement = undefined;
    _outlineStyle = undefined;
    off(window, 'keydown', restoreOutline);
  } // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.


  function getSizedParentNode(element) {
    do {
      element = element.parentNode;
    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);

    return element;
  } // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).


  function getScale(element) {
    var rect = element.getBoundingClientRect(); // Read-only in old browsers.

    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }

  var DomUtil = {
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    disableTextSelection: disableTextSelection,
    enableTextSelection: enableTextSelection,
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };
  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */
  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).
  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function on(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        addOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        addOne(obj, types[i], fn, context);
      }
    }

    return this;
  }

  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.
  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function off(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        removeOne(obj, type, types[type], fn);
      }
    } else if (types) {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    } else {
      for (var j in obj[eventsKey]) {
        removeOne(obj, j, obj[eventsKey][j]);
      }

      delete obj[eventsKey];
    }

    return this;
  }

  function browserFiresNativeDblClick() {
    // See https://github.com/w3c/pointerevents/issues/171
    if (pointer) {
      return !(edge || safari);
    }
  }

  var mouseSubst = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout',
    wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

    if (obj[eventsKey] && obj[eventsKey][id]) {
      return this;
    }

    var handler = function (e) {
      return fn.call(context || obj, e || window.event);
    };

    var originalHandler = handler;

    if (pointer && type.indexOf('touch') === 0) {
      // Needs DomEvent.Pointer.js
      addPointerListener(obj, type, handler, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      addDoubleTapListener(obj, handler, id);
    } else if ('addEventListener' in obj) {
      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {
        obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {
          passive: false
        } : false);
      } else if (type === 'mouseenter' || type === 'mouseleave') {
        handler = function (e) {
          e = e || window.event;

          if (isExternalTarget(obj, e)) {
            originalHandler(e);
          }
        };

        obj.addEventListener(mouseSubst[type], handler, false);
      } else {
        obj.addEventListener(type, originalHandler, false);
      }
    } else if ('attachEvent' in obj) {
      obj.attachEvent('on' + type, handler);
    }

    obj[eventsKey] = obj[eventsKey] || {};
    obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
        handler = obj[eventsKey] && obj[eventsKey][id];

    if (!handler) {
      return this;
    }

    if (pointer && type.indexOf('touch') === 0) {
      removePointerListener(obj, type, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      removeDoubleTapListener(obj, id);
    } else if ('removeEventListener' in obj) {
      obj.removeEventListener(mouseSubst[type] || type, handler, false);
    } else if ('detachEvent' in obj) {
      obj.detachEvent('on' + type, handler);
    }

    obj[eventsKey][id] = null;
  } // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```


  function stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else if (e.originalEvent) {
      // In case of Leaflet event.
      e.originalEvent._stopped = true;
    } else {
      e.cancelBubble = true;
    }

    skipped(e);
    return this;
  } // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).


  function disableScrollPropagation(el) {
    addOne(el, 'wheel', stopPropagation);
    return this;
  } // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).


  function disableClickPropagation(el) {
    on(el, 'mousedown touchstart dblclick', stopPropagation);
    addOne(el, 'click', fakeStop);
    return this;
  } // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.


  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }

    return this;
  } // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.


  function stop(e) {
    preventDefault(e);
    stopPropagation(e);
    return this;
  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.


  function getMousePosition(e, container) {
    if (!container) {
      return new Point(e.clientX, e.clientY);
    }

    var scale = getScale(container),
        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

    return new Point( // offset.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
  // and Firefox scrolls device pixels, not CSS pixels


  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.

  function getWheelDelta(e) {
    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
    0;
  }

  var skipEvents = {};

  function fakeStop(e) {
    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
    skipEvents[e.type] = true;
  }

  function skipped(e) {
    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map

    skipEvents[e.type] = false;
    return events;
  } // check if element really left/entered the event target (for mouseenter/mouseleave)


  function isExternalTarget(el, e) {
    var related = e.relatedTarget;

    if (!related) {
      return true;
    }

    try {
      while (related && related !== el) {
        related = related.parentNode;
      }
    } catch (err) {
      return false;
    }

    return related !== el;
  }

  var DomEvent = {
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    fakeStop: fakeStop,
    skipped: skipped,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };
  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var fx = new L.PosAnimation();
   * fx.run(el, [300, 500], 0.5);
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({
    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
    // Run an animation of a given element to a new position, optionally setting
    // duration in seconds (`0.25` by default) and easing linearity factor (3rd
    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
    // `0.5` by default).
    run: function (el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date(); // @event start: Event
      // Fired when the animation starts

      this.fire('start');

      this._animate();
    },
    // @method stop()
    // Stops the animation (if currently running).
    stop: function () {
      if (!this._inProgress) {
        return;
      }

      this._step(true);

      this._complete();
    },
    _animate: function () {
      // animation loop
      this._animId = requestAnimFrame(this._animate, this);

      this._step();
    },
    _step: function (round) {
      var elapsed = +new Date() - this._startTime,
          duration = this._duration * 1000;

      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration), round);
      } else {
        this._runFrame(1);

        this._complete();
      }
    },
    _runFrame: function (progress, round) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));

      if (round) {
        pos._round();
      }

      setPosition(this._el, pos); // @event step: Event
      // Fired continuously during the animation.

      this.fire('step');
    },
    _complete: function () {
      cancelAnimFrame(this._animId);
      this._inProgress = false; // @event end: Event
      // Fired when the animation ends.

      this.fire('end');
    },
    _easeOut: function (t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }
  });
  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API — it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({
    options: {
      // @section Map State Options
      // @option crs: CRS = L.CRS.EPSG3857
      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
      // sure what it means.
      crs: EPSG3857,
      // @option center: LatLng = undefined
      // Initial geographic center of the map
      center: undefined,
      // @option zoom: Number = undefined
      // Initial map zoom level
      zoom: undefined,
      // @option minZoom: Number = *
      // Minimum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the lowest of their `minZoom` options will be used instead.
      minZoom: undefined,
      // @option maxZoom: Number = *
      // Maximum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the highest of their `maxZoom` options will be used instead.
      maxZoom: undefined,
      // @option layers: Layer[] = []
      // Array of layers that will be added to the map initially
      layers: [],
      // @option maxBounds: LatLngBounds = null
      // When this option is set, the map restricts the view to the given
      // geographical bounds, bouncing the user back if the user tries to pan
      // outside the view. To set the restriction dynamically, use
      // [`setMaxBounds`](#map-setmaxbounds) method.
      maxBounds: undefined,
      // @option renderer: Renderer = *
      // The default method for drawing vector layers on the map. `L.SVG`
      // or `L.Canvas` by default depending on browser support.
      renderer: undefined,
      // @section Animation Options
      // @option zoomAnimation: Boolean = true
      // Whether the map zoom animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      zoomAnimation: true,
      // @option zoomAnimationThreshold: Number = 4
      // Won't animate zoom if the zoom difference exceeds this value.
      zoomAnimationThreshold: 4,
      // @option fadeAnimation: Boolean = true
      // Whether the tile fade animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      fadeAnimation: true,
      // @option markerZoomAnimation: Boolean = true
      // Whether markers animate their zoom with the zoom animation, if disabled
      // they will disappear for the length of the animation. By default it's
      // enabled in all browsers that support CSS3 Transitions except Android.
      markerZoomAnimation: true,
      // @option transform3DLimit: Number = 2^23
      // Defines the maximum size of a CSS translation transform. The default
      // value should not be changed unless a web browser positions layers in
      // the wrong place after doing a large `panBy`.
      transform3DLimit: 8388608,
      // Precision limit of a 32-bit float
      // @section Interaction Options
      // @option zoomSnap: Number = 1
      // Forces the map's zoom level to always be a multiple of this, particularly
      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
      // By default, the zoom level snaps to the nearest integer; lower values
      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
      zoomSnap: 1,
      // @option zoomDelta: Number = 1
      // Controls how much the map's zoom level will change after a
      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
      zoomDelta: 1,
      // @option trackResize: Boolean = true
      // Whether the map automatically handles browser window resize to update itself.
      trackResize: true
    },
    initialize: function (id, options) {
      // (HTMLElement or String, Object)
      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,
      // to avoid inconsistent state in some edge cases.

      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = true;

      this._initContainer(id);

      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980


      this._onResize = bind(this._onResize, this);

      this._initEvents();

      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }

      if (options.zoom !== undefined) {
        this._zoom = this._limitZoom(options.zoom);
      }

      if (options.center && options.zoom !== undefined) {
        this.setView(toLatLng(options.center), options.zoom, {
          reset: true
        });
      }

      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera

      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events
      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally

      if (this._zoomAnimated) {
        this._createAnimProxy();

        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }

      this._addLayers(this.options.layers);
    },
    // @section Methods for modifying map state
    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) with the given
    // animation options.
    setView: function (center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
      options = options || {};

      this._stop();

      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = extend({
            animate: options.animate
          }, options.zoom);
          options.pan = extend({
            animate: options.animate,
            duration: options.duration
          }, options.pan);
        } // try animating pan or zoom


        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

        if (moved) {
          // prevent resize handler call, the view will refresh after animation anyway
          clearTimeout(this._sizeTimer);
          return this;
        }
      } // animation didn't start, just reset the map view


      this._resetView(center, zoom);

      return this;
    },
    // @method setZoom(zoom: Number, options?: Zoom/pan options): this
    // Sets the zoom of the map.
    setZoom: function (zoom, options) {
      if (!this._loaded) {
        this._zoom = zoom;
        return this;
      }

      return this.setView(this.getCenter(), zoom, {
        zoom: options
      });
    },
    // @method zoomIn(delta?: Number, options?: Zoom options): this
    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomIn: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    },
    // @method zoomOut(delta?: Number, options?: Zoom options): this
    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomOut: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    },
    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified geographical point on the map
    // stationary (e.g. used internally for scroll zoom and double-click zoom).
    // @alternative
    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
    setZoomAround: function (latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
          viewHalf = this.getSize().divideBy(2),
          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {
        zoom: options
      });
    },
    _getBoundsCenterZoom: function (bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

      if (zoom === Infinity) {
        return {
          center: bounds.getCenter(),
          zoom: zoom
        };
      }

      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
          swPoint = this.project(bounds.getSouthWest(), zoom),
          nePoint = this.project(bounds.getNorthEast(), zoom),
          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
      return {
        center: center,
        zoom: zoom
      };
    },
    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets a map view that contains the given geographical bounds with the
    // maximum zoom level possible.
    fitBounds: function (bounds, options) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        throw new Error('Bounds are not valid.');
      }

      var target = this._getBoundsCenterZoom(bounds, options);

      return this.setView(target.center, target.zoom, options);
    },
    // @method fitWorld(options?: fitBounds options): this
    // Sets a map view that mostly contains the whole world with the maximum
    // zoom level possible.
    fitWorld: function (options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    },
    // @method panTo(latlng: LatLng, options?: Pan options): this
    // Pans the map to a given center.
    panTo: function (center, options) {
      // (LatLng)
      return this.setView(center, this._zoom, {
        pan: options
      });
    },
    // @method panBy(offset: Point, options?: Pan options): this
    // Pans the map by a given number of pixels (animated).
    panBy: function (offset, options) {
      offset = toPoint(offset).round();
      options = options || {};

      if (!offset.x && !offset.y) {
        return this.fire('moveend');
      } // If we pan too far, Chrome gets issues with tiles
      // and makes them disappear or appear in the wrong place (slightly offset) #2602


      if (options.animate !== true && !this.getSize().contains(offset)) {
        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());

        return this;
      }

      if (!this._panAnim) {
        this._panAnim = new PosAnimation();

        this._panAnim.on({
          'step': this._onPanTransitionStep,
          'end': this._onPanTransitionEnd
        }, this);
      } // don't fire movestart if animating inertia


      if (!options.noMoveStart) {
        this.fire('movestart');
      } // animate pan unless animate: false specified


      if (options.animate !== false) {
        addClass(this._mapPane, 'leaflet-pan-anim');

        var newPos = this._getMapPanePos().subtract(offset).round();

        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
      } else {
        this._rawPanBy(offset);

        this.fire('move').fire('moveend');
      }

      return this;
    },
    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) performing a smooth
    // pan-zoom animation.
    flyTo: function (targetCenter, targetZoom, options) {
      options = options || {};

      if (options.animate === false || !any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }

      this._stop();

      var from = this.project(this.getCenter()),
          to = this.project(targetCenter),
          size = this.getSize(),
          startZoom = this._zoom;
      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === undefined ? startZoom : targetZoom;
      var w0 = Math.max(size.x, size.y),
          w1 = w0 * this.getZoomScale(startZoom, targetZoom),
          u1 = to.distanceTo(from) || 1,
          rho = 1.42,
          rho2 = rho * rho;

      function r(i) {
        var s1 = i ? -1 : 1,
            s2 = i ? w1 : w0,
            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
            b1 = 2 * s2 * rho2 * u1,
            b = t1 / b1,
            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,
        // thus triggering an infinite loop in flyTo

        var log = sq < 0.000000001 ? -18 : Math.log(sq);
        return log;
      }

      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }

      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }

      function tanh(n) {
        return sinh(n) / cosh(n);
      }

      var r0 = r(0);

      function w(s) {
        return w0 * (cosh(r0) / cosh(r0 + rho * s));
      }

      function u(s) {
        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
      }

      function easeOut(t) {
        return 1 - Math.pow(1 - t, 1.5);
      }

      var start = Date.now(),
          S = (r(1) - r0) / rho,
          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

      function frame() {
        var t = (Date.now() - start) / duration,
            s = easeOut(t) * S;

        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);

          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
            flyTo: true
          });
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(true);
        }
      }

      this._moveStart(true, options.noMoveStart);

      frame.call(this);
      return this;
    },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    flyToBounds: function (bounds, options) {
      var target = this._getBoundsCenterZoom(bounds, options);

      return this.flyTo(target.center, target.zoom, options);
    },
    // @method setMaxBounds(bounds: LatLngBounds): this
    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
    setMaxBounds: function (bounds) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        this.options.maxBounds = null;
        return this.off('moveend', this._panInsideMaxBounds);
      } else if (this.options.maxBounds) {
        this.off('moveend', this._panInsideMaxBounds);
      }

      this.options.maxBounds = bounds;

      if (this._loaded) {
        this._panInsideMaxBounds();
      }

      return this.on('moveend', this._panInsideMaxBounds);
    },
    // @method setMinZoom(zoom: Number): this
    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
    setMinZoom: function (zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method setMaxZoom(zoom: Number): this
    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
    setMaxZoom: function (zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
    panInsideBounds: function (bounds, options) {
      this._enforcingBounds = true;

      var center = this.getCenter(),
          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

      if (!center.equals(newCenter)) {
        this.panTo(newCenter, options);
      }

      this._enforcingBounds = false;
      return this;
    },
    // @method panInside(latlng: LatLng, options?: options): this
    // Pans the map the minimum amount to make the `latlng` visible. Use
    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
    // If `latlng` is already within the (optionally padded) display bounds,
    // the map will not be panned.
    panInside: function (latlng, options) {
      options = options || {};
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          center = this.getCenter(),
          pixelCenter = this.project(center),
          pixelPoint = this.project(latlng),
          pixelBounds = this.getPixelBounds(),
          halfPixelBounds = pixelBounds.getSize().divideBy(2),
          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        var diff = pixelCenter.subtract(pixelPoint),
            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
          newCenter.x = pixelCenter.x - diff.x;

          if (diff.x > 0) {
            newCenter.x += halfPixelBounds.x - paddingTL.x;
          } else {
            newCenter.x -= halfPixelBounds.x - paddingBR.x;
          }
        }

        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
          newCenter.y = pixelCenter.y - diff.y;

          if (diff.y > 0) {
            newCenter.y += halfPixelBounds.y - paddingTL.y;
          } else {
            newCenter.y -= halfPixelBounds.y - paddingBR.y;
          }
        }

        this.panTo(this.unproject(newCenter), options);
        this._enforcingBounds = false;
      }

      return this;
    },
    // @method invalidateSize(options: Zoom/pan options): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default. If `options.pan` is `false`, panning will not occur.
    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
    // that it doesn't happen often even if the method is called many
    // times in a row.
    // @alternative
    // @method invalidateSize(animate: Boolean): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default.
    invalidateSize: function (options) {
      if (!this._loaded) {
        return this;
      }

      options = extend({
        animate: false,
        pan: true
      }, options === true ? {
        animate: true
      } : options);
      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._lastCenter = null;
      var newSize = this.getSize(),
          oldCenter = oldSize.divideBy(2).round(),
          newCenter = newSize.divideBy(2).round(),
          offset = oldCenter.subtract(newCenter);

      if (!offset.x && !offset.y) {
        return this;
      }

      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }

        this.fire('move');

        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
        } else {
          this.fire('moveend');
        }
      } // @section Map state change events
      // @event resize: ResizeEvent
      // Fired when the map is resized.


      return this.fire('resize', {
        oldSize: oldSize,
        newSize: newSize
      });
    },
    // @section Methods for modifying map state
    // @method stop(): this
    // Stops the currently running `panTo` or `flyTo` animation, if any.
    stop: function () {
      this.setZoom(this._limitZoom(this._zoom));

      if (!this.options.zoomSnap) {
        this.fire('viewreset');
      }

      return this._stop();
    },
    // @section Geolocation methods
    // @method locate(options?: Locate options): this
    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
    // and optionally sets the map view to the user's location with respect to
    // detection accuracy (or to the world view if geolocation failed).
    // Note that, if your page doesn't use HTTPS, this method will fail in
    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
    // See `Locate options` for more details.
    locate: function (options) {
      options = this._locateOptions = extend({
        timeout: 10000,
        watch: false // setView: false
        // maxZoom: <Number>
        // maximumAge: 0
        // enableHighAccuracy: false

      }, options);

      if (!('geolocation' in navigator)) {
        this._handleGeolocationError({
          code: 0,
          message: 'Geolocation not supported.'
        });

        return this;
      }

      var onResponse = bind(this._handleGeolocationResponse, this),
          onError = bind(this._handleGeolocationError, this);

      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }

      return this;
    },
    // @method stopLocate(): this
    // Stops watching location previously initiated by `map.locate({watch: true})`
    // and aborts resetting the map view if map.locate was called with
    // `{setView: true}`.
    stopLocate: function () {
      if (navigator.geolocation && navigator.geolocation.clearWatch) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }

      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }

      return this;
    },
    _handleGeolocationError: function (error) {
      var c = error.code,
          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      } // @section Location events
      // @event locationerror: ErrorEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.


      this.fire('locationerror', {
        code: c,
        message: 'Geolocation error: ' + message + '.'
      });
    },
    _handleGeolocationResponse: function (pos) {
      var lat = pos.coords.latitude,
          lng = pos.coords.longitude,
          latlng = new LatLng(lat, lng),
          bounds = latlng.toBounds(pos.coords.accuracy * 2),
          options = this._locateOptions;

      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
      }

      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp
      };

      for (var i in pos.coords) {
        if (typeof pos.coords[i] === 'number') {
          data[i] = pos.coords[i];
        }
      } // @event locationfound: LocationEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method)
      // went successfully.


      this.fire('locationfound', data);
    },
    // TODO Appropriate docs section?
    // @section Other Methods
    // @method addHandler(name: String, HandlerClass: Function): this
    // Adds a new `Handler` to the map, given its name and constructor function.
    addHandler: function (name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }

      var handler = this[name] = new HandlerClass(this);

      this._handlers.push(handler);

      if (this.options[name]) {
        handler.enable();
      }

      return this;
    },
    // @method remove(): this
    // Destroys the map and clears all related event listeners.
    remove: function () {
      this._initEvents(true);

      this.off('moveend', this._panInsideMaxBounds);

      if (this._containerId !== this._container._leaflet_id) {
        throw new Error('Map container is being reused by another instance');
      }

      try {
        // throws error in IE6-8
        delete this._container._leaflet_id;
        delete this._containerId;
      } catch (e) {
        /*eslint-disable */
        this._container._leaflet_id = undefined;
        /* eslint-enable */

        this._containerId = undefined;
      }

      if (this._locationWatchId !== undefined) {
        this.stopLocate();
      }

      this._stop();

      remove(this._mapPane);

      if (this._clearControlPos) {
        this._clearControlPos();
      }

      if (this._resizeRequest) {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = null;
      }

      this._clearHandlers();

      if (this._loaded) {
        // @section Map state change events
        // @event unload: Event
        // Fired when the map is destroyed with [remove](#map-remove) method.
        this.fire('unload');
      }

      var i;

      for (i in this._layers) {
        this._layers[i].remove();
      }

      for (i in this._panes) {
        remove(this._panes[i]);
      }

      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;
      return this;
    },
    // @section Other Methods
    // @method createPane(name: String, container?: HTMLElement): HTMLElement
    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
    // then returns it. The pane is created as a child of `container`, or
    // as a child of the main map pane if not set.
    createPane: function (name, container) {
      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
          pane = create$1('div', className, container || this._mapPane);

      if (name) {
        this._panes[name] = pane;
      }

      return pane;
    },
    // @section Methods for Getting Map State
    // @method getCenter(): LatLng
    // Returns the geographical center of the map view
    getCenter: function () {
      this._checkIfLoaded();

      if (this._lastCenter && !this._moved()) {
        return this._lastCenter;
      }

      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },
    // @method getZoom(): Number
    // Returns the current zoom level of the map view
    getZoom: function () {
      return this._zoom;
    },
    // @method getBounds(): LatLngBounds
    // Returns the geographical bounds visible in the current map view
    getBounds: function () {
      var bounds = this.getPixelBounds(),
          sw = this.unproject(bounds.getBottomLeft()),
          ne = this.unproject(bounds.getTopRight());
      return new LatLngBounds(sw, ne);
    },
    // @method getMinZoom(): Number
    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
    getMinZoom: function () {
      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
    },
    // @method getMaxZoom(): Number
    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
    getMaxZoom: function () {
      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
    },
    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
    // Returns the maximum zoom level on which the given bounds fit to the map
    // view in its entirety. If `inside` (optional) is set to `true`, the method
    // instead returns the minimum zoom level on which the map view fits into
    // the given bounds in its entirety.
    getBoundsZoom: function (bounds, inside, padding) {
      // (LatLngBounds[, Boolean, Point]) -> Number
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);
      var zoom = this.getZoom() || 0,
          min = this.getMinZoom(),
          max = this.getMaxZoom(),
          nw = bounds.getNorthWest(),
          se = bounds.getSouthEast(),
          size = this.getSize().subtract(padding),
          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
          snap = any3d ? this.options.zoomSnap : 1,
          scalex = size.x / boundsSize.x,
          scaley = size.y / boundsSize.y,
          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
      zoom = this.getScaleZoom(scale, zoom);

      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level

        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    // @method getSize(): Point
    // Returns the current size of the map container (in pixels).
    getSize: function () {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
        this._sizeChanged = false;
      }

      return this._size.clone();
    },
    // @method getPixelBounds(): Bounds
    // Returns the bounds of the current map view in projected pixel
    // coordinates (sometimes useful in layer and overlay implementations).
    getPixelBounds: function (center, zoom) {
      var topLeftPoint = this._getTopLeftPoint(center, zoom);

      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },
    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
    // the map pane? "left point of the map layer" can be confusing, specially
    // since there can be negative offsets.
    // @method getPixelOrigin(): Point
    // Returns the projected pixel coordinates of the top left point of
    // the map layer (useful in custom layer and overlay implementations).
    getPixelOrigin: function () {
      this._checkIfLoaded();

      return this._pixelOrigin;
    },
    // @method getPixelWorldBounds(zoom?: Number): Bounds
    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
    // If `zoom` is omitted, the map's current zoom level is used.
    getPixelWorldBounds: function (zoom) {
      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
    },
    // @section Other Methods
    // @method getPane(pane: String|HTMLElement): HTMLElement
    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
    getPane: function (pane) {
      return typeof pane === 'string' ? this._panes[pane] : pane;
    },
    // @method getPanes(): Object
    // Returns a plain object containing the names of all [panes](#map-pane) as keys and
    // the panes as values.
    getPanes: function () {
      return this._panes;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the map.
    getContainer: function () {
      return this._container;
    },
    // @section Conversion Methods
    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
    // Returns the scale factor to be applied to a map transition from zoom level
    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
    getZoomScale: function (toZoom, fromZoom) {
      // TODO replace with universal implementation after refactoring projections
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    },
    // @method getScaleZoom(scale: Number, fromZoom: Number): Number
    // Returns the zoom level that the map would end up at, if it is at `fromZoom`
    // level and everything is scaled by a factor of `scale`. Inverse of
    // [`getZoomScale`](#map-getZoomScale).
    getScaleZoom: function (scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      var zoom = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    },
    // @method project(latlng: LatLng, zoom: Number): Point
    // Projects a geographical coordinate `LatLng` according to the projection
    // of the map's CRS, then scales it according to `zoom` and the CRS's
    // `Transformation`. The result is pixel coordinate relative to
    // the CRS origin.
    project: function (latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    },
    // @method unproject(point: Point, zoom: Number): LatLng
    // Inverse of [`project`](#map-project).
    unproject: function (point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    },
    // @method layerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding geographical coordinate (for the current zoom level).
    layerPointToLatLng: function (point) {
      var projectedPoint = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },
    // @method latLngToLayerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the [origin pixel](#map-getpixelorigin).
    latLngToLayerPoint: function (latlng) {
      var projectedPoint = this.project(toLatLng(latlng))._round();

      return projectedPoint._subtract(this.getPixelOrigin());
    },
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
    // CRS's bounds.
    // By default this means longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees.
    wrapLatLng: function (latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring that
    // its center is within the CRS's bounds.
    // By default this means the center longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees, and the majority of the bounds
    // overlaps the CRS's bounds.
    wrapLatLngBounds: function (latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates according to
    // the map's CRS. By default this measures distance in meters.
    distance: function (latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    },
    // @method containerPointToLayerPoint(point: Point): Point
    // Given a pixel coordinate relative to the map container, returns the corresponding
    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
    containerPointToLayerPoint: function (point) {
      // (Point)
      return toPoint(point).subtract(this._getMapPanePos());
    },
    // @method layerPointToContainerPoint(point: Point): Point
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding pixel coordinate relative to the map container.
    layerPointToContainerPoint: function (point) {
      // (Point)
      return toPoint(point).add(this._getMapPanePos());
    },
    // @method containerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the map container, returns
    // the corresponding geographical coordinate (for the current zoom level).
    containerPointToLatLng: function (point) {
      var layerPoint = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(layerPoint);
    },
    // @method latLngToContainerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the map container.
    latLngToContainerPoint: function (latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    },
    // @method mouseEventToContainerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to the
    // map container where the event took place.
    mouseEventToContainerPoint: function (e) {
      return getMousePosition(e, this._container);
    },
    // @method mouseEventToLayerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to
    // the [origin pixel](#map-getpixelorigin) where the event took place.
    mouseEventToLayerPoint: function (e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    },
    // @method mouseEventToLatLng(ev: MouseEvent): LatLng
    // Given a MouseEvent object, returns geographical coordinate where the
    // event took place.
    mouseEventToLatLng: function (e) {
      // (MouseEvent)
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },
    // map initialization methods
    _initContainer: function (id) {
      var container = this._container = get(id);

      if (!container) {
        throw new Error('Map container not found.');
      } else if (container._leaflet_id) {
        throw new Error('Map container is already initialized.');
      }

      on(container, 'scroll', this._onScroll, this);
      this._containerId = stamp(container);
    },
    _initLayout: function () {
      var container = this._container;
      this._fadeAnimated = this.options.fadeAnimation && any3d;
      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));
      var position = getStyle(container, 'position');

      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        container.style.position = 'relative';
      }

      this._initPanes();

      if (this._initControlPos) {
        this._initControlPos();
      }
    },
    _initPanes: function () {
      var panes = this._panes = {};
      this._paneRenderers = {}; // @section
      //
      // Panes are DOM elements used to control the ordering of layers on the map. You
      // can access panes with [`map.getPane`](#map-getpane) or
      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
      // [`map.createPane`](#map-createpane) method.
      //
      // Every map has the following default panes that differ only in zIndex.
      //
      // @pane mapPane: HTMLElement = 'auto'
      // Pane that contains all other map panes

      this._mapPane = this.createPane('mapPane', this._container);
      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200
      // Pane for `GridLayer`s and `TileLayer`s

      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400
      // Pane for overlay shadows (e.g. `Marker` shadows)

      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500
      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s

      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600
      // Pane for `Icon`s of `Marker`s

      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650
      // Pane for `Tooltip`s.

      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700
      // Pane for `Popup`s.

      this.createPane('popupPane');

      if (!this.options.markerZoomAnimation) {
        addClass(panes.markerPane, 'leaflet-zoom-hide');
        addClass(panes.shadowPane, 'leaflet-zoom-hide');
      }
    },
    // private methods that modify map state
    // @section Map state change events
    _resetView: function (center, zoom) {
      setPosition(this._mapPane, new Point(0, 0));
      var loading = !this._loaded;
      this._loaded = true;
      zoom = this._limitZoom(zoom);
      this.fire('viewprereset');
      var zoomChanged = this._zoom !== zoom;

      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event
      // Fired when the map needs to redraw its content (this usually happens
      // on map zoom or load). Very useful for creating custom overlays.


      this.fire('viewreset'); // @event load: Event
      // Fired when the map is initialized (when its center and zoom are set
      // for the first time).

      if (loading) {
        this.fire('load');
      }
    },
    _moveStart: function (zoomChanged, noMoveStart) {
      // @event zoomstart: Event
      // Fired when the map zoom is about to change (e.g. before zoom animation).
      // @event movestart: Event
      // Fired when the view of the map starts changing (e.g. user starts dragging the map).
      if (zoomChanged) {
        this.fire('zoomstart');
      }

      if (!noMoveStart) {
        this.fire('movestart');
      }

      return this;
    },
    _move: function (center, zoom, data) {
      if (zoom === undefined) {
        zoom = this._zoom;
      }

      var zoomChanged = this._zoom !== zoom;
      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event
      // Fired repeatedly during any change in zoom level, including zoom
      // and fly animations.

      if (zoomChanged || data && data.pinch) {
        // Always fire 'zoom' if pinching because #3530
        this.fire('zoom', data);
      } // @event move: Event
      // Fired repeatedly during any movement of the map, including pan and
      // fly animations.


      return this.fire('move', data);
    },
    _moveEnd: function (zoomChanged) {
      // @event zoomend: Event
      // Fired when the map has changed, after any animations.
      if (zoomChanged) {
        this.fire('zoomend');
      } // @event moveend: Event
      // Fired when the center of the map stops changing (e.g. user stopped
      // dragging the map).


      return this.fire('moveend');
    },
    _stop: function () {
      cancelAnimFrame(this._flyToFrame);

      if (this._panAnim) {
        this._panAnim.stop();
      }

      return this;
    },
    _rawPanBy: function (offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },
    _getZoomSpan: function () {
      return this.getMaxZoom() - this.getMinZoom();
    },
    _panInsideMaxBounds: function () {
      if (!this._enforcingBounds) {
        this.panInsideBounds(this.options.maxBounds);
      }
    },
    _checkIfLoaded: function () {
      if (!this._loaded) {
        throw new Error('Set map center and zoom first.');
      }
    },
    // DOM event handling
    // @section Interaction events
    _initEvents: function (remove$$1) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;
      var onOff = remove$$1 ? off : on; // @event click: MouseEvent
      // Fired when the user clicks (or taps) the map.
      // @event dblclick: MouseEvent
      // Fired when the user double-clicks (or double-taps) the map.
      // @event mousedown: MouseEvent
      // Fired when the user pushes the mouse button on the map.
      // @event mouseup: MouseEvent
      // Fired when the user releases the mouse button on the map.
      // @event mouseover: MouseEvent
      // Fired when the mouse enters the map.
      // @event mouseout: MouseEvent
      // Fired when the mouse leaves the map.
      // @event mousemove: MouseEvent
      // Fired while the mouse moves over the map.
      // @event contextmenu: MouseEvent
      // Fired when the user pushes the right mouse button on the map, prevents
      // default browser context menu from showing if there are listeners on
      // this event. Also fired on mobile when the user holds a single touch
      // for a second (also called long press).
      // @event keypress: KeyboardEvent
      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
      // @event keydown: KeyboardEvent
      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
      // the `keydown` event is fired for keys that produce a character value and for keys
      // that do not produce a character value.
      // @event keyup: KeyboardEvent
      // Fired when the user releases a key from the keyboard while the map is focused.

      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

      if (this.options.trackResize) {
        onOff(window, 'resize', this._onResize, this);
      }

      if (any3d && this.options.transform3DLimit) {
        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
      }
    },
    _onResize: function () {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function () {
        this.invalidateSize({
          debounceMoveend: true
        });
      }, this);
    },
    _onScroll: function () {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    },
    _onMoveEnd: function () {
      var pos = this._getMapPanePos();

      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
        this._resetView(this.getCenter(), this.getZoom());
      }
    },
    _findEventTargets: function (e, type) {
      var targets = [],
          target,
          isHover = type === 'mouseout' || type === 'mouseover',
          src = e.target || e.srcElement,
          dragging = false;

      while (src) {
        target = this._targets[stamp(src)];

        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
          // Prevent firing click after you just dragged an object.
          dragging = true;
          break;
        }

        if (target && target.listens(type, true)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }

          targets.push(target);

          if (isHover) {
            break;
          }
        }

        if (src === this._container) {
          break;
        }

        src = src.parentNode;
      }

      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
        targets = [this];
      }

      return targets;
    },
    _handleDOMEvent: function (e) {
      if (!this._loaded || skipped(e)) {
        return;
      }

      var type = e.type;

      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
        // prevents outline when clicking on keyboard-focusable element
        preventOutline(e.target || e.srcElement);
      }

      this._fireDOMEvent(e, type);
    },
    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
    _fireDOMEvent: function (e, type, targets) {
      if (e.type === 'click') {
        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
        // @event preclick: MouseEvent
        // Fired before mouse click on the map (sometimes useful when you
        // want something to happen on click before any existing click
        // handlers start running).
        var synth = extend({}, e);
        synth.type = 'preclick';

        this._fireDOMEvent(synth, synth.type, targets);
      }

      if (e._stopped) {
        return;
      } // Find the layer the event is propagating from and its parents.


      targets = (targets || []).concat(this._findEventTargets(e, type));

      if (!targets.length) {
        return;
      }

      var target = targets[0];

      if (type === 'contextmenu' && target.listens(type, true)) {
        preventDefault(e);
      }

      var data = {
        originalEvent: e
      };

      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
      }

      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(type, data, true);

        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
          return;
        }
      }
    },
    _draggableMoved: function (obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
    },
    _clearHandlers: function () {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },
    // @section Other Methods
    // @method whenReady(fn: Function, context?: Object): this
    // Runs the given function `fn` when the map gets initialized with
    // a view (center and zoom) and at least one layer, or immediately
    // if it's already initialized, optionally passing a function context.
    whenReady: function (callback, context) {
      if (this._loaded) {
        callback.call(context || this, {
          target: this
        });
      } else {
        this.on('load', callback, context);
      }

      return this;
    },
    // private methods for getting map state
    _getMapPanePos: function () {
      return getPosition(this._mapPane) || new Point(0, 0);
    },
    _moved: function () {
      var pos = this._getMapPanePos();

      return pos && !pos.equals([0, 0]);
    },
    _getTopLeftPoint: function (center, zoom) {
      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
      return pixelOrigin.subtract(this._getMapPanePos());
    },
    _getNewPixelOrigin: function (center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);

      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
    },
    _latLngToNewLayerPoint: function (latlng, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return this.project(latlng, zoom)._subtract(topLeft);
    },
    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
    },
    // layer point of the current center
    _getCenterLayerPoint: function () {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },
    // offset of the specified place to the current center in pixels
    _getCenterOffset: function (latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    },
    // adjust center for view to get inside bounds
    _limitCenter: function (center, zoom, bounds) {
      if (!bounds) {
        return center;
      }

      var centerPoint = this.project(center, zoom),
          viewHalf = this.getSize().divideBy(2),
          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.
      // This prevents unstable projections from getting into
      // an infinite loop of tiny offsets.


      if (offset.round().equals([0, 0])) {
        return center;
      }

      return this.unproject(centerPoint.add(offset), zoom);
    },
    // adjust offset for view to get inside bounds
    _limitOffset: function (offset, bounds) {
      if (!bounds) {
        return offset;
      }

      var viewBounds = this.getPixelBounds(),
          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },
    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
          dx = this._rebound(minOffset.x, -maxOffset.x),
          dy = this._rebound(minOffset.y, -maxOffset.y);

      return new Point(dx, dy);
    },
    _rebound: function (left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },
    _limitZoom: function (zoom) {
      var min = this.getMinZoom(),
          max = this.getMaxZoom(),
          snap = any3d ? this.options.zoomSnap : 1;

      if (snap) {
        zoom = Math.round(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    _onPanTransitionStep: function () {
      this.fire('move');
    },
    _onPanTransitionEnd: function () {
      removeClass(this._mapPane, 'leaflet-pan-anim');
      this.fire('moveend');
    },
    _tryAnimatedPan: function (center, options) {
      // difference between the new and current centers in pixels
      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options


      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
        return false;
      }

      this.panBy(offset, options);
      return true;
    },
    _createAnimProxy: function () {
      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');

      this._panes.mapPane.appendChild(proxy);

      this.on('zoomanim', function (e) {
        var prop = TRANSFORM,
            transform = this._proxy.style[prop];
        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired

        if (transform === this._proxy.style[prop] && this._animatingZoom) {
          this._onZoomTransitionEnd();
        }
      }, this);
      this.on('load moveend', this._animMoveEnd, this);

      this._on('unload', this._destroyAnimProxy, this);
    },
    _destroyAnimProxy: function () {
      remove(this._proxy);
      this.off('load moveend', this._animMoveEnd, this);
      delete this._proxy;
    },
    _animMoveEnd: function () {
      var c = this.getCenter(),
          z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    },
    _catchTransitionEnd: function (e) {
      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
        this._onZoomTransitionEnd();
      }
    },
    _nothingToAnimate: function () {
      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
    },
    _tryAnimatedZoom: function (center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }

      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large

      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return false;
      } // offset is the pixel coords of the zoom origin relative to the current center


      var scale = this.getZoomScale(zoom),
          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced


      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }

      requestAnimFrame(function () {
        this._moveStart(true, false)._animateZoom(center, zoom, true);
      }, this);
      return true;
    },
    _animateZoom: function (center, zoom, startAnim, noUpdate) {
      if (!this._mapPane) {
        return;
      }

      if (startAnim) {
        this._animatingZoom = true; // remember what center/zoom to set after animation

        this._animateToCenter = center;
        this._animateToZoom = zoom;
        addClass(this._mapPane, 'leaflet-zoom-anim');
      } // @section Other Events
      // @event zoomanim: ZoomAnimEvent
      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.


      this.fire('zoomanim', {
        center: center,
        zoom: zoom,
        noUpdate: noUpdate
      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693

      setTimeout(bind(this._onZoomTransitionEnd, this), 250);
    },
    _onZoomTransitionEnd: function () {
      if (!this._animatingZoom) {
        return;
      }

      if (this._mapPane) {
        removeClass(this._mapPane, 'leaflet-zoom-anim');
      }

      this._animatingZoom = false;

      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.


      requestAnimFrame(function () {
        this._moveEnd(true);
      }, this);
    }
  }); // @section
  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.

  function createMap(id, options) {
    return new Map(id, options);
  }
  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */


  var Control = Class.extend({
    // @section
    // @aka Control options
    options: {
      // @option position: String = 'topright'
      // The position of the control (one of the map corners). Possible values are `'topleft'`,
      // `'topright'`, `'bottomleft'` or `'bottomright'`
      position: 'topright'
    },
    initialize: function (options) {
      setOptions(this, options);
    },

    /* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
    getPosition: function () {
      return this.options.position;
    },
    // @method setPosition(position: string): this
    // Sets the position of the control.
    setPosition: function (position) {
      var map = this._map;

      if (map) {
        map.removeControl(this);
      }

      this.options.position = position;

      if (map) {
        map.addControl(this);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTMLElement that contains the control.
    getContainer: function () {
      return this._container;
    },
    // @method addTo(map: Map): this
    // Adds the control to the given map.
    addTo: function (map) {
      this.remove();
      this._map = map;
      var container = this._container = this.onAdd(map),
          pos = this.getPosition(),
          corner = map._controlCorners[pos];
      addClass(container, 'leaflet-control');

      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }

      this._map.on('unload', this.remove, this);

      return this;
    },
    // @method remove: this
    // Removes the control from the map it is currently active on.
    remove: function () {
      if (!this._map) {
        return this;
      }

      remove(this._container);

      if (this.onRemove) {
        this.onRemove(this._map);
      }

      this._map.off('unload', this.remove, this);

      this._map = null;
      return this;
    },
    _refocusOnMap: function (e) {
      // if map exists and event is not a keyboard event
      if (this._map && e && e.screenX > 0 && e.screenY > 0) {
        this._map.getContainer().focus();
      }
    }
  });

  var control = function (options) {
    return new Control(options);
  };
  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */


  Map.include({
    // @method addControl(control: Control): this
    // Adds the given control to the map
    addControl: function (control) {
      control.addTo(this);
      return this;
    },
    // @method removeControl(control: Control): this
    // Removes the given control from the map
    removeControl: function (control) {
      control.remove();
      return this;
    },
    _initControlPos: function () {
      var corners = this._controlCorners = {},
          l = 'leaflet-',
          container = this._controlContainer = create$1('div', l + 'control-container', this._container);

      function createCorner(vSide, hSide) {
        var className = l + vSide + ' ' + l + hSide;
        corners[vSide + hSide] = create$1('div', className, container);
      }

      createCorner('top', 'left');
      createCorner('top', 'right');
      createCorner('bottom', 'left');
      createCorner('bottom', 'right');
    },
    _clearControlPos: function () {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }

      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    }
  });
  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
      // @option collapsed: Boolean = true
      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
      collapsed: true,
      position: 'topright',
      // @option autoZIndex: Boolean = true
      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
      autoZIndex: true,
      // @option hideSingleBase: Boolean = false
      // If `true`, the base layers in the control will be hidden when there is only one.
      hideSingleBase: false,
      // @option sortLayers: Boolean = false
      // Whether to sort the layers. When `false`, layers will keep the order
      // in which they were added to the control.
      sortLayers: false,
      // @option sortFunction: Function = *
      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
      // that will be used for sorting the layers, when `sortLayers` is `true`.
      // The function receives both the `L.Layer` instances and their names, as in
      // `sortFunction(layerA, layerB, nameA, nameB)`.
      // By default, it sorts layers alphabetically by their name.
      sortFunction: function (layerA, layerB, nameA, nameB) {
        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
      }
    },
    initialize: function (baseLayers, overlays, options) {
      setOptions(this, options);
      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._handlingClick = false;

      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }

      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },
    onAdd: function (map) {
      this._initLayout();

      this._update();

      this._map = map;
      map.on('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.on('add remove', this._onLayerChange, this);
      }

      return this._container;
    },
    addTo: function (map) {
      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.

      return this._expandIfNotCollapsed();
    },
    onRemove: function () {
      this._map.off('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off('add remove', this._onLayerChange, this);
      }
    },
    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
      this._addLayer(layer, name);

      return this._map ? this._update() : this;
    },
    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
      this._addLayer(layer, name, true);

      return this._map ? this._update() : this;
    },
    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
      layer.off('add remove', this._onLayerChange, this);

      var obj = this._getLayer(stamp(layer));

      if (obj) {
        this._layers.splice(this._layers.indexOf(obj), 1);
      }

      return this._map ? this._update() : this;
    },
    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
      addClass(this._container, 'leaflet-control-layers-expanded');
      this._section.style.height = null;
      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);

      if (acceptableHeight < this._section.clientHeight) {
        addClass(this._section, 'leaflet-control-layers-scrollbar');
        this._section.style.height = acceptableHeight + 'px';
      } else {
        removeClass(this._section, 'leaflet-control-layers-scrollbar');
      }

      this._checkDisabledLayers();

      return this;
    },
    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
      removeClass(this._container, 'leaflet-control-layers-expanded');
      return this;
    },
    _initLayout: function () {
      var className = 'leaflet-control-layers',
          container = this._container = create$1('div', className),
          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released

      container.setAttribute('aria-haspopup', true);
      disableClickPropagation(container);
      disableScrollPropagation(container);
      var section = this._section = create$1('section', className + '-list');

      if (collapsed) {
        this._map.on('click', this.collapse, this);

        if (!android) {
          on(container, {
            mouseenter: this.expand,
            mouseleave: this.collapse
          }, this);
        }
      }

      var link = this._layersLink = create$1('a', className + '-toggle', container);
      link.href = '#';
      link.title = 'Layers';

      if (touch) {
        on(link, 'click', stop);
        on(link, 'click', this.expand, this);
      } else {
        on(link, 'focus', this.expand, this);
      }

      if (!collapsed) {
        this.expand();
      }

      this._baseLayersList = create$1('div', className + '-base', section);
      this._separator = create$1('div', className + '-separator', section);
      this._overlaysList = create$1('div', className + '-overlays', section);
      container.appendChild(section);
    },
    _getLayer: function (id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    },
    _addLayer: function (layer, name, overlay) {
      if (this._map) {
        layer.on('add remove', this._onLayerChange, this);
      }

      this._layers.push({
        layer: layer,
        name: name,
        overlay: overlay
      });

      if (this.options.sortLayers) {
        this._layers.sort(bind(function (a, b) {
          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
        }, this));
      }

      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }

      this._expandIfNotCollapsed();
    },
    _update: function () {
      if (!this._container) {
        return this;
      }

      empty(this._baseLayersList);
      empty(this._overlaysList);
      this._layerControlInputs = [];
      var baseLayersPresent,
          overlaysPresent,
          i,
          obj,
          baseLayersCount = 0;

      for (i = 0; i < this._layers.length; i++) {
        obj = this._layers[i];

        this._addItem(obj);

        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      } // Hide base layers section if there's only one layer.


      if (this.options.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
      }

      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
      return this;
    },
    _onLayerChange: function (e) {
      if (!this._handlingClick) {
        this._update();
      }

      var obj = this._getLayer(stamp(e.target)); // @namespace Map
      // @section Layer events
      // @event baselayerchange: LayersControlEvent
      // Fired when the base layer is changed through the [layers control](#control-layers).
      // @event overlayadd: LayersControlEvent
      // Fired when an overlay is selected through the [layers control](#control-layers).
      // @event overlayremove: LayersControlEvent
      // Fired when an overlay is deselected through the [layers control](#control-layers).
      // @namespace Control.Layers


      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

      if (type) {
        this._map.fire(type, obj);
      }
    },
    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
    _createRadioElement: function (name, checked) {
      var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    },
    _addItem: function (obj) {
      var label = document.createElement('label'),
          checked = this._map.hasLayer(obj.layer),
          input;

      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'leaflet-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
      }

      this._layerControlInputs.push(input);

      input.layerId = stamp(obj.layer);
      on(input, 'click', this._onInputClick, this);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled
      // https://github.com/Leaflet/Leaflet/issues/2771

      var holder = document.createElement('div');
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);
      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);

      this._checkDisabledLayers();

      return label;
    },
    _onInputClick: function () {
      var inputs = this._layerControlInputs,
          input,
          layer;
      var addedLayers = [],
          removedLayers = [];
      this._handlingClick = true;

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;

        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      } // Bugfix issue 2318: Should remove all old layers before readding new ones


      for (i = 0; i < removedLayers.length; i++) {
        if (this._map.hasLayer(removedLayers[i])) {
          this._map.removeLayer(removedLayers[i]);
        }
      }

      for (i = 0; i < addedLayers.length; i++) {
        if (!this._map.hasLayer(addedLayers[i])) {
          this._map.addLayer(addedLayers[i]);
        }
      }

      this._handlingClick = false;

      this._refocusOnMap();
    },
    _checkDisabledLayers: function () {
      var inputs = this._layerControlInputs,
          input,
          layer,
          zoom = this._map.getZoom();

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
      }
    },
    _expandIfNotCollapsed: function () {
      if (this._map && !this.options.collapsed) {
        this.expand();
      }

      return this;
    },
    _expand: function () {
      // Backward compatibility, remove me in 1.1.
      return this.expand();
    },
    _collapse: function () {
      // Backward compatibility, remove me in 1.1.
      return this.collapse();
    }
  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.

  var layers = function (baseLayers, overlays, options) {
    return new Layers(baseLayers, overlays, options);
  };
  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */


  var Zoom = Control.extend({
    // @section
    // @aka Control.Zoom options
    options: {
      position: 'topleft',
      // @option zoomInText: String = '+'
      // The text set on the 'zoom in' button.
      zoomInText: '+',
      // @option zoomInTitle: String = 'Zoom in'
      // The title set on the 'zoom in' button.
      zoomInTitle: 'Zoom in',
      // @option zoomOutText: String = '&#x2212;'
      // The text set on the 'zoom out' button.
      zoomOutText: '&#x2212;',
      // @option zoomOutTitle: String = 'Zoom out'
      // The title set on the 'zoom out' button.
      zoomOutTitle: 'Zoom out'
    },
    onAdd: function (map) {
      var zoomName = 'leaflet-control-zoom',
          container = create$1('div', zoomName + ' leaflet-bar'),
          options = this.options;
      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

      this._updateDisabled();

      map.on('zoomend zoomlevelschange', this._updateDisabled, this);
      return container;
    },
    onRemove: function (map) {
      map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    disable: function () {
      this._disabled = true;

      this._updateDisabled();

      return this;
    },
    enable: function () {
      this._disabled = false;

      this._updateDisabled();

      return this;
    },
    _zoomIn: function (e) {
      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _zoomOut: function (e) {
      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _createButton: function (html, title, className, container, fn) {
      var link = create$1('a', className, container);
      link.innerHTML = html;
      link.href = '#';
      link.title = title;
      /*
       * Will force screen readers like VoiceOver to read this as "Zoom in - button"
       */

      link.setAttribute('role', 'button');
      link.setAttribute('aria-label', title);
      disableClickPropagation(link);
      on(link, 'click', stop);
      on(link, 'click', fn, this);
      on(link, 'click', this._refocusOnMap, this);
      return link;
    },
    _updateDisabled: function () {
      var map = this._map,
          className = 'leaflet-disabled';
      removeClass(this._zoomInButton, className);
      removeClass(this._zoomOutButton, className);

      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, className);
      }

      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, className);
      }
    }
  }); // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.

  Map.mergeOptions({
    zoomControl: true
  });
  Map.addInitHook(function () {
    if (this.options.zoomControl) {
      // @section Controls
      // @property zoomControl: Control.Zoom
      // The default zoom control (only available if the
      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
      this.zoomControl = new Zoom();
      this.addControl(this.zoomControl);
    }
  }); // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control

  var zoom = function (options) {
    return new Zoom(options);
  };
  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */


  var Scale = Control.extend({
    // @section
    // @aka Control.Scale options
    options: {
      position: 'bottomleft',
      // @option maxWidth: Number = 100
      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
      maxWidth: 100,
      // @option metric: Boolean = True
      // Whether to show the metric scale line (m/km).
      metric: true,
      // @option imperial: Boolean = True
      // Whether to show the imperial scale line (mi/ft).
      imperial: true // @option updateWhenIdle: Boolean = false
      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).

    },
    onAdd: function (map) {
      var className = 'leaflet-control-scale',
          container = create$1('div', className),
          options = this.options;

      this._addScales(options, className + '-line', container);

      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
      map.whenReady(this._update, this);
      return container;
    },
    onRemove: function (map) {
      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
    },
    _addScales: function (options, className, container) {
      if (options.metric) {
        this._mScale = create$1('div', className, container);
      }

      if (options.imperial) {
        this._iScale = create$1('div', className, container);
      }
    },
    _update: function () {
      var map = this._map,
          y = map.getSize().y / 2;
      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

      this._updateScales(maxMeters);
    },
    _updateScales: function (maxMeters) {
      if (this.options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }

      if (this.options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters),
          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

      this._updateScale(this._mScale, label, meters / maxMeters);
    },
    _updateImperial: function (maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
          maxMiles,
          miles,
          feet;

      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);

        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
      } else {
        feet = this._getRoundNum(maxFeet);

        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
      }
    },
    _updateScale: function (scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
      scale.innerHTML = text;
    },
    _getRoundNum: function (num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
          d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  }); // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.

  var scale = function (options) {
    return new Scale(options);
  };
  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */


  var Attribution = Control.extend({
    // @section
    // @aka Control.Attribution options
    options: {
      position: 'bottomright',
      // @option prefix: String = 'Leaflet'
      // The HTML text shown before the attributions. Pass `false` to disable.
      prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
    },
    initialize: function (options) {
      setOptions(this, options);
      this._attributions = {};
    },
    onAdd: function (map) {
      map.attributionControl = this;
      this._container = create$1('div', 'leaflet-control-attribution');
      disableClickPropagation(this._container); // TODO ugly, refactor

      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }

      this._update();

      return this._container;
    },
    // @method setPrefix(prefix: String): this
    // Sets the text before the attributions.
    setPrefix: function (prefix) {
      this.options.prefix = prefix;

      this._update();

      return this;
    },
    // @method addAttribution(text: String): this
    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
    addAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }

      this._attributions[text]++;

      this._update();

      return this;
    },
    // @method removeAttribution(text: String): this
    // Removes an attribution text.
    removeAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (this._attributions[text]) {
        this._attributions[text]--;

        this._update();
      }

      return this;
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      var attribs = [];

      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }

      var prefixAndAttribs = [];

      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }

      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(', '));
      }

      this._container.innerHTML = prefixAndAttribs.join(' | ');
    }
  }); // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.

  Map.mergeOptions({
    attributionControl: true
  });
  Map.addInitHook(function () {
    if (this.options.attributionControl) {
      new Attribution().addTo(this);
    }
  }); // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.

  var attribution = function (options) {
    return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;
  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;
  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */
  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
    initialize: function (map) {
      this._map = map;
    },
    // @method enable(): this
    // Enables the handler
    enable: function () {
      if (this._enabled) {
        return this;
      }

      this._enabled = true;
      this.addHooks();
      return this;
    },
    // @method disable(): this
    // Disables the handler
    disable: function () {
      if (!this._enabled) {
        return this;
      }

      this._enabled = false;
      this.removeHooks();
      return this;
    },
    // @method enabled(): Boolean
    // Returns `true` if the handler is enabled
    enabled: function () {
      return !!this._enabled;
    } // @section Extension methods
    // Classes inheriting from `Handler` must implement the two following methods:
    // @method addHooks()
    // Called when the handler is enabled, should add event hooks.
    // @method removeHooks()
    // Called when the handler is disabled, should remove the event hooks added previously.

  }); // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.

  Handler.addTo = function (map, name) {
    map.addHandler(name, this);
    return this;
  };

  var Mixin = {
    Events: Events
  };
  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = touch ? 'touchstart mousedown' : 'mousedown';
  var END = {
    mousedown: 'mouseup',
    touchstart: 'touchend',
    pointerdown: 'touchend',
    MSPointerDown: 'touchend'
  };
  var MOVE = {
    mousedown: 'mousemove',
    touchstart: 'touchmove',
    pointerdown: 'touchmove',
    MSPointerDown: 'touchmove'
  };
  var Draggable = Evented.extend({
    options: {
      // @section
      // @aka Draggable options
      // @option clickTolerance: Number = 3
      // The max number of pixels a user can shift the mouse pointer during a click
      // for it to be considered a valid click (as opposed to a mouse drag).
      clickTolerance: 3
    },
    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
    initialize: function (element, dragStartTarget, preventOutline$$1, options) {
      setOptions(this, options);
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline$$1;
    },
    // @method enable()
    // Enables the dragging ability
    enable: function () {
      if (this._enabled) {
        return;
      }

      on(this._dragStartTarget, START, this._onDown, this);
      this._enabled = true;
    },
    // @method disable()
    // Disables the dragging ability
    disable: function () {
      if (!this._enabled) {
        return;
      } // If we're currently dragging this draggable,
      // disabling it counts as first ending the drag.


      if (Draggable._dragging === this) {
        this.finishDrag();
      }

      off(this._dragStartTarget, START, this._onDown, this);
      this._enabled = false;
      this._moved = false;
    },
    _onDown: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this._moved = false;

      if (hasClass(this._element, 'leaflet-zoom-anim')) {
        return;
      }

      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
        return;
      }

      Draggable._dragging = this; // Prevent dragging multiple objects at once.

      if (this._preventOutline) {
        preventOutline(this._element);
      }

      disableImageDrag();
      disableTextSelection();

      if (this._moving) {
        return;
      } // @event down: Event
      // Fired when a drag is about to start.


      this.fire('down');
      var first = e.touches ? e.touches[0] : e,
          sizedParent = getSizedParentNode(this._element);
      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).

      this._parentScale = getScale(sizedParent);
      on(document, MOVE[e.type], this._onMove, this);
      on(document, END[e.type], this._onUp, this);
    },
    _onMove: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }

      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

      if (!offset.x && !offset.y) {
        return;
      }

      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
        return;
      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.
      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
      // and we can use the cached value for the scale.


      offset.x /= this._parentScale.x;
      offset.y /= this._parentScale.y;
      preventDefault(e);

      if (!this._moved) {
        // @event dragstart: Event
        // Fired when a drag starts
        this.fire('dragstart');
        this._moved = true;
        this._startPos = getPosition(this._element).subtract(offset);
        addClass(document.body, 'leaflet-dragging');
        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it
        // if necessary

        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
          this._lastTarget = this._lastTarget.correspondingUseElement;
        }

        addClass(this._lastTarget, 'leaflet-drag-target');
      }

      this._newPos = this._startPos.add(offset);
      this._moving = true;
      cancelAnimFrame(this._animRequest);
      this._lastEvent = e;
      this._animRequest = requestAnimFrame(this._updatePosition, this, true);
    },
    _updatePosition: function () {
      var e = {
        originalEvent: this._lastEvent
      }; // @event predrag: Event
      // Fired continuously during dragging *before* each corresponding
      // update of the element's position.

      this.fire('predrag', e);
      setPosition(this._element, this._newPos); // @event drag: Event
      // Fired continuously during dragging.

      this.fire('drag', e);
    },
    _onUp: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this.finishDrag();
    },
    finishDrag: function () {
      removeClass(document.body, 'leaflet-dragging');

      if (this._lastTarget) {
        removeClass(this._lastTarget, 'leaflet-drag-target');
        this._lastTarget = null;
      }

      for (var i in MOVE) {
        off(document, MOVE[i], this._onMove, this);
        off(document, END[i], this._onUp, this);
      }

      enableImageDrag();
      enableTextSelection();

      if (this._moved && this._moving) {
        // ensure drag is not fired after dragend
        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent
        // Fired when the drag ends.

        this.fire('dragend', {
          distance: this._newPos.distanceTo(this._startPos)
        });
      }

      this._moving = false;
      Draggable._dragging = false;
    }
  });
  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */
  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.
  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).

  function simplify(points, tolerance) {
    if (!tolerance || !points.length) {
      return points.slice();
    }

    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction

    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification

    points = _simplifyDP(points, sqTolerance);
    return points;
  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.


  function pointToSegmentDistance(p, p1, p2) {
    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.


  function closestPointOnSegment(p, p1, p2) {
    return _sqClosestPointOnSegment(p, p1, p2);
  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm


  function _simplifyDP(points, sqTolerance) {
    var len = points.length,
        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
        markers = new ArrayConstructor(len);
    markers[0] = markers[len - 1] = 1;

    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

    var i,
        newPoints = [];

    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }

    return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {
    var maxSqDist = 0,
        index,
        i,
        sqDist;

    for (i = first + 1; i <= last - 1; i++) {
      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }

    if (maxSqDist > sqTolerance) {
      markers[index] = 1;

      _simplifyDPStep(points, markers, sqTolerance, first, index);

      _simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  } // reduce points that are too close to each other to a single point


  function _reducePoints(points, sqTolerance) {
    var reducedPoints = [points[0]];

    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
      if (_sqDist(points[i], points[prev]) > sqTolerance) {
        reducedPoints.push(points[i]);
        prev = i;
      }
    }

    if (prev < len - 1) {
      reducedPoints.push(points[len - 1]);
    }

    return reducedPoints;
  }

  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.


  function clipSegment(a, b, bounds, useLastCode, round) {
    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
        codeB = _getBitCode(b, bounds),
        codeOut,
        p,
        newCode; // save 2nd code to avoid calculating it on the next segment


    _lastCode = codeB;

    while (true) {
      // if a,b is inside the clip window (trivial accept)
      if (!(codeA | codeB)) {
        return [a, b];
      } // if a,b is outside the clip window (trivial reject)


      if (codeA & codeB) {
        return false;
      } // other cases


      codeOut = codeA || codeB;
      p = _getEdgeIntersection(a, b, codeOut, bounds, round);
      newCode = _getBitCode(p, bounds);

      if (codeOut === codeA) {
        a = p;
        codeA = newCode;
      } else {
        b = p;
        codeB = newCode;
      }
    }
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
    var dx = b.x - a.x,
        dy = b.y - a.y,
        min = bounds.min,
        max = bounds.max,
        x,
        y;

    if (code & 8) {
      // top
      x = a.x + dx * (max.y - a.y) / dy;
      y = max.y;
    } else if (code & 4) {
      // bottom
      x = a.x + dx * (min.y - a.y) / dy;
      y = min.y;
    } else if (code & 2) {
      // right
      x = max.x;
      y = a.y + dy * (max.x - a.x) / dx;
    } else if (code & 1) {
      // left
      x = min.x;
      y = a.y + dy * (min.x - a.x) / dx;
    }

    return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
    var code = 0;

    if (p.x < bounds.min.x) {
      // left
      code |= 1;
    } else if (p.x > bounds.max.x) {
      // right
      code |= 2;
    }

    if (p.y < bounds.min.y) {
      // bottom
      code |= 4;
    } else if (p.y > bounds.max.y) {
      // top
      code |= 8;
    }

    return code;
  } // square distance (to avoid unnecessary Math.sqrt calls)


  function _sqDist(p1, p2) {
    var dx = p2.x - p1.x,
        dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  } // return closest point on segment or distance to that point


  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y,
        dot = dx * dx + dy * dy,
        t;

    if (dot > 0) {
      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;
    return sqDist ? dx * dx + dy * dy : new Point(x, y);
  } // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.


  function isFlat(latlngs) {
    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
  }

  function _flat(latlngs) {
    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
    return isFlat(latlngs);
  }

  var LineUtil = {
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat
  };
  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */

  function clipPolygon(points, bounds, round) {
    var clippedPoints,
        edges = [1, 4, 2, 8],
        i,
        j,
        k,
        a,
        b,
        len,
        edge,
        p;

    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = _getBitCode(points[i], bounds);
    } // for each edge (left, bottom, right, top)


    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];

      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j]; // if a is inside the clip window

        if (!(a._code & edge)) {
          // if b is outside the clip window (a->b goes out of screen)
          if (b._code & edge) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }

          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)
        } else if (!(b._code & edge)) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }

      points = clippedPoints;
    }

    return points;
  }

  var PolyUtil = {
    clipPolygon: clipPolygon
  };
  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection — the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
    project: function (latlng) {
      return new Point(latlng.lng, latlng.lat);
    },
    unproject: function (point) {
      return new LatLng(point.y, point.x);
    },
    bounds: new Bounds([-180, -90], [180, 90])
  };
  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
    R: 6378137,
    R_MINOR: 6356752.314245179,
    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
    project: function (latlng) {
      var d = Math.PI / 180,
          r = this.R,
          y = latlng.lat * d,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          con = e * Math.sin(y);
      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
      y = -r * Math.log(Math.max(ts, 1E-10));
      return new Point(latlng.lng * d * r, y);
    },
    unproject: function (point) {
      var d = 180 / Math.PI,
          r = this.R,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          ts = Math.exp(-point.y / r),
          phi = Math.PI / 2 - 2 * Math.atan(ts);

      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        con = e * Math.sin(phi);
        con = Math.pow((1 - con) / (1 + con), e / 2);
        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
        phi += dphi;
      }

      return new LatLng(phi * d, point.x * d / r);
    }
  };
  /*
   * @class Projection
    * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).
    * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid
    * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.
    * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.
    * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
    */

  var index = {
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */

  var EPSG3395 = extend({}, Earth, {
    code: 'EPSG:3395',
    projection: Mercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
    code: 'EPSG:4326',
    projection: LonLat,
    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });
  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
    projection: LonLat,
    transformation: toTransformation(1, 0, -1, 0),
    scale: function (zoom) {
      return Math.pow(2, zoom);
    },
    zoom: function (scale) {
      return Math.log(scale) / Math.LN2;
    },
    distance: function (latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng,
          dy = latlng2.lat - latlng1.lat;
      return Math.sqrt(dx * dx + dy * dy);
    },
    infinite: true
  });
  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;
  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */

  var Layer = Evented.extend({
    // Classes extending `L.Layer` will inherit the following options:
    options: {
      // @option pane: String = 'overlayPane'
      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
      pane: 'overlayPane',
      // @option attribution: String = null
      // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
      attribution: null,
      bubblingMouseEvents: true
    },

    /* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
    addTo: function (map) {
      map.addLayer(this);
      return this;
    },
    // @method remove: this
    // Removes the layer from the map it is currently active on.
    remove: function () {
      return this.removeFrom(this._map || this._mapToAdd);
    },
    // @method removeFrom(map: Map): this
    // Removes the layer from the given map
    //
    // @alternative
    // @method removeFrom(group: LayerGroup): this
    // Removes the layer from the given `LayerGroup`
    removeFrom: function (obj) {
      if (obj) {
        obj.removeLayer(this);
      }

      return this;
    },
    // @method getPane(name? : String): HTMLElement
    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
    getPane: function (name) {
      return this._map.getPane(name ? this.options[name] || name : this.options.pane);
    },
    addInteractiveTarget: function (targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    },
    removeInteractiveTarget: function (targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    },
    // @method getAttribution: String
    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
    getAttribution: function () {
      return this.options.attribution;
    },
    _layerAdd: function (e) {
      var map = e.target; // check in case layer gets added and then removed before the map is ready

      if (!map.hasLayer(this)) {
        return;
      }

      this._map = map;
      this._zoomAnimated = map._zoomAnimated;

      if (this.getEvents) {
        var events = this.getEvents();
        map.on(events, this);
        this.once('remove', function () {
          map.off(events, this);
        }, this);
      }

      this.onAdd(map);

      if (this.getAttribution && map.attributionControl) {
        map.attributionControl.addAttribution(this.getAttribution());
      }

      this.fire('add');
      map.fire('layeradd', {
        layer: this
      });
    }
  });
  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */

  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */

  Map.include({
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the map
    addLayer: function (layer) {
      if (!layer._layerAdd) {
        throw new Error('The provided object is not a Layer.');
      }

      var id = stamp(layer);

      if (this._layers[id]) {
        return this;
      }

      this._layers[id] = layer;
      layer._mapToAdd = this;

      if (layer.beforeAdd) {
        layer.beforeAdd(this);
      }

      this.whenReady(layer._layerAdd, layer);
      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the map.
    removeLayer: function (layer) {
      var id = stamp(layer);

      if (!this._layers[id]) {
        return this;
      }

      if (this._loaded) {
        layer.onRemove(this);
      }

      if (layer.getAttribution && this.attributionControl) {
        this.attributionControl.removeAttribution(layer.getAttribution());
      }

      delete this._layers[id];

      if (this._loaded) {
        this.fire('layerremove', {
          layer: layer
        });
        layer.fire('remove');
      }

      layer._map = layer._mapToAdd = null;
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the map
    hasLayer: function (layer) {
      return !!layer && stamp(layer) in this._layers;
    },

    /* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    _addLayers: function (layers) {
      layers = layers ? isArray(layers) ? layers : [layers] : [];

      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },
    _addZoomLimit: function (layer) {
      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
        this._zoomBoundLayers[stamp(layer)] = layer;

        this._updateZoomLevels();
      }
    },
    _removeZoomLimit: function (layer) {
      var id = stamp(layer);

      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];

        this._updateZoomLevels();
      }
    },
    _updateZoomLevels: function () {
      var minZoom = Infinity,
          maxZoom = -Infinity,
          oldZoomSpan = this._getZoomSpan();

      for (var i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;
        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
      }

      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events
      // @event zoomlevelschange: Event
      // Fired when the number of zoomlevels on the map is changed due
      // to adding or removing a layer.

      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire('zoomlevelschange');
      }

      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
        this.setZoom(this._layersMaxZoom);
      }

      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
        this.setZoom(this._layersMinZoom);
      }
    }
  });
  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({
    initialize: function (layers, options) {
      setOptions(this, options);
      this._layers = {};
      var i, len;

      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the group.
    addLayer: function (layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;

      if (this._map) {
        this._map.addLayer(layer);
      }

      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the group.
    // @alternative
    // @method removeLayer(id: Number): this
    // Removes the layer with the given internal ID from the group.
    removeLayer: function (layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);

      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }

      delete this._layers[id];
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the group.
    // @alternative
    // @method hasLayer(id: Number): Boolean
    // Returns `true` if the given internal ID is currently added to the group.
    hasLayer: function (layer) {
      if (!layer) {
        return false;
      }

      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
      return layerId in this._layers;
    },
    // @method clearLayers(): this
    // Removes all the layers from the group.
    clearLayers: function () {
      return this.eachLayer(this.removeLayer, this);
    },
    // @method invoke(methodName: String, …): this
    // Calls `methodName` on every layer contained in this group, passing any
    // additional parameters. Has no effect if the layers contained do not
    // implement `methodName`.
    invoke: function (methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
          i,
          layer;

      for (i in this._layers) {
        layer = this._layers[i];

        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }

      return this;
    },
    onAdd: function (map) {
      this.eachLayer(map.addLayer, map);
    },
    onRemove: function (map) {
      this.eachLayer(map.removeLayer, map);
    },
    // @method eachLayer(fn: Function, context?: Object): this
    // Iterates over the layers of the group, optionally specifying context of the iterator function.
    // ```js
    // group.eachLayer(function (layer) {
    // 	layer.bindPopup('Hello');
    // });
    // ```
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    // @method getLayer(id: Number): Layer
    // Returns the layer with the given internal ID.
    getLayer: function (id) {
      return this._layers[id];
    },
    // @method getLayers(): Layer[]
    // Returns an array of all the layers added to the group.
    getLayers: function () {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    },
    // @method setZIndex(zIndex: Number): this
    // Calls `setZIndex` on every layer contained in this group, passing the z-index.
    setZIndex: function (zIndex) {
      return this.invoke('setZIndex', zIndex);
    },
    // @method getLayerId(layer: Layer): Number
    // Returns the internal ID for a layer
    getLayerId: function (layer) {
      return stamp(layer);
    }
  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.

  var layerGroup = function (layers, options) {
    return new LayerGroup(layers, options);
  };
  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */


  var FeatureGroup = LayerGroup.extend({
    addLayer: function (layer) {
      if (this.hasLayer(layer)) {
        return this;
      }

      layer.addEventParent(this);
      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent
      // Fired when a layer is added to this `FeatureGroup`

      return this.fire('layeradd', {
        layer: layer
      });
    },
    removeLayer: function (layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }

      if (layer in this._layers) {
        layer = this._layers[layer];
      }

      layer.removeEventParent(this);
      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent
      // Fired when a layer is removed from this `FeatureGroup`

      return this.fire('layerremove', {
        layer: layer
      });
    },
    // @method setStyle(style: Path options): this
    // Sets the given path options to each layer of the group that has a `setStyle` method.
    setStyle: function (style) {
      return this.invoke('setStyle', style);
    },
    // @method bringToFront(): this
    // Brings the layer group to the top of all other layers
    bringToFront: function () {
      return this.invoke('bringToFront');
    },
    // @method bringToBack(): this
    // Brings the layer group to the back of all other layers
    bringToBack: function () {
      return this.invoke('bringToBack');
    },
    // @method getBounds(): LatLngBounds
    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
    getBounds: function () {
      var bounds = new LatLngBounds();

      for (var id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }

      return bounds;
    }
  }); // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.

  var featureGroup = function (layers, options) {
    return new FeatureGroup(layers, options);
  };
  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */


  var Icon = Class.extend({
    /* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */
    options: {
      popupAnchor: [0, 0],
      tooltipAnchor: [0, 0]
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    // @method createIcon(oldIcon?: HTMLElement): HTMLElement
    // Called internally when the icon has to be shown, returns a `<img>` HTML element
    // styled according to the options.
    createIcon: function (oldIcon) {
      return this._createIcon('icon', oldIcon);
    },
    // @method createShadow(oldIcon?: HTMLElement): HTMLElement
    // As `createIcon`, but for the shadow beneath it.
    createShadow: function (oldIcon) {
      return this._createIcon('shadow', oldIcon);
    },
    _createIcon: function (name, oldIcon) {
      var src = this._getIconUrl(name);

      if (!src) {
        if (name === 'icon') {
          throw new Error('iconUrl not set in Icon options (see the docs).');
        }

        return null;
      }

      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);

      this._setIconStyles(img, name);

      return img;
    },
    _setIconStyles: function (img, name) {
      var options = this.options;
      var sizeOption = options[name + 'Size'];

      if (typeof sizeOption === 'number') {
        sizeOption = [sizeOption, sizeOption];
      }

      var size = toPoint(sizeOption),
          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

      if (anchor) {
        img.style.marginLeft = -anchor.x + 'px';
        img.style.marginTop = -anchor.y + 'px';
      }

      if (size) {
        img.style.width = size.x + 'px';
        img.style.height = size.y + 'px';
      }
    },
    _createImg: function (src, el) {
      el = el || document.createElement('img');
      el.src = src;
      return el;
    },
    _getIconUrl: function (name) {
      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
    }
  }); // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.

  function icon(options) {
    return new Icon(options);
  }
  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */


  var IconDefault = Icon.extend({
    options: {
      iconUrl: 'marker-icon.png',
      iconRetinaUrl: 'marker-icon-2x.png',
      shadowUrl: 'marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41]
    },
    _getIconUrl: function (name) {
      if (!IconDefault.imagePath) {
        // Deprecated, backwards-compatibility only
        IconDefault.imagePath = this._detectIconPath();
      } // @option imagePath: String
      // `Icon.Default` will try to auto-detect the location of the
      // blue icon images. If you are placing these images in a non-standard
      // way, set this option to point to the right path.


      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
    },
    _detectIconPath: function () {
      var el = create$1('div', 'leaflet-default-icon-path', document.body);
      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

      document.body.removeChild(el);

      if (path === null || path.indexOf('url') !== 0) {
        path = '';
      } else {
        path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
      }

      return path;
    }
  });
  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */

  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
    initialize: function (marker) {
      this._marker = marker;
    },
    addHooks: function () {
      var icon = this._marker._icon;

      if (!this._draggable) {
        this._draggable = new Draggable(icon, icon, true);
      }

      this._draggable.on({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).enable();

      addClass(icon, 'leaflet-marker-draggable');
    },
    removeHooks: function () {
      this._draggable.off({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).disable();

      if (this._marker._icon) {
        removeClass(this._marker._icon, 'leaflet-marker-draggable');
      }
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    _adjustPan: function (e) {
      var marker = this._marker,
          map = marker._map,
          speed = this._marker.options.autoPanSpeed,
          padding = this._marker.options.autoPanPadding,
          iconPos = getPosition(marker._icon),
          bounds = map.getPixelBounds(),
          origin = map.getPixelOrigin();
      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));

      if (!panBounds.contains(iconPos)) {
        // Compute incremental movement
        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
        map.panBy(movement, {
          animate: false
        });

        this._draggable._newPos._add(movement);

        this._draggable._startPos._add(movement);

        setPosition(marker._icon, this._draggable._newPos);

        this._onDrag(e);

        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDragStart: function () {
      // @section Dragging events
      // @event dragstart: Event
      // Fired when the user starts dragging the marker.
      // @event movestart: Event
      // Fired when the marker starts moving (because of dragging).
      this._oldLatLng = this._marker.getLatLng(); // When using ES6 imports it could not be set when `Popup` was not imported as well

      this._marker.closePopup && this._marker.closePopup();

      this._marker.fire('movestart').fire('dragstart');
    },
    _onPreDrag: function (e) {
      if (this._marker.options.autoPan) {
        cancelAnimFrame(this._panRequest);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDrag: function (e) {
      var marker = this._marker,
          shadow = marker._shadow,
          iconPos = getPosition(marker._icon),
          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position


      if (shadow) {
        setPosition(shadow, iconPos);
      }

      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng; // @event drag: Event
      // Fired repeatedly while the user drags the marker.

      marker.fire('move', e).fire('drag', e);
    },
    _onDragEnd: function (e) {
      // @event dragend: DragEndEvent
      // Fired when the user stops dragging the marker.
      cancelAnimFrame(this._panRequest); // @event moveend: Event
      // Fired when the marker stops moving (because of dragging).

      delete this._oldLatLng;

      this._marker.fire('moveend').fire('dragend', e);
    }
  });
  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({
    // @section
    // @aka Marker options
    options: {
      // @option icon: Icon = *
      // Icon instance to use for rendering the marker.
      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
      // If not specified, a common instance of `L.Icon.Default` is used.
      icon: new IconDefault(),
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option keyboard: Boolean = true
      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
      keyboard: true,
      // @option title: String = ''
      // Text for the browser tooltip that appear on marker hover (no tooltip by default).
      title: '',
      // @option alt: String = ''
      // Text for the `alt` attribute of the icon image (useful for accessibility).
      alt: '',
      // @option zIndexOffset: Number = 0
      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
      zIndexOffset: 0,
      // @option opacity: Number = 1.0
      // The opacity of the marker.
      opacity: 1,
      // @option riseOnHover: Boolean = false
      // If `true`, the marker will get on top of others when you hover the mouse over it.
      riseOnHover: false,
      // @option riseOffset: Number = 250
      // The z-index offset used for the `riseOnHover` feature.
      riseOffset: 250,
      // @option pane: String = 'markerPane'
      // `Map pane` where the markers icon will be added.
      pane: 'markerPane',
      // @option shadowPane: String = 'shadowPane'
      // `Map pane` where the markers shadow will be added.
      shadowPane: 'shadowPane',
      // @option bubblingMouseEvents: Boolean = false
      // When `true`, a mouse event on this marker will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: false,
      // @section Draggable marker options
      // @option draggable: Boolean = false
      // Whether the marker is draggable with mouse/touch or not.
      draggable: false,
      // @option autoPan: Boolean = false
      // Whether to pan the map when dragging this marker near its edge or not.
      autoPan: false,
      // @option autoPanPadding: Point = Point(50, 50)
      // Distance (in pixels to the left/right and to the top/bottom) of the
      // map edge to start panning the map.
      autoPanPadding: [50, 50],
      // @option autoPanSpeed: Number = 10
      // Number of pixels the map should pan by.
      autoPanSpeed: 10
    },

    /* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    },
    onAdd: function (map) {
      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

      if (this._zoomAnimated) {
        map.on('zoomanim', this._animateZoom, this);
      }

      this._initIcon();

      this.update();
    },
    onRemove: function (map) {
      if (this.dragging && this.dragging.enabled()) {
        this.options.draggable = true;
        this.dragging.removeHooks();
      }

      delete this.dragging;

      if (this._zoomAnimated) {
        map.off('zoomanim', this._animateZoom, this);
      }

      this._removeIcon();

      this._removeShadow();
    },
    getEvents: function () {
      return {
        zoom: this.update,
        viewreset: this.update
      };
    },
    // @method getLatLng: LatLng
    // Returns the current geographical position of the marker.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Changes the marker position to the given point.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method setZIndexOffset(offset: Number): this
    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
    setZIndexOffset: function (offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    },
    // @method getIcon: Icon
    // Returns the current icon used by the marker
    getIcon: function () {
      return this.options.icon;
    },
    // @method setIcon(icon: Icon): this
    // Changes the marker icon.
    setIcon: function (icon) {
      this.options.icon = icon;

      if (this._map) {
        this._initIcon();

        this.update();
      }

      if (this._popup) {
        this.bindPopup(this._popup, this._popup.options);
      }

      return this;
    },
    getElement: function () {
      return this._icon;
    },
    update: function () {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();

        this._setPos(pos);
      }

      return this;
    },
    _initIcon: function () {
      var options = this.options,
          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      var icon = options.icon.createIcon(this._icon),
          addIcon = false; // if we're not reusing the icon, remove the old one and init new one

      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }

        addIcon = true;

        if (options.title) {
          icon.title = options.title;
        }

        if (icon.tagName === 'IMG') {
          icon.alt = options.alt || '';
        }
      }

      addClass(icon, classToAdd);

      if (options.keyboard) {
        icon.tabIndex = '0';
      }

      this._icon = icon;

      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      var newShadow = options.icon.createShadow(this._shadow),
          addShadow = false;

      if (newShadow !== this._shadow) {
        this._removeShadow();

        addShadow = true;
      }

      if (newShadow) {
        addClass(newShadow, classToAdd);
        newShadow.alt = '';
      }

      this._shadow = newShadow;

      if (options.opacity < 1) {
        this._updateOpacity();
      }

      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }

      this._initInteraction();

      if (newShadow && addShadow) {
        this.getPane(options.shadowPane).appendChild(this._shadow);
      }
    },
    _removeIcon: function () {
      if (this.options.riseOnHover) {
        this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      remove(this._icon);
      this.removeInteractiveTarget(this._icon);
      this._icon = null;
    },
    _removeShadow: function () {
      if (this._shadow) {
        remove(this._shadow);
      }

      this._shadow = null;
    },
    _setPos: function (pos) {
      if (this._icon) {
        setPosition(this._icon, pos);
      }

      if (this._shadow) {
        setPosition(this._shadow, pos);
      }

      this._zIndex = pos.y + this.options.zIndexOffset;

      this._resetZIndex();
    },
    _updateZIndex: function (offset) {
      if (this._icon) {
        this._icon.style.zIndex = this._zIndex + offset;
      }
    },
    _animateZoom: function (opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

      this._setPos(pos);
    },
    _initInteraction: function () {
      if (!this.options.interactive) {
        return;
      }

      addClass(this._icon, 'leaflet-interactive');
      this.addInteractiveTarget(this._icon);

      if (MarkerDrag) {
        var draggable = this.options.draggable;

        if (this.dragging) {
          draggable = this.dragging.enabled();
          this.dragging.disable();
        }

        this.dragging = new MarkerDrag(this);

        if (draggable) {
          this.dragging.enable();
        }
      }
    },
    // @method setOpacity(opacity: Number): this
    // Changes the opacity of the marker.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._map) {
        this._updateOpacity();
      }

      return this;
    },
    _updateOpacity: function () {
      var opacity = this.options.opacity;

      if (this._icon) {
        setOpacity(this._icon, opacity);
      }

      if (this._shadow) {
        setOpacity(this._shadow, opacity);
      }
    },
    _bringToFront: function () {
      this._updateZIndex(this.options.riseOffset);
    },
    _resetZIndex: function () {
      this._updateZIndex(0);
    },
    _getPopupAnchor: function () {
      return this.options.icon.options.popupAnchor;
    },
    _getTooltipAnchor: function () {
      return this.options.icon.options.tooltipAnchor;
    }
  }); // factory L.marker(latlng: LatLng, options? : Marker options)
  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.

  function marker(latlng, options) {
    return new Marker(latlng, options);
  }
  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */


  var Path = Layer.extend({
    // @section
    // @aka Path options
    options: {
      // @option stroke: Boolean = true
      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
      stroke: true,
      // @option color: String = '#3388ff'
      // Stroke color
      color: '#3388ff',
      // @option weight: Number = 3
      // Stroke width in pixels
      weight: 3,
      // @option opacity: Number = 1.0
      // Stroke opacity
      opacity: 1,
      // @option lineCap: String= 'round'
      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
      lineCap: 'round',
      // @option lineJoin: String = 'round'
      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
      lineJoin: 'round',
      // @option dashArray: String = null
      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashArray: null,
      // @option dashOffset: String = null
      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashOffset: null,
      // @option fill: Boolean = depends
      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
      fill: false,
      // @option fillColor: String = *
      // Fill color. Defaults to the value of the [`color`](#path-color) option
      fillColor: null,
      // @option fillOpacity: Number = 0.2
      // Fill opacity.
      fillOpacity: 0.2,
      // @option fillRule: String = 'evenodd'
      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
      fillRule: 'evenodd',
      // className: '',
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option bubblingMouseEvents: Boolean = true
      // When `true`, a mouse event on this path will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: true
    },
    beforeAdd: function (map) {
      // Renderer is set here because we need to call renderer.getEvents
      // before this.getEvents.
      this._renderer = map.getRenderer(this);
    },
    onAdd: function () {
      this._renderer._initPath(this);

      this._reset();

      this._renderer._addPath(this);
    },
    onRemove: function () {
      this._renderer._removePath(this);
    },
    // @method redraw(): this
    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
    redraw: function () {
      if (this._map) {
        this._renderer._updatePath(this);
      }

      return this;
    },
    // @method setStyle(style: Path options): this
    // Changes the appearance of a Path based on the options in the `Path options` object.
    setStyle: function (style) {
      setOptions(this, style);

      if (this._renderer) {
        this._renderer._updateStyle(this);

        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
          this._updateBounds();
        }
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all path layers.
    bringToFront: function () {
      if (this._renderer) {
        this._renderer._bringToFront(this);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all path layers.
    bringToBack: function () {
      if (this._renderer) {
        this._renderer._bringToBack(this);
      }

      return this;
    },
    getElement: function () {
      return this._path;
    },
    _reset: function () {
      // defined in child classes
      this._project();

      this._update();
    },
    _clickTolerance: function () {
      // used when doing hit detection for Canvas layers
      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
    }
  });
  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
      fill: true,
      // @option radius: Number = 10
      // Radius of the circle marker, in pixels
      radius: 10
    },
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    },
    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
      return this._latlng;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle marker. Units are in pixels.
    setRadius: function (radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of the circle
    getRadius: function () {
      return this._radius;
    },
    setStyle: function (options) {
      var radius = options && options.radius || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    },
    _project: function () {
      this._point = this._map.latLngToLayerPoint(this._latlng);

      this._updateBounds();
    },
    _updateBounds: function () {
      var r = this._radius,
          r2 = this._radiusY || r,
          w = this._clickTolerance(),
          p = [r + w, r2 + w];

      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function () {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function () {
      this._renderer._updateCircle(this);
    },
    _empty: function () {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    }
  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.

  function circleMarker(latlng, options) {
    return new CircleMarker(latlng, options);
  }
  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */


  var Circle = CircleMarker.extend({
    initialize: function (latlng, options, legacyOptions) {
      if (typeof options === 'number') {
        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
        options = extend({}, legacyOptions, {
          radius: options
        });
      }

      setOptions(this, options);
      this._latlng = toLatLng(latlng);

      if (isNaN(this.options.radius)) {
        throw new Error('Circle radius cannot be NaN');
      } // @section
      // @aka Circle options
      // @option radius: Number; Radius of the circle, in meters.


      this._mRadius = this.options.radius;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle. Units are in meters.
    setRadius: function (radius) {
      this._mRadius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of a circle. Units are in meters.
    getRadius: function () {
      return this._mRadius;
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      var half = [this._radius, this._radiusY || this._radius];
      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
    },
    setStyle: Path.prototype.setStyle,
    _project: function () {
      var lng = this._latlng.lng,
          lat = this._latlng.lat,
          map = this._map,
          crs = map.options.crs;

      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180,
            latR = this._mRadius / Earth.R / d,
            top = map.project([lat + latR, lng]),
            bottom = map.project([lat - latR, lng]),
            p = top.add(bottom).divideBy(2),
            lat2 = map.unproject(p).lat,
            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

        if (isNaN(lngR) || lngR === 0) {
          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
        }

        this._point = p.subtract(map.getPixelOrigin());
        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
        this._radiusY = p.y - top.y;
      } else {
        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
        this._point = map.latLngToLayerPoint(this._latlng);
        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
      }

      this._updateBounds();
    }
  }); // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.

  function circle(latlng, options, legacyOptions) {
    return new Circle(latlng, options, legacyOptions);
  }
  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({
    // @section
    // @aka Polyline options
    options: {
      // @option smoothFactor: Number = 1.0
      // How much to simplify the polyline on each zoom level. More means
      // better performance and smoother look, and less means more accurate representation.
      smoothFactor: 1.0,
      // @option noClip: Boolean = false
      // Disable polyline clipping.
      noClip: false
    },
    initialize: function (latlngs, options) {
      setOptions(this, options);

      this._setLatLngs(latlngs);
    },
    // @method getLatLngs(): LatLng[]
    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
    getLatLngs: function () {
      return this._latlngs;
    },
    // @method setLatLngs(latlngs: LatLng[]): this
    // Replaces all the points in the polyline with the given array of geographical points.
    setLatLngs: function (latlngs) {
      this._setLatLngs(latlngs);

      return this.redraw();
    },
    // @method isEmpty(): Boolean
    // Returns `true` if the Polyline has no LatLngs.
    isEmpty: function () {
      return !this._latlngs.length;
    },
    // @method closestLayerPoint(p: Point): Point
    // Returns the point closest to `p` on the Polyline.
    closestLayerPoint: function (p) {
      var minDistance = Infinity,
          minPoint = null,
          closest = _sqClosestPointOnSegment,
          p1,
          p2;

      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
        var points = this._parts[j];

        for (var i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = closest(p, p1, p2, true);

          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = closest(p, p1, p2);
          }
        }
      }

      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }

      return minPoint;
    },
    // @method getCenter(): LatLng
    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          halfDist,
          segDist,
          dist,
          p1,
          p2,
          ratio,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polyline centroid algorithm; only uses the first ring if there are multiple


      for (i = 0, halfDist = 0; i < len - 1; i++) {
        halfDist += points[i].distanceTo(points[i + 1]) / 2;
      } // The line is so small in the current view that all points are on the same pixel.


      if (halfDist === 0) {
        return this._map.layerPointToLatLng(points[0]);
      }

      for (i = 0, dist = 0; i < len - 1; i++) {
        p1 = points[i];
        p2 = points[i + 1];
        segDist = p1.distanceTo(p2);
        dist += segDist;

        if (dist > halfDist) {
          ratio = (dist - halfDist) / segDist;
          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
        }
      }
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      return this._bounds;
    },
    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
    // Adds a given point to the polyline. By default, adds to the first ring of
    // the polyline in case of a multi-polyline, but can be overridden by passing
    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
    addLatLng: function (latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);

      this._bounds.extend(latlng);

      return this.redraw();
    },
    _setLatLngs: function (latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    },
    _defaultShape: function () {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    },
    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
    _convertLatLngs: function (latlngs) {
      var result = [],
          flat = isFlat(latlngs);

      for (var i = 0, len = latlngs.length; i < len; i++) {
        if (flat) {
          result[i] = toLatLng(latlngs[i]);

          this._bounds.extend(result[i]);
        } else {
          result[i] = this._convertLatLngs(latlngs[i]);
        }
      }

      return result;
    },
    _project: function () {
      var pxBounds = new Bounds();
      this._rings = [];

      this._projectLatlngs(this._latlngs, this._rings, pxBounds);

      if (this._bounds.isValid() && pxBounds.isValid()) {
        this._rawPxBounds = pxBounds;

        this._updateBounds();
      }
    },
    _updateBounds: function () {
      var w = this._clickTolerance(),
          p = new Point(w, w);

      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);
    },
    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result, projectedBounds) {
      var flat = latlngs[0] instanceof LatLng,
          len = latlngs.length,
          i,
          ring;

      if (flat) {
        ring = [];

        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
          projectedBounds.extend(ring[i]);
        }

        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    },
    // clip polyline by renderer bounds so that we have less to render for performance
    _clipPoints: function () {
      var bounds = this._renderer._bounds;
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      var parts = this._parts,
          i,
          j,
          k,
          len,
          len2,
          segment,
          points;

      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
        points = this._rings[i];

        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, true);

          if (!segment) {
            continue;
          }

          parts[k] = parts[k] || [];
          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part

          if (segment[1] !== points[j + 1] || j === len2 - 2) {
            parts[k].push(segment[1]);
            k++;
          }
        }
      }
    },
    // simplify each clipped part of the polyline for performance
    _simplifyPoints: function () {
      var parts = this._parts,
          tolerance = this.options.smoothFactor;

      for (var i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      this._clipPoints();

      this._simplifyPoints();

      this._updatePath();
    },
    _updatePath: function () {
      this._renderer._updatePoly(this);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p, closed) {
      var i,
          j,
          k,
          len,
          len2,
          part,
          w = this._clickTolerance();

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // hit detection for polylines


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && j === 0) {
            continue;
          }

          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return true;
          }
        }
      }

      return false;
    }
  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.

  function polyline(latlngs, options) {
    return new Polyline(latlngs, options);
  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.


  Polyline._flat = _flat;
  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({
    options: {
      fill: true
    },
    isEmpty: function () {
      return !this._latlngs.length || !this._latlngs[0].length;
    },
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          j,
          p1,
          p2,
          f,
          area,
          x,
          y,
          center,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polygon centroid algorithm; only uses the first ring if there are multiple


      area = x = y = 0;

      for (i = 0, j = len - 1; i < len; j = i++) {
        p1 = points[i];
        p2 = points[j];
        f = p1.y * p2.x - p2.y * p1.x;
        x += (p1.x + p2.x) * f;
        y += (p1.y + p2.y) * f;
        area += f * 3;
      }

      if (area === 0) {
        // Polygon is so small that all points are on same pixel.
        center = points[0];
      } else {
        center = [x / area, y / area];
      }

      return this._map.layerPointToLatLng(center);
    },
    _convertLatLngs: function (latlngs) {
      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
          len = result.length; // remove last point if it equals first one


      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
        result.pop();
      }

      return result;
    },
    _setLatLngs: function (latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);

      if (isFlat(this._latlngs)) {
        this._latlngs = [this._latlngs];
      }
    },
    _defaultShape: function () {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    },
    _clipPoints: function () {
      // polygons need a different clipping algorithm so we redefine that
      var bounds = this._renderer._bounds,
          w = this.options.weight,
          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges

      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
        clipped = clipPolygon(this._rings[i], bounds, true);

        if (clipped.length) {
          this._parts.push(clipped);
        }
      }
    },
    _updatePath: function () {
      this._renderer._updatePoly(this, true);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      var inside = false,
          part,
          p1,
          p2,
          i,
          j,
          k,
          len,
          len2;

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // ray casting algorithm for detecting if point is in polygon


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];

          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
            inside = !inside;
          }
        }
      } // also check if it's on polygon stroke


      return inside || Polyline.prototype._containsPoint.call(this, p, true);
    }
  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)

  function polygon(latlngs, options) {
    return new Polygon(latlngs, options);
  }
  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */


  var GeoJSON = FeatureGroup.extend({
    /* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     *
     * @option markersInheritOptions: Boolean = false
     * Whether default Markers for "Point" type Features inherit from group options.
     */
    initialize: function (geojson, options) {
      setOptions(this, options);
      this._layers = {};

      if (geojson) {
        this.addData(geojson);
      }
    },
    // @method addData( <GeoJSON> data ): this
    // Adds a GeoJSON object to the layer.
    addData: function (geojson) {
      var features = isArray(geojson) ? geojson : geojson.features,
          i,
          len,
          feature;

      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          // only add this if geometry or geometries are set and not null
          feature = features[i];

          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
            this.addData(feature);
          }
        }

        return this;
      }

      var options = this.options;

      if (options.filter && !options.filter(geojson)) {
        return this;
      }

      var layer = geometryToLayer(geojson, options);

      if (!layer) {
        return this;
      }

      layer.feature = asFeature(geojson);
      layer.defaultOptions = layer.options;
      this.resetStyle(layer);

      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }

      return this.addLayer(layer);
    },
    // @method resetStyle( <Path> layer? ): this
    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
    // If `layer` is omitted, the style of all features in the current layer is reset.
    resetStyle: function (layer) {
      if (layer === undefined) {
        return this.eachLayer(this.resetStyle, this);
      } // reset any custom styles


      layer.options = extend({}, layer.defaultOptions);

      this._setLayerStyle(layer, this.options.style);

      return this;
    },
    // @method setStyle( <Function> style ): this
    // Changes styles of GeoJSON vector layers with the given style function.
    setStyle: function (style) {
      return this.eachLayer(function (layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },
    _setLayerStyle: function (layer, style) {
      if (layer.setStyle) {
        if (typeof style === 'function') {
          style = style(layer.feature);
        }

        layer.setStyle(style);
      }
    }
  }); // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:
  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.

  function geometryToLayer(geojson, options) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
        coords = geometry ? geometry.coordinates : null,
        layers = [],
        pointToLayer = options && options.pointToLayer,
        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
        latlng,
        latlngs,
        i,
        len;

    if (!coords && !geometry) {
      return null;
    }

    switch (geometry.type) {
      case 'Point':
        latlng = _coordsToLatLng(coords);
        return _pointToLayer(pointToLayer, geojson, latlng, options);

      case 'MultiPoint':
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
        }

        return new FeatureGroup(layers);

      case 'LineString':
      case 'MultiLineString':
        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
        return new Polyline(latlngs, options);

      case 'Polygon':
      case 'MultiPolygon':
        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
        return new Polygon(latlngs, options);

      case 'GeometryCollection':
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var layer = geometryToLayer({
            geometry: geometry.geometries[i],
            type: 'Feature',
            properties: geojson.properties
          }, options);

          if (layer) {
            layers.push(layer);
          }
        }

        return new FeatureGroup(layers);

      default:
        throw new Error('Invalid GeoJSON object.');
    }
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
  } // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.


  function coordsToLatLng(coords) {
    return new LatLng(coords[1], coords[0], coords[2]);
  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.


  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
    var latlngs = [];

    for (var i = 0, len = coords.length, latlng; i < len; i++) {
      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
      latlngs.push(latlng);
    }

    return latlngs;
  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)


  function latLngToCoords(latlng, precision) {
    precision = typeof precision === 'number' ? precision : 6;
    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.


  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
    var coords = [];

    for (var i = 0, len = latlngs.length; i < len; i++) {
      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
    }

    if (!levelsDeep && closed) {
      coords.push(coords[0]);
    }

    return coords;
  }

  function getFeature(layer, newGeometry) {
    return layer.feature ? extend({}, layer.feature, {
      geometry: newGeometry
    }) : asFeature(newGeometry);
  } // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.


  function asFeature(geojson) {
    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
      return geojson;
    }

    return {
      type: 'Feature',
      properties: {},
      geometry: geojson
    };
  }

  var PointToGeoJSON = {
    toGeoJSON: function (precision) {
      return getFeature(this, {
        type: 'Point',
        coordinates: latLngToCoords(this.getLatLng(), precision)
      });
    }
  }; // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).

  Marker.include(PointToGeoJSON); // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).

  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON); // @namespace Polyline
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).

  Polyline.include({
    toGeoJSON: function (precision) {
      var multi = !isFlat(this._latlngs);
      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'LineString',
        coordinates: coords
      });
    }
  }); // @namespace Polygon
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).

  Polygon.include({
    toGeoJSON: function (precision) {
      var holes = !isFlat(this._latlngs),
          multi = holes && !isFlat(this._latlngs[0]);
      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

      if (!holes) {
        coords = [coords];
      }

      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'Polygon',
        coordinates: coords
      });
    }
  }); // @namespace LayerGroup

  LayerGroup.include({
    toMultiPoint: function (precision) {
      var coords = [];
      this.eachLayer(function (layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });
      return getFeature(this, {
        type: 'MultiPoint',
        coordinates: coords
      });
    },
    // @method toGeoJSON(precision?: Number): Object
    // `precision` is the number of decimal places for coordinates.
    // The default value is 6 places.
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
    toGeoJSON: function (precision) {
      var type = this.feature && this.feature.geometry && this.feature.geometry.type;

      if (type === 'MultiPoint') {
        return this.toMultiPoint(precision);
      }

      var isGeometryCollection = type === 'GeometryCollection',
          jsons = [];
      this.eachLayer(function (layer) {
        if (layer.toGeoJSON) {
          var json = layer.toGeoJSON(precision);

          if (isGeometryCollection) {
            jsons.push(json.geometry);
          } else {
            var feature = asFeature(json); // Squash nested feature collections

            if (feature.type === 'FeatureCollection') {
              jsons.push.apply(jsons, feature.features);
            } else {
              jsons.push(feature);
            }
          }
        }
      });

      if (isGeometryCollection) {
        return getFeature(this, {
          geometries: jsons,
          type: 'GeometryCollection'
        });
      }

      return {
        type: 'FeatureCollection',
        features: jsons
      };
    }
  }); // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.

  function geoJSON(geojson, options) {
    return new GeoJSON(geojson, options);
  } // Backward compatibility.


  var geoJson = geoJSON;
  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({
    // @section
    // @aka ImageOverlay options
    options: {
      // @option opacity: Number = 1.0
      // The opacity of the image overlay.
      opacity: 1,
      // @option alt: String = ''
      // Text for the `alt` attribute of the image (useful for accessibility).
      alt: '',
      // @option interactive: Boolean = false
      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
      interactive: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the image.
      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
      // @option errorOverlayUrl: String = ''
      // URL to the overlay image to show in place of the overlay that failed to load.
      errorOverlayUrl: '',
      // @option zIndex: Number = 1
      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
      zIndex: 1,
      // @option className: String = ''
      // A custom class name to assign to the image. Empty by default.
      className: ''
    },
    initialize: function (url, bounds, options) {
      // (String, LatLngBounds, Object)
      this._url = url;
      this._bounds = toLatLngBounds(bounds);
      setOptions(this, options);
    },
    onAdd: function () {
      if (!this._image) {
        this._initImage();

        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }

      if (this.options.interactive) {
        addClass(this._image, 'leaflet-interactive');
        this.addInteractiveTarget(this._image);
      }

      this.getPane().appendChild(this._image);

      this._reset();
    },
    onRemove: function () {
      remove(this._image);

      if (this.options.interactive) {
        this.removeInteractiveTarget(this._image);
      }
    },
    // @method setOpacity(opacity: Number): this
    // Sets the opacity of the overlay.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._image) {
        this._updateOpacity();
      }

      return this;
    },
    setStyle: function (styleOpts) {
      if (styleOpts.opacity) {
        this.setOpacity(styleOpts.opacity);
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all overlays.
    bringToFront: function () {
      if (this._map) {
        toFront(this._image);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all overlays.
    bringToBack: function () {
      if (this._map) {
        toBack(this._image);
      }

      return this;
    },
    // @method setUrl(url: String): this
    // Changes the URL of the image.
    setUrl: function (url) {
      this._url = url;

      if (this._image) {
        this._image.src = url;
      }

      return this;
    },
    // @method setBounds(bounds: LatLngBounds): this
    // Update the bounds that this ImageOverlay covers
    setBounds: function (bounds) {
      this._bounds = toLatLngBounds(bounds);

      if (this._map) {
        this._reset();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        zoom: this._reset,
        viewreset: this._reset
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method setZIndex(value: Number): this
    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
    setZIndex: function (value) {
      this.options.zIndex = value;

      this._updateZIndex();

      return this;
    },
    // @method getBounds(): LatLngBounds
    // Get the bounds that this ImageOverlay covers
    getBounds: function () {
      return this._bounds;
    },
    // @method getElement(): HTMLElement
    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
    // used by this overlay.
    getElement: function () {
      return this._image;
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'IMG';
      var img = this._image = wasElementSupplied ? this._url : create$1('img');
      addClass(img, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(img, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(img, this.options.className);
      }

      img.onselectstart = falseFn;
      img.onmousemove = falseFn; // @event load: Event
      // Fired when the ImageOverlay layer has loaded its image

      img.onload = bind(this.fire, this, 'load');
      img.onerror = bind(this._overlayOnError, this, 'error');

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }

      if (this.options.zIndex) {
        this._updateZIndex();
      }

      if (wasElementSupplied) {
        this._url = img.src;
        return;
      }

      img.src = this._url;
      img.alt = this.options.alt;
    },
    _animateZoom: function (e) {
      var scale = this._map.getZoomScale(e.zoom),
          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

      setTransform(this._image, offset, scale);
    },
    _reset: function () {
      var image = this._image,
          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
          size = bounds.getSize();
      setPosition(image, bounds.min);
      image.style.width = size.x + 'px';
      image.style.height = size.y + 'px';
    },
    _updateOpacity: function () {
      setOpacity(this._image, this.options.opacity);
    },
    _updateZIndex: function () {
      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._image.style.zIndex = this.options.zIndex;
      }
    },
    _overlayOnError: function () {
      // @event error: Event
      // Fired when the ImageOverlay layer fails to load its image
      this.fire('error');
      var errorUrl = this.options.errorOverlayUrl;

      if (errorUrl && this._url !== errorUrl) {
        this._url = errorUrl;
        this._image.src = errorUrl;
      }
    }
  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.

  var imageOverlay = function (url, bounds, options) {
    return new ImageOverlay(url, bounds, options);
  };
  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */


  var VideoOverlay = ImageOverlay.extend({
    // @section
    // @aka VideoOverlay options
    options: {
      // @option autoplay: Boolean = true
      // Whether the video starts playing automatically when loaded.
      autoplay: true,
      // @option loop: Boolean = true
      // Whether the video will loop back to the beginning when played.
      loop: true,
      // @option keepAspectRatio: Boolean = true
      // Whether the video will save aspect ratio after the projection.
      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
      keepAspectRatio: true,
      // @option muted: Boolean = false
      // Whether the video starts on mute when loaded.
      muted: false
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'VIDEO';
      var vid = this._image = wasElementSupplied ? this._url : create$1('video');
      addClass(vid, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(vid, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(vid, this.options.className);
      }

      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn; // @event load: Event
      // Fired when the video has finished loading the first frame

      vid.onloadeddata = bind(this.fire, this, 'load');

      if (wasElementSupplied) {
        var sourceElements = vid.getElementsByTagName('source');
        var sources = [];

        for (var j = 0; j < sourceElements.length; j++) {
          sources.push(sourceElements[j].src);
        }

        this._url = sourceElements.length > 0 ? sources : [vid.src];
        return;
      }

      if (!isArray(this._url)) {
        this._url = [this._url];
      }

      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
        vid.style['objectFit'] = 'fill';
      }

      vid.autoplay = !!this.options.autoplay;
      vid.loop = !!this.options.loop;
      vid.muted = !!this.options.muted;

      for (var i = 0; i < this._url.length; i++) {
        var source = create$1('source');
        source.src = this._url[i];
        vid.appendChild(source);
      }
    } // @method getElement(): HTMLVideoElement
    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
    // used by this overlay.

  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
    return new VideoOverlay(video, bounds, options);
  }
  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */


  var SVGOverlay = ImageOverlay.extend({
    _initImage: function () {
      var el = this._image = this._url;
      addClass(el, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(el, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(el, this.options.className);
      }

      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    } // @method getElement(): SVGElement
    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
    // used by this overlay.

  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
    return new SVGOverlay(el, bounds, options);
  }
  /*
   * @class DivOverlay
   * @inherits Layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
   */
  // @namespace DivOverlay


  var DivOverlay = Layer.extend({
    // @section
    // @aka DivOverlay options
    options: {
      // @option offset: Point = Point(0, 7)
      // The offset of the popup position. Useful to control the anchor
      // of the popup when opening it on some overlays.
      offset: [0, 7],
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: '',
      // @option pane: String = 'popupPane'
      // `Map pane` where the popup will be added.
      pane: 'popupPane'
    },
    initialize: function (options, source) {
      setOptions(this, options);
      this._source = source;
    },
    onAdd: function (map) {
      this._zoomAnimated = map._zoomAnimated;

      if (!this._container) {
        this._initLayout();
      }

      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
      }

      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();

      if (map._fadeAnimated) {
        setOpacity(this._container, 1);
      }

      this.bringToFront();
    },
    onRemove: function (map) {
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
      } else {
        remove(this._container);
      }
    },
    // @namespace Popup
    // @method getLatLng: LatLng
    // Returns the geographical point of popup.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Sets the geographical point where the popup will open.
    setLatLng: function (latlng) {
      this._latlng = toLatLng(latlng);

      if (this._map) {
        this._updatePosition();

        this._adjustPan();
      }

      return this;
    },
    // @method getContent: String|HTMLElement
    // Returns the content of the popup.
    getContent: function () {
      return this._content;
    },
    // @method setContent(htmlContent: String|HTMLElement|Function): this
    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
    setContent: function (content) {
      this._content = content;
      this.update();
      return this;
    },
    // @method getElement: String|HTMLElement
    // Returns the HTML container of the popup.
    getElement: function () {
      return this._container;
    },
    // @method update: null
    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
    update: function () {
      if (!this._map) {
        return;
      }

      this._container.style.visibility = 'hidden';

      this._updateContent();

      this._updateLayout();

      this._updatePosition();

      this._container.style.visibility = '';

      this._adjustPan();
    },
    getEvents: function () {
      var events = {
        zoom: this._updatePosition,
        viewreset: this._updatePosition
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method isOpen: Boolean
    // Returns `true` when the popup is visible on the map.
    isOpen: function () {
      return !!this._map && this._map.hasLayer(this);
    },
    // @method bringToFront: this
    // Brings this popup in front of other popups (in the same map pane).
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings this popup to the back of other popups (in the same map pane).
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
      }

      return this;
    },
    _prepareOpen: function (parent, layer, latlng) {
      if (!(layer instanceof Layer)) {
        latlng = layer;
        layer = parent;
      }

      if (layer instanceof FeatureGroup) {
        for (var id in parent._layers) {
          layer = parent._layers[id];
          break;
        }
      }

      if (!latlng) {
        if (layer.getCenter) {
          latlng = layer.getCenter();
        } else if (layer.getLatLng) {
          latlng = layer.getLatLng();
        } else {
          throw new Error('Unable to get source layer LatLng.');
        }
      } // set overlay source to this layer


      this._source = layer; // update the overlay (content, layout, ect...)

      this.update();
      return latlng;
    },
    _updateContent: function () {
      if (!this._content) {
        return;
      }

      var node = this._contentNode;
      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

      if (typeof content === 'string') {
        node.innerHTML = content;
      } else {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }

        node.appendChild(content);
      }

      this.fire('contentupdate');
    },
    _updatePosition: function () {
      if (!this._map) {
        return;
      }

      var pos = this._map.latLngToLayerPoint(this._latlng),
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (this._zoomAnimated) {
        setPosition(this._container, pos.add(anchor));
      } else {
        offset = offset.add(pos).add(anchor);
      }

      var bottom = this._containerBottom = -offset.y,
          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)

      this._container.style.bottom = bottom + 'px';
      this._container.style.left = left + 'px';
    },
    _getAnchor: function () {
      return [0, 0];
    }
  });
  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   * Here's a more complicated way to open a popup on a map:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */
  // @namespace Popup

  var Popup = DivOverlay.extend({
    // @section
    // @aka Popup options
    options: {
      // @option maxWidth: Number = 300
      // Max width of the popup, in pixels.
      maxWidth: 300,
      // @option minWidth: Number = 50
      // Min width of the popup, in pixels.
      minWidth: 50,
      // @option maxHeight: Number = null
      // If set, creates a scrollable container of the given height
      // inside a popup if its content exceeds it.
      maxHeight: null,
      // @option autoPan: Boolean = true
      // Set it to `false` if you don't want the map to do panning animation
      // to fit the opened popup.
      autoPan: true,
      // @option autoPanPaddingTopLeft: Point = null
      // The margin between the popup and the top left corner of the map
      // view after autopanning was performed.
      autoPanPaddingTopLeft: null,
      // @option autoPanPaddingBottomRight: Point = null
      // The margin between the popup and the bottom right corner of the map
      // view after autopanning was performed.
      autoPanPaddingBottomRight: null,
      // @option autoPanPadding: Point = Point(5, 5)
      // Equivalent of setting both top left and bottom right autopan padding to the same value.
      autoPanPadding: [5, 5],
      // @option keepInView: Boolean = false
      // Set it to `true` if you want to prevent users from panning the popup
      // off of the screen while it is open.
      keepInView: false,
      // @option closeButton: Boolean = true
      // Controls the presence of a close button in the popup.
      closeButton: true,
      // @option autoClose: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the popup closing when another popup is opened.
      autoClose: true,
      // @option closeOnEscapeKey: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the ESC key for closing of the popup.
      closeOnEscapeKey: true,
      // @option closeOnClick: Boolean = *
      // Set it if you want to override the default behavior of the popup closing when user clicks
      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: ''
    },
    // @namespace Popup
    // @method openOn(map: Map): this
    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
    openOn: function (map) {
      map.openPopup(this);
      return this;
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupopen: PopupEvent
      // Fired when a popup is opened in the map

      map.fire('popupopen', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupopen: PopupEvent
        // Fired when a popup bound to this layer is opened
        this._source.fire('popupopen', {
          popup: this
        }, true); // For non-path layers, we toggle the popup when clicking
        // again the layer, so prevent the map to reopen it.


        if (!(this._source instanceof Path)) {
          this._source.on('preclick', stopPropagation);
        }
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupclose: PopupEvent
      // Fired when a popup in the map is closed

      map.fire('popupclose', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupclose: PopupEvent
        // Fired when a popup bound to this layer is closed
        this._source.fire('popupclose', {
          popup: this
        }, true);

        if (!(this._source instanceof Path)) {
          this._source.off('preclick', stopPropagation);
        }
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this._close;
      }

      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closePopup(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-popup',
          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');
      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
      this._contentNode = create$1('div', prefix + '-content', wrapper);
      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, 'contextmenu', stopPropagation);
      this._tipContainer = create$1('div', prefix + '-tip-container', container);
      this._tip = create$1('div', prefix + '-tip', this._tipContainer);

      if (this.options.closeButton) {
        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
        closeButton.href = '#close';
        closeButton.innerHTML = '&#215;';
        on(closeButton, 'click', this._onCloseButtonClick, this);
      }
    },
    _updateLayout: function () {
      var container = this._contentNode,
          style = container.style;
      style.width = '';
      style.whiteSpace = 'nowrap';
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = width + 1 + 'px';
      style.whiteSpace = '';
      style.height = '';
      var height = container.offsetHeight,
          maxHeight = this.options.maxHeight,
          scrolledClass = 'leaflet-popup-scrolled';

      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + 'px';
        addClass(container, scrolledClass);
      } else {
        removeClass(container, scrolledClass);
      }

      this._containerWidth = this._container.offsetWidth;
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
          anchor = this._getAnchor();

      setPosition(this._container, pos.add(anchor));
    },
    _adjustPan: function () {
      if (!this.options.autoPan) {
        return;
      }

      if (this._map._panAnim) {
        this._map._panAnim.stop();
      }

      var map = this._map,
          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
          containerHeight = this._container.offsetHeight + marginBottom,
          containerWidth = this._containerWidth,
          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

      layerPos._add(getPosition(this._container));

      var containerPos = map.layerPointToContainerPoint(layerPos),
          padding = toPoint(this.options.autoPanPadding),
          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
          size = map.getSize(),
          dx = 0,
          dy = 0;

      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        // right
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }

      if (containerPos.x - dx - paddingTL.x < 0) {
        // left
        dx = containerPos.x - paddingTL.x;
      }

      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        // bottom
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }

      if (containerPos.y - dy - paddingTL.y < 0) {
        // top
        dy = containerPos.y - paddingTL.y;
      } // @namespace Map
      // @section Popup events
      // @event autopanstart: Event
      // Fired when the map starts autopanning when opening a popup.


      if (dx || dy) {
        map.fire('autopanstart').panBy([dx, dy]);
      }
    },
    _onCloseButtonClick: function (e) {
      this._close();

      stop(e);
    },
    _getAnchor: function () {
      // Where should we anchor the popup on the source layer?
      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
    }
  }); // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.

  var popup = function (options, source) {
    return new Popup(options, source);
  };
  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */


  Map.mergeOptions({
    closePopupOnClick: true
  }); // @namespace Map
  // @section Methods for Layers and Controls

  Map.include({
    // @method openPopup(popup: Popup): this
    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
    // @alternative
    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
    // Creates a popup with the specified content and options and opens it in the given point on a map.
    openPopup: function (popup, latlng, options) {
      if (!(popup instanceof Popup)) {
        popup = new Popup(options).setContent(popup);
      }

      if (latlng) {
        popup.setLatLng(latlng);
      }

      if (this.hasLayer(popup)) {
        return this;
      }

      if (this._popup && this._popup.options.autoClose) {
        this.closePopup();
      }

      this._popup = popup;
      return this.addLayer(popup);
    },
    // @method closePopup(popup?: Popup): this
    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
    closePopup: function (popup) {
      if (!popup || popup === this._popup) {
        popup = this._popup;
        this._popup = null;
      }

      if (popup) {
        this.removeLayer(popup);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */
  // @section Popup methods

  Layer.include({
    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
    // Binds a popup to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindPopup: function (content, options) {
      if (content instanceof Popup) {
        setOptions(content, options);
        this._popup = content;
        content._source = this;
      } else {
        if (!this._popup || options) {
          this._popup = new Popup(options, this);
        }

        this._popup.setContent(content);
      }

      if (!this._popupHandlersAdded) {
        this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = true;
      }

      return this;
    },
    // @method unbindPopup(): this
    // Removes the popup previously bound with `bindPopup`.
    unbindPopup: function () {
      if (this._popup) {
        this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = false;
        this._popup = null;
      }

      return this;
    },
    // @method openPopup(latlng?: LatLng): this
    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
    openPopup: function (layer, latlng) {
      if (this._popup && this._map) {
        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map

        this._map.openPopup(this._popup, latlng);
      }

      return this;
    },
    // @method closePopup(): this
    // Closes the popup bound to this layer if it is open.
    closePopup: function () {
      if (this._popup) {
        this._popup._close();
      }

      return this;
    },
    // @method togglePopup(): this
    // Opens or closes the popup bound to this layer depending on its current state.
    togglePopup: function (target) {
      if (this._popup) {
        if (this._popup._map) {
          this.closePopup();
        } else {
          this.openPopup(target);
        }
      }

      return this;
    },
    // @method isPopupOpen(): boolean
    // Returns `true` if the popup bound to this layer is currently open.
    isPopupOpen: function () {
      return this._popup ? this._popup.isOpen() : false;
    },
    // @method setPopupContent(content: String|HTMLElement|Popup): this
    // Sets the content of the popup bound to this layer.
    setPopupContent: function (content) {
      if (this._popup) {
        this._popup.setContent(content);
      }

      return this;
    },
    // @method getPopup(): Popup
    // Returns the popup bound to this layer.
    getPopup: function () {
      return this._popup;
    },
    _openPopup: function (e) {
      var layer = e.layer || e.target;

      if (!this._popup) {
        return;
      }

      if (!this._map) {
        return;
      } // prevent map click


      stop(e); // if this inherits from Path its a vector and we can just
      // open the popup at the new location

      if (layer instanceof Path) {
        this.openPopup(e.layer || e.target, e.latlng);
        return;
      } // otherwise treat it like a marker and figure out
      // if we should toggle it open/closed


      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
        this.closePopup();
      } else {
        this.openPopup(layer, e.latlng);
      }
    },
    _movePopup: function (e) {
      this._popup.setLatLng(e.latlng);
    },
    _onKeyPress: function (e) {
      if (e.originalEvent.keyCode === 13) {
        this._openPopup(e);
      }
    }
  });
  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */
  // @namespace Tooltip

  var Tooltip = DivOverlay.extend({
    // @section
    // @aka Tooltip options
    options: {
      // @option pane: String = 'tooltipPane'
      // `Map pane` where the tooltip will be added.
      pane: 'tooltipPane',
      // @option offset: Point = Point(0, 0)
      // Optional offset of the tooltip position.
      offset: [0, 0],
      // @option direction: String = 'auto'
      // Direction where to open the tooltip. Possible values are: `right`, `left`,
      // `top`, `bottom`, `center`, `auto`.
      // `auto` will dynamically switch between `right` and `left` according to the tooltip
      // position on the map.
      direction: 'auto',
      // @option permanent: Boolean = false
      // Whether to open the tooltip permanently or only on mouseover.
      permanent: false,
      // @option sticky: Boolean = false
      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
      sticky: false,
      // @option interactive: Boolean = false
      // If true, the tooltip will listen to the feature events.
      interactive: false,
      // @option opacity: Number = 0.9
      // Tooltip container opacity.
      opacity: 0.9
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity); // @namespace Map
      // @section Tooltip events
      // @event tooltipopen: TooltipEvent
      // Fired when a tooltip is opened in the map.

      map.fire('tooltipopen', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipopen: TooltipEvent
        // Fired when a tooltip bound to this layer is opened.
        this._source.fire('tooltipopen', {
          tooltip: this
        }, true);
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Tooltip events
      // @event tooltipclose: TooltipEvent
      // Fired when a tooltip in the map is closed.

      map.fire('tooltipclose', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipclose: TooltipEvent
        // Fired when a tooltip bound to this layer is closed.
        this._source.fire('tooltipclose', {
          tooltip: this
        }, true);
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (touch && !this.options.permanent) {
        events.preclick = this._close;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closeTooltip(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-tooltip',
          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      this._contentNode = this._container = create$1('div', className);
    },
    _updateLayout: function () {},
    _adjustPan: function () {},
    _setPosition: function (pos) {
      var subX,
          subY,
          map = this._map,
          container = this._container,
          centerPoint = map.latLngToContainerPoint(map.getCenter()),
          tooltipPoint = map.layerPointToContainerPoint(pos),
          direction = this.options.direction,
          tooltipWidth = container.offsetWidth,
          tooltipHeight = container.offsetHeight,
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (direction === 'top') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight;
      } else if (direction === 'bottom') {
        subX = tooltipWidth / 2;
        subY = 0;
      } else if (direction === 'center') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight / 2;
      } else if (direction === 'right') {
        subX = 0;
        subY = tooltipHeight / 2;
      } else if (direction === 'left') {
        subX = tooltipWidth;
        subY = tooltipHeight / 2;
      } else if (tooltipPoint.x < centerPoint.x) {
        direction = 'right';
        subX = 0;
        subY = tooltipHeight / 2;
      } else {
        direction = 'left';
        subX = tooltipWidth + (offset.x + anchor.x) * 2;
        subY = tooltipHeight / 2;
      }

      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
      removeClass(container, 'leaflet-tooltip-right');
      removeClass(container, 'leaflet-tooltip-left');
      removeClass(container, 'leaflet-tooltip-top');
      removeClass(container, 'leaflet-tooltip-bottom');
      addClass(container, 'leaflet-tooltip-' + direction);
      setPosition(container, pos);
    },
    _updatePosition: function () {
      var pos = this._map.latLngToLayerPoint(this._latlng);

      this._setPosition(pos);
    },
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._container) {
        setOpacity(this._container, opacity);
      }
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);

      this._setPosition(pos);
    },
    _getAnchor: function () {
      // Where should we anchor the tooltip on the source layer?
      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
    }
  }); // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.

  var tooltip = function (options, source) {
    return new Tooltip(options, source);
  }; // @namespace Map
  // @section Methods for Layers and Controls


  Map.include({
    // @method openTooltip(tooltip: Tooltip): this
    // Opens the specified tooltip.
    // @alternative
    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
    // Creates a tooltip with the specified content and options and open it.
    openTooltip: function (tooltip, latlng, options) {
      if (!(tooltip instanceof Tooltip)) {
        tooltip = new Tooltip(options).setContent(tooltip);
      }

      if (latlng) {
        tooltip.setLatLng(latlng);
      }

      if (this.hasLayer(tooltip)) {
        return this;
      }

      return this.addLayer(tooltip);
    },
    // @method closeTooltip(tooltip?: Tooltip): this
    // Closes the tooltip given as parameter.
    closeTooltip: function (tooltip) {
      if (tooltip) {
        this.removeLayer(tooltip);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */
  // @section Tooltip methods

  Layer.include({
    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
    // Binds a tooltip to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindTooltip: function (content, options) {
      if (content instanceof Tooltip) {
        setOptions(content, options);
        this._tooltip = content;
        content._source = this;
      } else {
        if (!this._tooltip || options) {
          this._tooltip = new Tooltip(options, this);
        }

        this._tooltip.setContent(content);
      }

      this._initTooltipInteractions();

      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
        this.openTooltip();
      }

      return this;
    },
    // @method unbindTooltip(): this
    // Removes the tooltip previously bound with `bindTooltip`.
    unbindTooltip: function () {
      if (this._tooltip) {
        this._initTooltipInteractions(true);

        this.closeTooltip();
        this._tooltip = null;
      }

      return this;
    },
    _initTooltipInteractions: function (remove$$1) {
      if (!remove$$1 && this._tooltipHandlersAdded) {
        return;
      }

      var onOff = remove$$1 ? 'off' : 'on',
          events = {
        remove: this.closeTooltip,
        move: this._moveTooltip
      };

      if (!this._tooltip.options.permanent) {
        events.mouseover = this._openTooltip;
        events.mouseout = this.closeTooltip;

        if (this._tooltip.options.sticky) {
          events.mousemove = this._moveTooltip;
        }

        if (touch) {
          events.click = this._openTooltip;
        }
      } else {
        events.add = this._openTooltip;
      }

      this[onOff](events);
      this._tooltipHandlersAdded = !remove$$1;
    },
    // @method openTooltip(latlng?: LatLng): this
    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
    openTooltip: function (layer, latlng) {
      if (this._tooltip && this._map) {
        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map

        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never
        // opened.


        if (this._tooltip.options.interactive && this._tooltip._container) {
          addClass(this._tooltip._container, 'leaflet-clickable');
          this.addInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method closeTooltip(): this
    // Closes the tooltip bound to this layer if it is open.
    closeTooltip: function () {
      if (this._tooltip) {
        this._tooltip._close();

        if (this._tooltip.options.interactive && this._tooltip._container) {
          removeClass(this._tooltip._container, 'leaflet-clickable');
          this.removeInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method toggleTooltip(): this
    // Opens or closes the tooltip bound to this layer depending on its current state.
    toggleTooltip: function (target) {
      if (this._tooltip) {
        if (this._tooltip._map) {
          this.closeTooltip();
        } else {
          this.openTooltip(target);
        }
      }

      return this;
    },
    // @method isTooltipOpen(): boolean
    // Returns `true` if the tooltip bound to this layer is currently open.
    isTooltipOpen: function () {
      return this._tooltip.isOpen();
    },
    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
    // Sets the content of the tooltip bound to this layer.
    setTooltipContent: function (content) {
      if (this._tooltip) {
        this._tooltip.setContent(content);
      }

      return this;
    },
    // @method getTooltip(): Tooltip
    // Returns the tooltip bound to this layer.
    getTooltip: function () {
      return this._tooltip;
    },
    _openTooltip: function (e) {
      var layer = e.layer || e.target;

      if (!this._tooltip || !this._map) {
        return;
      }

      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
    },
    _moveTooltip: function (e) {
      var latlng = e.latlng,
          containerPoint,
          layerPoint;

      if (this._tooltip.options.sticky && e.originalEvent) {
        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
        latlng = this._map.layerPointToLatLng(layerPoint);
      }

      this._tooltip.setLatLng(latlng);
    }
  });
  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
    options: {
      // @section
      // @aka DivIcon options
      iconSize: [12, 12],
      // also can be set through CSS
      // iconAnchor: (Point),
      // popupAnchor: (Point),
      // @option html: String|HTMLElement = ''
      // Custom HTML code to put inside the div element, empty by default. Alternatively,
      // an instance of `HTMLElement`.
      html: false,
      // @option bgPos: Point = [0, 0]
      // Optional relative position of the background, in pixels
      bgPos: null,
      className: 'leaflet-div-icon'
    },
    createIcon: function (oldIcon) {
      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
          options = this.options;

      if (options.html instanceof Element) {
        empty(div);
        div.appendChild(options.html);
      } else {
        div.innerHTML = options.html !== false ? options.html : '';
      }

      if (options.bgPos) {
        var bgPos = toPoint(options.bgPos);
        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
      }

      this._setIconStyles(div, 'icon');

      return div;
    },
    createShadow: function () {
      return null;
    }
  }); // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.

  function divIcon(options) {
    return new DivIcon(options);
  }

  Icon.Default = IconDefault;
  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */

  var GridLayer = Layer.extend({
    // @section
    // @aka GridLayer options
    options: {
      // @option tileSize: Number|Point = 256
      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
      tileSize: 256,
      // @option opacity: Number = 1.0
      // Opacity of the tiles. Can be used in the `createTile()` function.
      opacity: 1,
      // @option updateWhenIdle: Boolean = (depends)
      // Load new tiles only when panning ends.
      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
      updateWhenIdle: mobile,
      // @option updateWhenZooming: Boolean = true
      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
      updateWhenZooming: true,
      // @option updateInterval: Number = 200
      // Tiles will not update more than once every `updateInterval` milliseconds when panning.
      updateInterval: 200,
      // @option zIndex: Number = 1
      // The explicit zIndex of the tile layer.
      zIndex: 1,
      // @option bounds: LatLngBounds = undefined
      // If set, tiles will only be loaded inside the set `LatLngBounds`.
      bounds: null,
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = undefined
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: undefined,
      // @option maxNativeZoom: Number = undefined
      // Maximum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
      // from `maxNativeZoom` level and auto-scaled.
      maxNativeZoom: undefined,
      // @option minNativeZoom: Number = undefined
      // Minimum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
      // from `minNativeZoom` level and auto-scaled.
      minNativeZoom: undefined,
      // @option noWrap: Boolean = false
      // Whether the layer is wrapped around the antimeridian. If `true`, the
      // GridLayer will only be displayed once at low zoom levels. Has no
      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
      // tiles outside the CRS limits.
      noWrap: false,
      // @option pane: String = 'tilePane'
      // `Map pane` where the grid layer will be added.
      pane: 'tilePane',
      // @option className: String = ''
      // A custom class name to assign to the tile layer. Empty by default.
      className: '',
      // @option keepBuffer: Number = 2
      // When panning the map, keep this many rows and columns of tiles before unloading them.
      keepBuffer: 2
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    onAdd: function () {
      this._initContainer();

      this._levels = {};
      this._tiles = {};

      this._resetView();

      this._update();
    },
    beforeAdd: function (map) {
      map._addZoomLimit(this);
    },
    onRemove: function (map) {
      this._removeAllTiles();

      remove(this._container);

      map._removeZoomLimit(this);

      this._container = null;
      this._tileZoom = undefined;
    },
    // @method bringToFront: this
    // Brings the tile layer to the top of all tile layers.
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);

        this._setAutoZIndex(Math.max);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings the tile layer to the bottom of all tile layers.
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);

        this._setAutoZIndex(Math.min);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the tiles for this layer.
    getContainer: function () {
      return this._container;
    },
    // @method setOpacity(opacity: Number): this
    // Changes the [opacity](#gridlayer-opacity) of the grid layer.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      this._updateOpacity();

      return this;
    },
    // @method setZIndex(zIndex: Number): this
    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
    setZIndex: function (zIndex) {
      this.options.zIndex = zIndex;

      this._updateZIndex();

      return this;
    },
    // @method isLoading: Boolean
    // Returns `true` if any tile in the grid layer has not finished loading.
    isLoading: function () {
      return this._loading;
    },
    // @method redraw: this
    // Causes the layer to clear all the tiles and request them again.
    redraw: function () {
      if (this._map) {
        this._removeAllTiles();

        this._update();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd
      };

      if (!this.options.updateWhenIdle) {
        // update tiles on move, but not more often than once per given interval
        if (!this._onMove) {
          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
        }

        events.move = this._onMove;
      }

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @section Extension methods
    // Layers extending `GridLayer` shall reimplement the following method.
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, must be overridden by classes extending `GridLayer`.
    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
    // is specified, it must be called when the tile has finished loading and drawing.
    createTile: function () {
      return document.createElement('div');
    },
    // @section
    // @method getTileSize: Point
    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
    getTileSize: function () {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    },
    _updateZIndex: function () {
      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },
    _setAutoZIndex: function (compare) {
      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
      var layers = this.getPane().children,
          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

      for (var i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex;

        if (layers[i] !== this._container && zIndex) {
          edgeZIndex = compare(edgeZIndex, +zIndex);
        }
      }

      if (isFinite(edgeZIndex)) {
        this.options.zIndex = edgeZIndex + compare(-1, 1);

        this._updateZIndex();
      }
    },
    _updateOpacity: function () {
      if (!this._map) {
        return;
      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles


      if (ielt9) {
        return;
      }

      setOpacity(this._container, this.options.opacity);
      var now = +new Date(),
          nextFrame = false,
          willPrune = false;

      for (var key in this._tiles) {
        var tile = this._tiles[key];

        if (!tile.current || !tile.loaded) {
          continue;
        }

        var fade = Math.min(1, (now - tile.loaded) / 200);
        setOpacity(tile.el, fade);

        if (fade < 1) {
          nextFrame = true;
        } else {
          if (tile.active) {
            willPrune = true;
          } else {
            this._onOpaqueTile(tile);
          }

          tile.active = true;
        }
      }

      if (willPrune && !this._noPrune) {
        this._pruneTiles();
      }

      if (nextFrame) {
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      }
    },
    _onOpaqueTile: falseFn,
    _initContainer: function () {
      if (this._container) {
        return;
      }

      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));

      this._updateZIndex();

      if (this.options.opacity < 1) {
        this._updateOpacity();
      }

      this.getPane().appendChild(this._container);
    },
    _updateLevels: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom;

      if (zoom === undefined) {
        return undefined;
      }

      for (var z in this._levels) {
        z = Number(z);

        if (this._levels[z].el.children.length || z === zoom) {
          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);

          this._onUpdateLevel(z);
        } else {
          remove(this._levels[z].el);

          this._removeTilesAtZoom(z);

          this._onRemoveLevel(z);

          delete this._levels[z];
        }
      }

      var level = this._levels[zoom],
          map = this._map;

      if (!level) {
        level = this._levels[zoom] = {};
        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
        level.el.style.zIndex = maxZoom;
        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
        level.zoom = zoom;

        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition


        falseFn(level.el.offsetWidth);

        this._onCreateLevel(level);
      }

      this._level = level;
      return level;
    },
    _onUpdateLevel: falseFn,
    _onRemoveLevel: falseFn,
    _onCreateLevel: falseFn,
    _pruneTiles: function () {
      if (!this._map) {
        return;
      }

      var key, tile;

      var zoom = this._map.getZoom();

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._removeAllTiles();

        return;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];
        tile.retain = tile.current;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];

        if (tile.current && !tile.active) {
          var coords = tile.coords;

          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
          }
        }
      }

      for (key in this._tiles) {
        if (!this._tiles[key].retain) {
          this._removeTile(key);
        }
      }
    },
    _removeTilesAtZoom: function (zoom) {
      for (var key in this._tiles) {
        if (this._tiles[key].coords.z !== zoom) {
          continue;
        }

        this._removeTile(key);
      }
    },
    _removeAllTiles: function () {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    },
    _invalidateAll: function () {
      for (var z in this._levels) {
        remove(this._levels[z].el);

        this._onRemoveLevel(Number(z));

        delete this._levels[z];
      }

      this._removeAllTiles();

      this._tileZoom = undefined;
    },
    _retainParent: function (x, y, z, minZoom) {
      var x2 = Math.floor(x / 2),
          y2 = Math.floor(y / 2),
          z2 = z - 1,
          coords2 = new Point(+x2, +y2);
      coords2.z = +z2;

      var key = this._tileCoordsToKey(coords2),
          tile = this._tiles[key];

      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }

      if (z2 > minZoom) {
        return this._retainParent(x2, y2, z2, minZoom);
      }

      return false;
    },
    _retainChildren: function (x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;

          var key = this._tileCoordsToKey(coords),
              tile = this._tiles[key];

          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }

          if (z + 1 < maxZoom) {
            this._retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    },
    _resetView: function (e) {
      var animating = e && (e.pinch || e.flyTo);

      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
    },
    _animateZoom: function (e) {
      this._setView(e.center, e.zoom, true, e.noUpdate);
    },
    _clampZoom: function (zoom) {
      var options = this.options;

      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
        return options.minNativeZoom;
      }

      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
        return options.maxNativeZoom;
      }

      return zoom;
    },
    _setView: function (center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);

      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
        tileZoom = undefined;
      } else {
        tileZoom = this._clampZoom(tileZoom);
      }

      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom;

        if (this._abortLoading) {
          this._abortLoading();
        }

        this._updateLevels();

        this._resetGrid();

        if (tileZoom !== undefined) {
          this._update(center);
        }

        if (!noPrune) {
          this._pruneTiles();
        } // Flag to prevent _updateOpacity from pruning tiles during
        // a zoom anim or a pinch gesture


        this._noPrune = !!noPrune;
      }

      this._setZoomTransforms(center, zoom);
    },
    _setZoomTransforms: function (center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    },
    _setZoomTransform: function (level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom),
          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

      if (any3d) {
        setTransform(level.el, translate, scale);
      } else {
        setPosition(level.el, translate);
      }
    },
    _resetGrid: function () {
      var map = this._map,
          crs = map.options.crs,
          tileSize = this._tileSize = this.getTileSize(),
          tileZoom = this._tileZoom;

      var bounds = this._map.getPixelWorldBounds(this._tileZoom);

      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }

      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
    },
    _onMoveEnd: function () {
      if (!this._map || this._map._animatingZoom) {
        return;
      }

      this._update();
    },
    _getTiledPixelBounds: function (center) {
      var map = this._map,
          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
          scale = map.getZoomScale(mapZoom, this._tileZoom),
          pixelCenter = map.project(center, this._tileZoom).floor(),
          halfSize = map.getSize().divideBy(scale * 2);
      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },
    // Private method to load tiles in the grid's active zoom level according to map bounds
    _update: function (center) {
      var map = this._map;

      if (!map) {
        return;
      }

      var zoom = this._clampZoom(map.getZoom());

      if (center === undefined) {
        center = map.getCenter();
      }

      if (this._tileZoom === undefined) {
        return;
      } // if out of minzoom/maxzoom


      var pixelBounds = this._getTiledPixelBounds(center),
          tileRange = this._pxBoundsToTileRange(pixelBounds),
          tileCenter = tileRange.getCenter(),
          queue = [],
          margin = this.options.keepBuffer,
          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.


      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
        throw new Error('Attempted to load an infinite number of tiles');
      }

      for (var key in this._tiles) {
        var c = this._tiles[key].coords;

        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
          this._tiles[key].current = false;
        }
      } // _update just loads more tiles. If the tile zoom level differs too much
      // from the map's, let _setView reset levels and prune old tiles.


      if (Math.abs(zoom - this._tileZoom) > 1) {
        this._setView(center, zoom);

        return;
      } // create a queue of coordinates to load tiles from


      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = new Point(i, j);
          coords.z = this._tileZoom;

          if (!this._isValidTile(coords)) {
            continue;
          }

          var tile = this._tiles[this._tileCoordsToKey(coords)];

          if (tile) {
            tile.current = true;
          } else {
            queue.push(coords);
          }
        }
      } // sort tile queue to load tiles in order of their distance to center


      queue.sort(function (a, b) {
        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
      });

      if (queue.length !== 0) {
        // if it's the first batch of tiles to load
        if (!this._loading) {
          this._loading = true; // @event loading: Event
          // Fired when the grid layer starts loading tiles.

          this.fire('loading');
        } // create DOM fragment to append tiles in one batch


        var fragment = document.createDocumentFragment();

        for (i = 0; i < queue.length; i++) {
          this._addTile(queue[i], fragment);
        }

        this._level.el.appendChild(fragment);
      }
    },
    _isValidTile: function (coords) {
      var crs = this._map.options.crs;

      if (!crs.infinite) {
        // don't load tile if it's out of bounds and not wrapped
        var bounds = this._globalTileRange;

        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
          return false;
        }
      }

      if (!this.options.bounds) {
        return true;
      } // don't load tile if it doesn't intersect the bounds in options


      var tileBounds = this._tileCoordsToBounds(coords);

      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
    },
    _keyToBounds: function (key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    },
    _tileCoordsToNwSe: function (coords) {
      var map = this._map,
          tileSize = this.getTileSize(),
          nwPoint = coords.scaleBy(tileSize),
          sePoint = nwPoint.add(tileSize),
          nw = map.unproject(nwPoint, coords.z),
          se = map.unproject(sePoint, coords.z);
      return [nw, se];
    },
    // converts tile coordinates to its geographical bounds
    _tileCoordsToBounds: function (coords) {
      var bp = this._tileCoordsToNwSe(coords),
          bounds = new LatLngBounds(bp[0], bp[1]);

      if (!this.options.noWrap) {
        bounds = this._map.wrapLatLngBounds(bounds);
      }

      return bounds;
    },
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords) {
      return coords.x + ':' + coords.y + ':' + coords.z;
    },
    // converts tile cache key to coordinates
    _keyToTileCoords: function (key) {
      var k = key.split(':'),
          coords = new Point(+k[0], +k[1]);
      coords.z = +k[2];
      return coords;
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      }

      remove(tile.el);
      delete this._tiles[key]; // @event tileunload: TileEvent
      // Fired when a tile is removed (e.g. when a tile goes off the screen).

      this.fire('tileunload', {
        tile: tile.el,
        coords: this._keyToTileCoords(key)
      });
    },
    _initTile: function (tile) {
      addClass(tile, 'leaflet-tile');
      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + 'px';
      tile.style.height = tileSize.y + 'px';
      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems

      if (ielt9 && this.options.opacity < 1) {
        setOpacity(tile, this.options.opacity);
      } // without this hack, tiles disappear after zoom on Chrome for Android
      // https://github.com/Leaflet/Leaflet/issues/2078


      if (android && !android23) {
        tile.style.WebkitBackfaceVisibility = 'hidden';
      }
    },
    _addTile: function (coords, container) {
      var tilePos = this._getTilePos(coords),
          key = this._tileCoordsToKey(coords);

      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

      this._initTile(tile); // if createTile is defined with a second argument ("done" callback),
      // we know that tile is async and will be ready later; otherwise


      if (this.createTile.length < 2) {
        // mark tile as ready, but delay one frame for opacity animation to happen
        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      }

      setPosition(tile, tilePos); // save tile in cache

      this._tiles[key] = {
        el: tile,
        coords: coords,
        current: true
      };
      container.appendChild(tile); // @event tileloadstart: TileEvent
      // Fired when a tile is requested and starts loading.

      this.fire('tileloadstart', {
        tile: tile,
        coords: coords
      });
    },
    _tileReady: function (coords, err, tile) {
      if (err) {
        // @event tileerror: TileErrorEvent
        // Fired when there is an error loading a tile.
        this.fire('tileerror', {
          error: err,
          tile: tile,
          coords: coords
        });
      }

      var key = this._tileCoordsToKey(coords);

      tile = this._tiles[key];

      if (!tile) {
        return;
      }

      tile.loaded = +new Date();

      if (this._map._fadeAnimated) {
        setOpacity(tile.el, 0);
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      } else {
        tile.active = true;

        this._pruneTiles();
      }

      if (!err) {
        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent
        // Fired when a tile loads.

        this.fire('tileload', {
          tile: tile.el,
          coords: coords
        });
      }

      if (this._noTilesToLoad()) {
        this._loading = false; // @event load: Event
        // Fired when the grid layer loaded all visible tiles.

        this.fire('load');

        if (ielt9 || !this._map._fadeAnimated) {
          requestAnimFrame(this._pruneTiles, this);
        } else {
          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
          // to trigger a pruning.
          setTimeout(bind(this._pruneTiles, this), 250);
        }
      }
    },
    _getTilePos: function (coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    },
    _wrapCoords: function (coords) {
      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
      newCoords.z = coords.z;
      return newCoords;
    },
    _pxBoundsToTileRange: function (bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
    },
    _noTilesToLoad: function () {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return false;
        }
      }

      return true;
    }
  }); // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.

  function gridLayer(options) {
    return new GridLayer(options);
  }
  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({
    // @section
    // @aka TileLayer options
    options: {
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = 18
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: 18,
      // @option subdomains: String|String[] = 'abc'
      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
      subdomains: 'abc',
      // @option errorTileUrl: String = ''
      // URL to the tile image to show in place of the tile that failed to load.
      errorTileUrl: '',
      // @option zoomOffset: Number = 0
      // The zoom number used in tile URLs will be offset with this value.
      zoomOffset: 0,
      // @option tms: Boolean = false
      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
      tms: false,
      // @option zoomReverse: Boolean = false
      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
      zoomReverse: false,
      // @option detectRetina: Boolean = false
      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
      detectRetina: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false
    },
    initialize: function (url, options) {
      this._url = url;
      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels

      if (options.detectRetina && retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);

        if (!options.zoomReverse) {
          options.zoomOffset++;
          options.maxZoom--;
        } else {
          options.zoomOffset--;
          options.minZoom++;
        }

        options.minZoom = Math.max(0, options.minZoom);
      }

      if (typeof options.subdomains === 'string') {
        options.subdomains = options.subdomains.split('');
      } // for https://github.com/Leaflet/Leaflet/issues/137


      if (!android) {
        this.on('tileunload', this._onTileRemove);
      }
    },
    // @method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    // If the URL does not change, the layer will not be redrawn unless
    // the noRedraw parameter is set to false.
    setUrl: function (url, noRedraw) {
      if (this._url === url && noRedraw === undefined) {
        noRedraw = true;
      }

      this._url = url;

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    },
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
    // callback is called when the tile has been loaded.
    createTile: function (coords, done) {
      var tile = document.createElement('img');
      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
      on(tile, 'error', bind(this._tileOnError, this, done, tile));

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }
      /*
       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
       http://www.w3.org/TR/WCAG20-TECHS/H67
      */


      tile.alt = '';
      /*
       Set role="presentation" to force screen readers to ignore this
       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
      */

      tile.setAttribute('role', 'presentation');
      tile.src = this.getTileUrl(coords);
      return tile;
    },
    // @section Extension methods
    // @uninheritable
    // Layers extending `TileLayer` might reimplement the following method.
    // @method getTileUrl(coords: Object): String
    // Called only internally, returns the URL for a tile given its coordinates.
    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
    getTileUrl: function (coords) {
      var data = {
        r: retina ? '@2x' : '',
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: this._getZoomForUrl()
      };

      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;

        if (this.options.tms) {
          data['y'] = invertedY;
        }

        data['-y'] = invertedY;
      }

      return template(this._url, extend(data, this.options));
    },
    _tileOnLoad: function (done, tile) {
      // For https://github.com/Leaflet/Leaflet/issues/3332
      if (ielt9) {
        setTimeout(bind(done, this, null, tile), 0);
      } else {
        done(null, tile);
      }
    },
    _tileOnError: function (done, tile, e) {
      var errorUrl = this.options.errorTileUrl;

      if (errorUrl && tile.getAttribute('src') !== errorUrl) {
        tile.src = errorUrl;
      }

      done(e, tile);
    },
    _onTileRemove: function (e) {
      e.tile.onload = null;
    },
    _getZoomForUrl: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom,
          zoomReverse = this.options.zoomReverse,
          zoomOffset = this.options.zoomOffset;

      if (zoomReverse) {
        zoom = maxZoom - zoom;
      }

      return zoom + zoomOffset;
    },
    _getSubdomain: function (tilePoint) {
      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },
    // stops loading all tiles in the background layer
    _abortLoading: function () {
      var i, tile;

      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          tile = this._tiles[i].el;
          tile.onload = falseFn;
          tile.onerror = falseFn;

          if (!tile.complete) {
            tile.src = emptyImageUrl;
            remove(tile);
            delete this._tiles[i];
          }
        }
      }
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      } // Cancels any pending http requests associated with the tile
      // unless we're on Android's stock browser,
      // see https://github.com/Leaflet/Leaflet/issues/137


      if (!androidStock) {
        tile.el.setAttribute('src', emptyImageUrl);
      }

      return GridLayer.prototype._removeTile.call(this, key);
    },
    _tileReady: function (coords, err, tile) {
      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {
        return;
      }

      return GridLayer.prototype._tileReady.call(this, coords, err, tile);
    }
  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
    return new TileLayer(url, options);
  }
  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data © 2012 IEM Nexrad"
   * });
   * ```
   */


  var TileLayerWMS = TileLayer.extend({
    // @section
    // @aka TileLayer.WMS options
    // If any custom options not documented here are used, they will be sent to the
    // WMS server as extra parameters in each request URL. This can be useful for
    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
    defaultWmsParams: {
      service: 'WMS',
      request: 'GetMap',
      // @option layers: String = ''
      // **(required)** Comma-separated list of WMS layers to show.
      layers: '',
      // @option styles: String = ''
      // Comma-separated list of WMS styles.
      styles: '',
      // @option format: String = 'image/jpeg'
      // WMS image format (use `'image/png'` for layers with transparency).
      format: 'image/jpeg',
      // @option transparent: Boolean = false
      // If `true`, the WMS service will return images with transparency.
      transparent: false,
      // @option version: String = '1.1.1'
      // Version of the WMS service to use
      version: '1.1.1'
    },
    options: {
      // @option crs: CRS = null
      // Coordinate Reference System to use for the WMS requests, defaults to
      // map CRS. Don't change this if you're not sure what it means.
      crs: null,
      // @option uppercase: Boolean = false
      // If `true`, WMS request parameter keys will be uppercase.
      uppercase: false
    },
    initialize: function (url, options) {
      this._url = url;
      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params

      for (var i in options) {
        if (!(i in this.options)) {
          wmsParams[i] = options[i];
        }
      }

      options = setOptions(this, options);
      var realRetina = options.detectRetina && retina ? 2 : 1;
      var tileSize = this.getTileSize();
      wmsParams.width = tileSize.x * realRetina;
      wmsParams.height = tileSize.y * realRetina;
      this.wmsParams = wmsParams;
    },
    onAdd: function (map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
      this.wmsParams[projectionKey] = this._crs.code;
      TileLayer.prototype.onAdd.call(this, map);
    },
    getTileUrl: function (coords) {
      var tileBounds = this._tileCoordsToNwSe(coords),
          crs = this._crs,
          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
          min = bounds.min,
          max = bounds.max,
          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
          url = TileLayer.prototype.getTileUrl.call(this, coords);

      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
    },
    // @method setParams(params: Object, noRedraw?: Boolean): this
    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
    setParams: function (params, noRedraw) {
      extend(this.wmsParams, params);

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    }
  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.

  function tileLayerWMS(url, options) {
    return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;
  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({
    // @section
    // @aka Renderer options
    options: {
      // @option padding: Number = 0.1
      // How much to extend the clip area around the map view (relative to its size)
      // e.g. 0.1 would be 10% of map view in each direction
      padding: 0.1,
      // @option tolerance: Number = 0
      // How much to extend click tolerance round a path/object on the map
      tolerance: 0
    },
    initialize: function (options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    },
    onAdd: function () {
      if (!this._container) {
        this._initContainer(); // defined by renderer implementations


        if (this._zoomAnimated) {
          addClass(this._container, 'leaflet-zoom-animated');
        }
      }

      this.getPane().appendChild(this._container);

      this._update();

      this.on('update', this._updatePaths, this);
    },
    onRemove: function () {
      this.off('update', this._updatePaths, this);

      this._destroyContainer();
    },
    getEvents: function () {
      var events = {
        viewreset: this._reset,
        zoom: this._onZoom,
        moveend: this._update,
        zoomend: this._onZoomEnd
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._onAnimZoom;
      }

      return events;
    },
    _onAnimZoom: function (ev) {
      this._updateTransform(ev.center, ev.zoom);
    },
    _onZoom: function () {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    },
    _updateTransform: function (center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom),
          position = getPosition(this._container),
          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
          currentCenterPoint = this._map.project(this._center, zoom),
          destCenterPoint = this._map.project(center, zoom),
          centerOffset = destCenterPoint.subtract(currentCenterPoint),
          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

      if (any3d) {
        setTransform(this._container, topLeftOffset, scale);
      } else {
        setPosition(this._container, topLeftOffset);
      }
    },
    _reset: function () {
      this._update();

      this._updateTransform(this._center, this._zoom);

      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    },
    _onZoomEnd: function () {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    },
    _updatePaths: function () {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    },
    _update: function () {
      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
      // Subclasses are responsible of firing the 'update' event.
      var p = this.options.padding,
          size = this._map.getSize(),
          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }
  });
  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    },
    _onViewPreReset: function () {
      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
      this._postponeUpdatePaths = true;
    },
    onAdd: function () {
      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,
      // in case of removing the renderer itself from the map.

      this._draw();
    },
    _initContainer: function () {
      var container = this._container = document.createElement('canvas');
      on(container, 'mousemove', this._onMouseMove, this);
      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
      on(container, 'mouseout', this._handleMouseOut, this);
      this._ctx = container.getContext('2d');
    },
    _destroyContainer: function () {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    },
    _updatePaths: function () {
      if (this._postponeUpdatePaths) {
        return;
      }

      var layer;
      this._redrawBounds = null;

      for (var id in this._layers) {
        layer = this._layers[id];

        layer._update();
      }

      this._redraw();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          container = this._container,
          size = b.getSize(),
          m = retina ? 2 : 1;
      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina

      container.width = m * size.x;
      container.height = m * size.y;
      container.style.width = size.x + 'px';
      container.style.height = size.y + 'px';

      if (retina) {
        this._ctx.scale(2, 2);
      } // translate so we use the same path coordinates after canvas element moves


      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves


      this.fire('update');
    },
    _reset: function () {
      Renderer.prototype._reset.call(this);

      if (this._postponeUpdatePaths) {
        this._postponeUpdatePaths = false;

        this._updatePaths();
      }
    },
    _initPath: function (layer) {
      this._updateDashArray(layer);

      this._layers[stamp(layer)] = layer;
      var order = layer._order = {
        layer: layer,
        prev: this._drawLast,
        next: null
      };

      if (this._drawLast) {
        this._drawLast.next = order;
      }

      this._drawLast = order;
      this._drawFirst = this._drawFirst || this._drawLast;
    },
    _addPath: function (layer) {
      this._requestRedraw(layer);
    },
    _removePath: function (layer) {
      var order = layer._order;
      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        this._drawLast = prev;
      }

      if (prev) {
        prev.next = next;
      } else {
        this._drawFirst = next;
      }

      delete layer._order;
      delete this._layers[stamp(layer)];

      this._requestRedraw(layer);
    },
    _updatePath: function (layer) {
      // Redraw the union of the layer's old pixel
      // bounds and the new pixel bounds.
      this._extendRedrawBounds(layer);

      layer._project();

      layer._update(); // The redraw will extend the redraw bounds
      // with the new pixel bounds.


      this._requestRedraw(layer);
    },
    _updateStyle: function (layer) {
      this._updateDashArray(layer);

      this._requestRedraw(layer);
    },
    _updateDashArray: function (layer) {
      if (typeof layer.options.dashArray === 'string') {
        var parts = layer.options.dashArray.split(/[, ]+/),
            dashArray = [],
            dashValue,
            i;

        for (i = 0; i < parts.length; i++) {
          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths

          if (isNaN(dashValue)) {
            return;
          }

          dashArray.push(dashValue);
        }

        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    },
    _requestRedraw: function (layer) {
      if (!this._map) {
        return;
      }

      this._extendRedrawBounds(layer);

      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
    },
    _extendRedrawBounds: function (layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();

        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));

        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    },
    _redraw: function () {
      this._redrawRequest = null;

      if (this._redrawBounds) {
        this._redrawBounds.min._floor();

        this._redrawBounds.max._ceil();
      }

      this._clear(); // clear layers in redraw bounds


      this._draw(); // draw layers


      this._redrawBounds = null;
    },
    _clear: function () {
      var bounds = this._redrawBounds;

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save();

        this._ctx.setTransform(1, 0, 0, 1, 0, 0);

        this._ctx.clearRect(0, 0, this._container.width, this._container.height);

        this._ctx.restore();
      }
    },
    _draw: function () {
      var layer,
          bounds = this._redrawBounds;

      this._ctx.save();

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.beginPath();

        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);

        this._ctx.clip();
      }

      this._drawing = true;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
          layer._updatePath();
        }
      }

      this._drawing = false;

      this._ctx.restore(); // Restore state before clipping.

    },
    _updatePoly: function (layer, closed) {
      if (!this._drawing) {
        return;
      }

      var i,
          j,
          len2,
          p,
          parts = layer._parts,
          len = parts.length,
          ctx = this._ctx;

      if (!len) {
        return;
      }

      ctx.beginPath();

      for (i = 0; i < len; i++) {
        for (j = 0, len2 = parts[i].length; j < len2; j++) {
          p = parts[i][j];
          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
        }

        if (closed) {
          ctx.closePath();
        }
      }

      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature

    },
    _updateCircle: function (layer) {
      if (!this._drawing || layer._empty()) {
        return;
      }

      var p = layer._point,
          ctx = this._ctx,
          r = Math.max(Math.round(layer._radius), 1),
          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }

      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

      if (s !== 1) {
        ctx.restore();
      }

      this._fillStroke(ctx, layer);
    },
    _fillStroke: function (ctx, layer) {
      var options = layer.options;

      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fillStyle = options.fillColor || options.color;
        ctx.fill(options.fillRule || 'evenodd');
      }

      if (options.stroke && options.weight !== 0) {
        if (ctx.setLineDash) {
          ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }

        ctx.globalAlpha = options.opacity;
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        ctx.lineCap = options.lineCap;
        ctx.lineJoin = options.lineJoin;
        ctx.stroke();
      }
    },
    // Canvas obviously doesn't have mouse events for individual drawn objects,
    // so we emulate that by calculating what's under the mouse on mousemove/click manually
    _onClick: function (e) {
      var point = this._map.mouseEventToLayerPoint(e),
          layer,
          clickedLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          if (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {
            clickedLayer = layer;
          }
        }
      }

      if (clickedLayer) {
        fakeStop(e);

        this._fireEvent([clickedLayer], e);
      }
    },
    _onMouseMove: function (e) {
      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
        return;
      }

      var point = this._map.mouseEventToLayerPoint(e);

      this._handleMouseHover(e, point);
    },
    _handleMouseOut: function (e) {
      var layer = this._hoveredLayer;

      if (layer) {
        // if we're leaving the layer, fire mouseout
        removeClass(this._container, 'leaflet-interactive');

        this._fireEvent([layer], e, 'mouseout');

        this._hoveredLayer = null;
        this._mouseHoverThrottled = false;
      }
    },
    _handleMouseHover: function (e, point) {
      if (this._mouseHoverThrottled) {
        return;
      }

      var layer, candidateHoveredLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          candidateHoveredLayer = layer;
        }
      }

      if (candidateHoveredLayer !== this._hoveredLayer) {
        this._handleMouseOut(e);

        if (candidateHoveredLayer) {
          addClass(this._container, 'leaflet-interactive'); // change cursor

          this._fireEvent([candidateHoveredLayer], e, 'mouseover');

          this._hoveredLayer = candidateHoveredLayer;
        }
      }

      if (this._hoveredLayer) {
        this._fireEvent([this._hoveredLayer], e);
      }

      this._mouseHoverThrottled = true;
      setTimeout(bind(function () {
        this._mouseHoverThrottled = false;
      }, this), 32);
    },
    _fireEvent: function (layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    },
    _bringToFront: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        // Already last
        return;
      }

      if (prev) {
        prev.next = next;
      } else if (next) {
        // Update first entry unless this is the
        // single entry
        this._drawFirst = next;
      }

      order.prev = this._drawLast;
      this._drawLast.next = order;
      order.next = null;
      this._drawLast = order;

      this._requestRedraw(layer);
    },
    _bringToBack: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (prev) {
        prev.next = next;
      } else {
        // Already first
        return;
      }

      if (next) {
        next.prev = prev;
      } else if (prev) {
        // Update last entry unless this is the
        // single entry
        this._drawLast = prev;
      }

      order.prev = null;
      order.next = this._drawFirst;
      this._drawFirst.prev = order;
      this._drawFirst = order;

      this._requestRedraw(layer);
    }
  }); // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.

  function canvas$1(options) {
    return canvas ? new Canvas(options) : null;
  }
  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = function () {
    try {
      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
      return function (name) {
        return document.createElement('<lvml:' + name + ' class="lvml">');
      };
    } catch (e) {
      return function (name) {
        return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }
  }();
  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */
  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences


  var vmlMixin = {
    _initContainer: function () {
      this._container = create$1('div', 'leaflet-vml-container');
    },
    _update: function () {
      if (this._map._animatingZoom) {
        return;
      }

      Renderer.prototype._update.call(this);

      this.fire('update');
    },
    _initPath: function (layer) {
      var container = layer._container = vmlCreate('shape');
      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));
      container.coordsize = '1 1';
      layer._path = vmlCreate('path');
      container.appendChild(layer._path);

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      var container = layer._container;

      this._container.appendChild(container);

      if (layer.options.interactive) {
        layer.addInteractiveTarget(container);
      }
    },
    _removePath: function (layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    },
    _updateStyle: function (layer) {
      var stroke = layer._stroke,
          fill = layer._fill,
          options = layer.options,
          container = layer._container;
      container.stroked = !!options.stroke;
      container.filled = !!options.fill;

      if (options.stroke) {
        if (!stroke) {
          stroke = layer._stroke = vmlCreate('stroke');
        }

        container.appendChild(stroke);
        stroke.weight = options.weight + 'px';
        stroke.color = options.color;
        stroke.opacity = options.opacity;

        if (options.dashArray) {
          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
        } else {
          stroke.dashStyle = '';
        }

        stroke.endcap = options.lineCap.replace('butt', 'flat');
        stroke.joinstyle = options.lineJoin;
      } else if (stroke) {
        container.removeChild(stroke);
        layer._stroke = null;
      }

      if (options.fill) {
        if (!fill) {
          fill = layer._fill = vmlCreate('fill');
        }

        container.appendChild(fill);
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        layer._fill = null;
      }
    },
    _updateCircle: function (layer) {
      var p = layer._point.round(),
          r = Math.round(layer._radius),
          r2 = Math.round(layer._radiusY || r);

      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
    },
    _setPath: function (layer, path) {
      layer._path.v = path;
    },
    _bringToFront: function (layer) {
      toFront(layer._container);
    },
    _bringToBack: function (layer) {
      toBack(layer._container);
    }
  };
  var create$2 = vml ? vmlCreate : svgCreate;
  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.zoomstart = this._onZoomStart;
      return events;
    },
    _initContainer: function () {
      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths

      this._container.setAttribute('pointer-events', 'none');

      this._rootGroup = create$2('g');

      this._container.appendChild(this._rootGroup);
    },
    _destroyContainer: function () {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    },
    _onZoomStart: function () {
      // Drag-then-pinch interactions might mess up the center and zoom.
      // In this case, the easiest way to prevent this is re-do the renderer
      //   bounds and padding when the zooming starts.
      this._update();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          size = b.getSize(),
          container = this._container; // set size of svg-container if changed

      if (!this._svgSize || !this._svgSize.equals(size)) {
        this._svgSize = size;
        container.setAttribute('width', size.x);
        container.setAttribute('height', size.y);
      } // movement: update container viewBox so that we don't have to change coordinates of individual layers


      setPosition(container, b.min);
      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
      this.fire('update');
    },
    // methods below are called by vector layers implementations
    _initPath: function (layer) {
      var path = layer._path = create$2('path'); // @namespace Path
      // @option className: String = null
      // Custom class name set on an element. Only for SVG renderer.

      if (layer.options.className) {
        addClass(path, layer.options.className);
      }

      if (layer.options.interactive) {
        addClass(path, 'leaflet-interactive');
      }

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      if (!this._rootGroup) {
        this._initContainer();
      }

      this._rootGroup.appendChild(layer._path);

      layer.addInteractiveTarget(layer._path);
    },
    _removePath: function (layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    },
    _updatePath: function (layer) {
      layer._project();

      layer._update();
    },
    _updateStyle: function (layer) {
      var path = layer._path,
          options = layer.options;

      if (!path) {
        return;
      }

      if (options.stroke) {
        path.setAttribute('stroke', options.color);
        path.setAttribute('stroke-opacity', options.opacity);
        path.setAttribute('stroke-width', options.weight);
        path.setAttribute('stroke-linecap', options.lineCap);
        path.setAttribute('stroke-linejoin', options.lineJoin);

        if (options.dashArray) {
          path.setAttribute('stroke-dasharray', options.dashArray);
        } else {
          path.removeAttribute('stroke-dasharray');
        }

        if (options.dashOffset) {
          path.setAttribute('stroke-dashoffset', options.dashOffset);
        } else {
          path.removeAttribute('stroke-dashoffset');
        }
      } else {
        path.setAttribute('stroke', 'none');
      }

      if (options.fill) {
        path.setAttribute('fill', options.fillColor || options.color);
        path.setAttribute('fill-opacity', options.fillOpacity);
        path.setAttribute('fill-rule', options.fillRule || 'evenodd');
      } else {
        path.setAttribute('fill', 'none');
      }
    },
    _updatePoly: function (layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    },
    _updateCircle: function (layer) {
      var p = layer._point,
          r = Math.max(Math.round(layer._radius), 1),
          r2 = Math.max(Math.round(layer._radiusY), 1) || r,
          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs

      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

      this._setPath(layer, d);
    },
    _setPath: function (layer, path) {
      layer._path.setAttribute('d', path);
    },
    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
    _bringToFront: function (layer) {
      toFront(layer._path);
    },
    _bringToBack: function (layer) {
      toBack(layer._path);
    }
  });

  if (vml) {
    SVG.include(vmlMixin);
  } // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.


  function svg$1(options) {
    return svg || vml ? new SVG(options) : null;
  }

  Map.include({
    // @namespace Map; @method getRenderer(layer: Path): Renderer
    // Returns the instance of `Renderer` that should be used to render the given
    // `Path`. It will ensure that the `renderer` options of the map and paths
    // are respected, and that the renderers do exist on the map.
    getRenderer: function (layer) {
      // @namespace Path; @option renderer: Renderer
      // Use this specific instance of `Renderer` for this path. Takes
      // precedence over the map's [default renderer](#map-renderer).
      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

      if (!renderer) {
        renderer = this._renderer = this._createRenderer();
      }

      if (!this.hasLayer(renderer)) {
        this.addLayer(renderer);
      }

      return renderer;
    },
    _getPaneRenderer: function (name) {
      if (name === 'overlayPane' || name === undefined) {
        return false;
      }

      var renderer = this._paneRenderers[name];

      if (renderer === undefined) {
        renderer = this._createRenderer({
          pane: name
        });
        this._paneRenderers[name] = renderer;
      }

      return renderer;
    },
    _createRenderer: function (options) {
      // @namespace Map; @option preferCanvas: Boolean = false
      // Whether `Path`s should be rendered on a `Canvas` renderer.
      // By default, all `Path`s are rendered in a `SVG` renderer.
      return this.options.preferCanvas && canvas$1(options) || svg$1(options);
    }
  });
  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */

  var Rectangle = Polygon.extend({
    initialize: function (latLngBounds, options) {
      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    },
    // @method setBounds(latLngBounds: LatLngBounds): this
    // Redraws the rectangle with the passed bounds.
    setBounds: function (latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },
    _boundsToLatLngs: function (latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }
  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)

  function rectangle(latLngBounds, options) {
    return new Rectangle(latLngBounds, options);
  }

  SVG.create = create$2;
  SVG.pointsToPath = pointsToPath;
  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;
  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option boxZoom: Boolean = true
    // Whether the map can be zoomed to a rectangular area specified by
    // dragging the mouse while pressing the shift key.
    boxZoom: true
  });
  var BoxZoom = Handler.extend({
    initialize: function (map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on('unload', this._destroy, this);
    },
    addHooks: function () {
      on(this._container, 'mousedown', this._onMouseDown, this);
    },
    removeHooks: function () {
      off(this._container, 'mousedown', this._onMouseDown, this);
    },
    moved: function () {
      return this._moved;
    },
    _destroy: function () {
      remove(this._pane);
      delete this._pane;
    },
    _resetState: function () {
      this._resetStateTimeout = 0;
      this._moved = false;
    },
    _clearDeferredResetState: function () {
      if (this._resetStateTimeout !== 0) {
        clearTimeout(this._resetStateTimeout);
        this._resetStateTimeout = 0;
      }
    },
    _onMouseDown: function (e) {
      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
        return false;
      } // Clear the deferred resetState if it hasn't executed yet, otherwise it
      // will interrupt the interaction and orphan a box element in the container.


      this._clearDeferredResetState();

      this._resetState();

      disableTextSelection();
      disableImageDrag();
      this._startPoint = this._map.mouseEventToContainerPoint(e);
      on(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseMove: function (e) {
      if (!this._moved) {
        this._moved = true;
        this._box = create$1('div', 'leaflet-zoom-box', this._container);
        addClass(this._container, 'leaflet-crosshair');

        this._map.fire('boxzoomstart');
      }

      this._point = this._map.mouseEventToContainerPoint(e);
      var bounds = new Bounds(this._point, this._startPoint),
          size = bounds.getSize();
      setPosition(this._box, bounds.min);
      this._box.style.width = size.x + 'px';
      this._box.style.height = size.y + 'px';
    },
    _finish: function () {
      if (this._moved) {
        remove(this._box);
        removeClass(this._container, 'leaflet-crosshair');
      }

      enableTextSelection();
      enableImageDrag();
      off(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseUp: function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }

      this._finish();

      if (!this._moved) {
        return;
      } // Postpone to next JS tick so internal click event handling
      // still see it as "moved".


      this._clearDeferredResetState();

      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

      this._map.fitBounds(bounds).fire('boxzoomend', {
        boxZoomBounds: bounds
      });
    },
    _onKeyDown: function (e) {
      if (e.keyCode === 27) {
        this._finish();
      }
    }
  }); // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.

  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);
  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option doubleClickZoom: Boolean|String = true
    // Whether the map can be zoomed in by double clicking on it and
    // zoomed out by double clicking while holding shift. If passed
    // `'center'`, double-click zoom will zoom to the center of the
    //  view regardless of where the mouse was.
    doubleClickZoom: true
  });
  var DoubleClickZoom = Handler.extend({
    addHooks: function () {
      this._map.on('dblclick', this._onDoubleClick, this);
    },
    removeHooks: function () {
      this._map.off('dblclick', this._onDoubleClick, this);
    },
    _onDoubleClick: function (e) {
      var map = this._map,
          oldZoom = map.getZoom(),
          delta = map.options.zoomDelta,
          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

      if (map.options.doubleClickZoom === 'center') {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    }
  }); // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.

  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);
  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option dragging: Boolean = true
    // Whether the map be draggable with mouse/touch or not.
    dragging: true,
    // @section Panning Inertia Options
    // @option inertia: Boolean = *
    // If enabled, panning of the map will have an inertia effect where
    // the map builds momentum while dragging and continues moving in
    // the same direction for some time. Feels especially nice on touch
    // devices. Enabled by default unless running on old Android devices.
    inertia: !android23,
    // @option inertiaDeceleration: Number = 3000
    // The rate with which the inertial movement slows down, in pixels/second².
    inertiaDeceleration: 3400,
    // px/s^2
    // @option inertiaMaxSpeed: Number = Infinity
    // Max speed of the inertial movement, in pixels/second.
    inertiaMaxSpeed: Infinity,
    // px/s
    // @option easeLinearity: Number = 0.2
    easeLinearity: 0.2,
    // TODO refactor, move to CRS
    // @option worldCopyJump: Boolean = false
    // With this option enabled, the map tracks when you pan to another "copy"
    // of the world and seamlessly jumps to the original one so that all overlays
    // like markers and vector layers are still visible.
    worldCopyJump: false,
    // @option maxBoundsViscosity: Number = 0.0
    // If `maxBounds` is set, this option will control how solid the bounds
    // are when dragging the map around. The default value of `0.0` allows the
    // user to drag outside the bounds at normal speed, higher values will
    // slow down map dragging outside bounds, and `1.0` makes the bounds fully
    // solid, preventing the user from dragging outside the bounds.
    maxBoundsViscosity: 0.0
  });
  var Drag = Handler.extend({
    addHooks: function () {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new Draggable(map._mapPane, map._container);

        this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this);

        this._draggable.on('predrag', this._onPreDragLimit, this);

        if (map.options.worldCopyJump) {
          this._draggable.on('predrag', this._onPreDragWrap, this);

          map.on('zoomend', this._onZoomEnd, this);
          map.whenReady(this._onZoomEnd, this);
        }
      }

      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');

      this._draggable.enable();

      this._positions = [];
      this._times = [];
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-grab');
      removeClass(this._map._container, 'leaflet-touch-drag');

      this._draggable.disable();
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    moving: function () {
      return this._draggable && this._draggable._moving;
    },
    _onDragStart: function () {
      var map = this._map;

      map._stop();

      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);
        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
      } else {
        this._offsetLimit = null;
      }

      map.fire('movestart').fire('dragstart');

      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },
    _onDrag: function (e) {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

        this._positions.push(pos);

        this._times.push(time);

        this._prunePositions(time);
      }

      this._map.fire('move', e).fire('drag', e);
    },
    _prunePositions: function (time) {
      while (this._positions.length > 1 && time - this._times[0] > 50) {
        this._positions.shift();

        this._times.shift();
      }
    },
    _onZoomEnd: function () {
      var pxCenter = this._map.getSize().divideBy(2),
          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    },
    _viscousLimit: function (value, threshold) {
      return value - (value - threshold) * this._viscosity;
    },
    _onPreDragLimit: function () {
      if (!this._viscosity || !this._offsetLimit) {
        return;
      }

      var offset = this._draggable._newPos.subtract(this._draggable._startPos);

      var limit = this._offsetLimit;

      if (offset.x < limit.min.x) {
        offset.x = this._viscousLimit(offset.x, limit.min.x);
      }

      if (offset.y < limit.min.y) {
        offset.y = this._viscousLimit(offset.y, limit.min.y);
      }

      if (offset.x > limit.max.x) {
        offset.x = this._viscousLimit(offset.x, limit.max.x);
      }

      if (offset.y > limit.max.y) {
        offset.y = this._viscousLimit(offset.y, limit.max.y);
      }

      this._draggable._newPos = this._draggable._startPos.add(offset);
    },
    _onPreDragWrap: function () {
      // TODO refactor to be able to adjust map pane position after zoom
      var worldWidth = this._worldWidth,
          halfWidth = Math.round(worldWidth / 2),
          dx = this._initialWorldOffset,
          x = this._draggable._newPos.x,
          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = newX;
    },
    _onDragEnd: function (e) {
      var map = this._map,
          options = map.options,
          noInertia = !options.inertia || this._times.length < 2;
      map.fire('dragend', e);

      if (noInertia) {
        map.fire('moveend');
      } else {
        this._prunePositions(+new Date());

        var direction = this._lastPos.subtract(this._positions[0]),
            duration = (this._lastTime - this._times[0]) / 1000,
            ease = options.easeLinearity,
            speedVector = direction.multiplyBy(ease / duration),
            speed = speedVector.distanceTo([0, 0]),
            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

        if (!offset.x && !offset.y) {
          map.fire('moveend');
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);
          requestAnimFrame(function () {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true,
              animate: true
            });
          });
        }
      }
    }
  }); // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).

  Map.addInitHook('addHandler', 'dragging', Drag);
  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */
  // @namespace Map
  // @section Keyboard Navigation Options

  Map.mergeOptions({
    // @option keyboard: Boolean = true
    // Makes the map focusable and allows users to navigate the map with keyboard
    // arrows and `+`/`-` keys.
    keyboard: true,
    // @option keyboardPanDelta: Number = 80
    // Amount of pixels to pan when pressing an arrow key.
    keyboardPanDelta: 80
  });
  var Keyboard = Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173]
    },
    initialize: function (map) {
      this._map = map;

      this._setPanDelta(map.options.keyboardPanDelta);

      this._setZoomDelta(map.options.zoomDelta);
    },
    addHooks: function () {
      var container = this._map._container; // make the container focusable by tabbing

      if (container.tabIndex <= 0) {
        container.tabIndex = '0';
      }

      on(container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.on({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    removeHooks: function () {
      this._removeHooks();

      off(this._map._container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.off({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    _onMouseDown: function () {
      if (this._focused) {
        return;
      }

      var body = document.body,
          docEl = document.documentElement,
          top = body.scrollTop || docEl.scrollTop,
          left = body.scrollLeft || docEl.scrollLeft;

      this._map._container.focus();

      window.scrollTo(left, top);
    },
    _onFocus: function () {
      this._focused = true;

      this._map.fire('focus');
    },
    _onBlur: function () {
      this._focused = false;

      this._map.fire('blur');
    },
    _setPanDelta: function (panDelta) {
      var keys = this._panKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }

      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }

      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }

      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    },
    _setZoomDelta: function (zoomDelta) {
      var keys = this._zoomKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }

      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    },
    _addHooks: function () {
      on(document, 'keydown', this._onKeyDown, this);
    },
    _removeHooks: function () {
      off(document, 'keydown', this._onKeyDown, this);
    },
    _onKeyDown: function (e) {
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var key = e.keyCode,
          map = this._map,
          offset;

      if (key in this._panKeys) {
        if (!map._panAnim || !map._panAnim._inProgress) {
          offset = this._panKeys[key];

          if (e.shiftKey) {
            offset = toPoint(offset).multiplyBy(3);
          }

          map.panBy(offset);

          if (map.options.maxBounds) {
            map.panInsideBounds(map.options.maxBounds);
          }
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
        map.closePopup();
      } else {
        return;
      }

      stop(e);
    }
  }); // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.

  Map.addInitHook('addHandler', 'keyboard', Keyboard);
  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Mouse wheel options
    // @option scrollWheelZoom: Boolean|String = true
    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
    // it will zoom to the center of the view regardless of where the mouse was.
    scrollWheelZoom: true,
    // @option wheelDebounceTime: Number = 40
    // Limits the rate at which a wheel can fire (in milliseconds). By default
    // user can't zoom via wheel more often than once per 40 ms.
    wheelDebounceTime: 40,
    // @option wheelPxPerZoomLevel: Number = 60
    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
    // mean a change of one full zoom level. Smaller values will make wheel-zooming
    // faster (and vice versa).
    wheelPxPerZoomLevel: 60
  });
  var ScrollWheelZoom = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'wheel', this._onWheelScroll, this);
      this._delta = 0;
    },
    removeHooks: function () {
      off(this._map._container, 'wheel', this._onWheelScroll, this);
    },
    _onWheelScroll: function (e) {
      var delta = getWheelDelta(e);
      var debounce = this._map.options.wheelDebounceTime;
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);

      if (!this._startTime) {
        this._startTime = +new Date();
      }

      var left = Math.max(debounce - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), left);
      stop(e);
    },
    _performZoom: function () {
      var map = this._map,
          zoom = map.getZoom(),
          snap = this._map.options.zoomSnap || 0;

      map._stop(); // stop panning and fly animations if any
      // map the delta with a sigmoid function to -4..4 range leaning on -1..1


      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
      this._delta = 0;
      this._startTime = null;

      if (!delta) {
        return;
      }

      if (map.options.scrollWheelZoom === 'center') {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    }
  }); // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.

  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);
  /*
   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Touch interaction options
    // @option tap: Boolean = true
    // Enables mobile hacks for supporting instant taps (fixing 200ms click
    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).
    tap: true,
    // @option tapTolerance: Number = 15
    // The max number of pixels a user can shift his finger during touch
    // for it to be considered a valid tap.
    tapTolerance: 15
  });
  var Tap = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'touchstart', this._onDown, this);
    },
    removeHooks: function () {
      off(this._map._container, 'touchstart', this._onDown, this);
    },
    _onDown: function (e) {
      if (!e.touches) {
        return;
      }

      preventDefault(e);
      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch

      if (e.touches.length > 1) {
        this._fireClick = false;
        clearTimeout(this._holdTimeout);
        return;
      }

      var first = e.touches[0],
          el = first.target;
      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it

      if (el.tagName && el.tagName.toLowerCase() === 'a') {
        addClass(el, 'leaflet-active');
      } // simulate long hold but setting a timeout


      this._holdTimeout = setTimeout(bind(function () {
        if (this._isTapValid()) {
          this._fireClick = false;

          this._onUp();

          this._simulateEvent('contextmenu', first);
        }
      }, this), 1000);

      this._simulateEvent('mousedown', first);

      on(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);
    },
    _onUp: function (e) {
      clearTimeout(this._holdTimeout);
      off(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);

      if (this._fireClick && e && e.changedTouches) {
        var first = e.changedTouches[0],
            el = first.target;

        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
          removeClass(el, 'leaflet-active');
        }

        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much


        if (this._isTapValid()) {
          this._simulateEvent('click', first);
        }
      }
    },
    _isTapValid: function () {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    },
    _onMove: function (e) {
      var first = e.touches[0];
      this._newPos = new Point(first.clientX, first.clientY);

      this._simulateEvent('mousemove', first);
    },
    _simulateEvent: function (type, e) {
      var simulatedEvent = document.createEvent('MouseEvents');
      simulatedEvent._simulated = true;
      e.target._simulatedClick = true;
      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
      e.target.dispatchEvent(simulatedEvent);
    }
  }); // @section Handlers
  // @property tap: Handler
  // Mobile touch hacks (quick tap and touch hold) handler.

  if (touch && (!pointer || safari)) {
    Map.addInitHook('addHandler', 'tap', Tap);
  }
  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */
  // @namespace Map
  // @section Interaction Options


  Map.mergeOptions({
    // @section Touch interaction options
    // @option touchZoom: Boolean|String = *
    // Whether the map can be zoomed by touch-dragging with two fingers. If
    // passed `'center'`, it will zoom to the center of the view regardless of
    // where the touch events (fingers) were. Enabled for touch-capable web
    // browsers except for old Androids.
    touchZoom: touch && !android23,
    // @option bounceAtZoomLimits: Boolean = true
    // Set it to false if you don't want the map to zoom beyond min/max zoom
    // and then bounce back when pinch-zooming.
    bounceAtZoomLimits: true
  });
  var TouchZoom = Handler.extend({
    addHooks: function () {
      addClass(this._map._container, 'leaflet-touch-zoom');
      on(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-touch-zoom');
      off(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    _onTouchStart: function (e) {
      var map = this._map;

      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
        return;
      }

      var p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]);
      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);

      if (map.options.touchZoom !== 'center') {
        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
      }

      this._startDist = p1.distanceTo(p2);
      this._startZoom = map.getZoom();
      this._moved = false;
      this._zooming = true;

      map._stop();

      on(document, 'touchmove', this._onTouchMove, this);
      on(document, 'touchend', this._onTouchEnd, this);
      preventDefault(e);
    },
    _onTouchMove: function (e) {
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }

      var map = this._map,
          p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]),
          scale = p1.distanceTo(p2) / this._startDist;

      this._zoom = map.getScaleZoom(scale, this._startZoom);

      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
        this._zoom = map._limitZoom(this._zoom);
      }

      if (map.options.touchZoom === 'center') {
        this._center = this._startLatLng;

        if (scale === 1) {
          return;
        }
      } else {
        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);

        if (scale === 1 && delta.x === 0 && delta.y === 0) {
          return;
        }

        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
      }

      if (!this._moved) {
        map._moveStart(true, false);

        this._moved = true;
      }

      cancelAnimFrame(this._animRequest);
      var moveFn = bind(map._move, map, this._center, this._zoom, {
        pinch: true,
        round: false
      });
      this._animRequest = requestAnimFrame(moveFn, this, true);
      preventDefault(e);
    },
    _onTouchEnd: function () {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }

      this._zooming = false;
      cancelAnimFrame(this._animRequest);
      off(document, 'touchmove', this._onTouchMove, this);
      off(document, 'touchend', this._onTouchEnd, this); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.

      if (this._map.options.zoomAnimation) {
        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
      } else {
        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    }
  }); // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.

  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);
  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.Tap = Tap;
  Map.TouchZoom = TouchZoom;
  exports.version = version;
  exports.Control = Control;
  exports.control = control;
  exports.Browser = Browser;
  exports.Evented = Evented;
  exports.Mixin = Mixin;
  exports.Util = Util;
  exports.Class = Class;
  exports.Handler = Handler;
  exports.extend = extend;
  exports.bind = bind;
  exports.stamp = stamp;
  exports.setOptions = setOptions;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.PosAnimation = PosAnimation;
  exports.Draggable = Draggable;
  exports.LineUtil = LineUtil;
  exports.PolyUtil = PolyUtil;
  exports.Point = Point;
  exports.point = toPoint;
  exports.Bounds = Bounds;
  exports.bounds = toBounds;
  exports.Transformation = Transformation;
  exports.transformation = toTransformation;
  exports.Projection = index;
  exports.LatLng = LatLng;
  exports.latLng = toLatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.latLngBounds = toLatLngBounds;
  exports.CRS = CRS;
  exports.GeoJSON = GeoJSON;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.layerGroup = layerGroup;
  exports.FeatureGroup = FeatureGroup;
  exports.featureGroup = featureGroup;
  exports.ImageOverlay = ImageOverlay;
  exports.imageOverlay = imageOverlay;
  exports.VideoOverlay = VideoOverlay;
  exports.videoOverlay = videoOverlay;
  exports.SVGOverlay = SVGOverlay;
  exports.svgOverlay = svgOverlay;
  exports.DivOverlay = DivOverlay;
  exports.Popup = Popup;
  exports.popup = popup;
  exports.Tooltip = Tooltip;
  exports.tooltip = tooltip;
  exports.Icon = Icon;
  exports.icon = icon;
  exports.DivIcon = DivIcon;
  exports.divIcon = divIcon;
  exports.Marker = Marker;
  exports.marker = marker;
  exports.TileLayer = TileLayer;
  exports.tileLayer = tileLayer;
  exports.GridLayer = GridLayer;
  exports.gridLayer = gridLayer;
  exports.SVG = SVG;
  exports.svg = svg$1;
  exports.Renderer = Renderer;
  exports.Canvas = Canvas;
  exports.canvas = canvas$1;
  exports.Path = Path;
  exports.CircleMarker = CircleMarker;
  exports.circleMarker = circleMarker;
  exports.Circle = Circle;
  exports.circle = circle;
  exports.Polyline = Polyline;
  exports.polyline = polyline;
  exports.Polygon = Polygon;
  exports.polygon = polygon;
  exports.Rectangle = Rectangle;
  exports.rectangle = rectangle;
  exports.Map = Map;
  exports.map = createMap;
  var oldL = window.L;

  exports.noConflict = function () {
    window.L = oldL;
    return this;
  }; // Always export us to window global (see #2364)


  window.L = exports;
});

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon-2x.png":
/*!*************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon-2x.png ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "680f69f3c2e6b90c1812.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "2b3e1faf89f94a483539.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-shadow.png":
/*!************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-shadow.png ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "a0c6cc1401c107b501ef.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./style.css");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ "./node_modules/leaflet/dist/leaflet.css");



/* This code is needed to properly load the images in the Leaflet CSS */

delete (leaflet__WEBPACK_IMPORTED_MODULE_1___default().Icon.Default.prototype._getIconUrl);
leaflet__WEBPACK_IMPORTED_MODULE_1___default().Icon.Default.mergeOptions({
  iconRetinaUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ "./node_modules/leaflet/dist/images/marker-icon-2x.png"),
  iconUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ "./node_modules/leaflet/dist/images/marker-icon.png"),
  shadowUrl: __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ "./node_modules/leaflet/dist/images/marker-shadow.png")
});
'use strict'; // prettier-ignore


const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
const form = document.querySelector('.form');
const containerWorkouts = document.querySelector('.workouts');
const inputType = document.querySelector('.form__input--type');
const inputDistance = document.querySelector('.form__input--distance');
const inputDuration = document.querySelector('.form__input--duration');
const inputCadence = document.querySelector('.form__input--cadence');
const inputElevation = document.querySelector('.form__input--elevation');

if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(function (position) {
    const {
      latitude
    } = position.coords;
    const {
      longitude
    } = position.coords;
    console.log("https://www.google.com/maps/@".concat(latitude, ",").concat(longitude));
    const map = leaflet__WEBPACK_IMPORTED_MODULE_1___default().map('map').setView([latitude, longitude], 13);
    leaflet__WEBPACK_IMPORTED_MODULE_1___default().tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    leaflet__WEBPACK_IMPORTED_MODULE_1___default().marker([34.43544, 32.8986]).addTo(map).bindPopup('A pretty CSS3 popup.<br> Easily customizable.').openPopup();
  }, function () {
    alert('no location');
  });
}
}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d1osV0FBVixDQUFzQkUsa0JBQXRCLENBQ0UsVUFBVWdFLFFBQVYsRUFBb0I7QUFDbEIsVUFBTTtBQUFFM0QsTUFBQUE7QUFBRixRQUFlMkQsUUFBUSxDQUFDNUQsTUFBOUI7QUFDQSxVQUFNO0FBQUVFLE1BQUFBO0FBQUYsUUFBZ0IwRCxRQUFRLENBQUM1RCxNQUEvQjtBQUNBaG5CLElBQUFBLE9BQU8sQ0FBQzRKLEdBQVIsd0NBQTRDcWQsUUFBNUMsY0FBd0RDLFNBQXhEO0FBQ0EsVUFBTTJJLEdBQUcsR0FBR2p3QixrREFBQSxDQUFNLEtBQU4sRUFBYXNmLE9BQWIsQ0FBcUIsQ0FBQytILFFBQUQsRUFBV0MsU0FBWCxDQUFyQixFQUE0QyxFQUE1QyxDQUFaO0FBRUF0bkIsSUFBQUEsd0RBQUEsQ0FBWSxvREFBWixFQUFrRTtBQUNoRXk0QixNQUFBQSxXQUFXLEVBQ1Q7QUFGOEQsS0FBbEUsRUFHR3BJLEtBSEgsQ0FHU0osR0FIVDtBQUtBandCLElBQUFBLHFEQUFBLENBQVMsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUFULEVBQ0dxd0IsS0FESCxDQUNTSixHQURULEVBRUc2VSxTQUZILENBRWEsK0NBRmIsRUFHR3dOLFNBSEg7QUFJRCxHQWhCSCxFQWlCRSxZQUFZO0FBQ1ZnYSxJQUFBQSxLQUFLLENBQUMsYUFBRCxDQUFMO0FBQ0QsR0FuQkg7QUFxQkQsQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb3JlL1V0aWwuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvcmUvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvcmUvRXZlbnRzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvbWV0cnkvQm91bmRzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vTGF0TG5nQm91bmRzLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vTGF0TG5nLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vY3JzL0NSUy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzg1Ny5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5VdGlsLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb3JlL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9kb20vRG9tRXZlbnQuRG91YmxlVGFwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9kb20vRG9tVXRpbC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZG9tL0RvbUV2ZW50LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9kb20vUG9zQW5pbWF0aW9uLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvTWFwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5MYXllcnMuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5ab29tLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuU2NhbGUuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29udHJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvY29yZS9IYW5kbGVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzMzOTUuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9nZW8vY3JzL0NSUy5TaW1wbGUuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2dlby9jcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL0xheWVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9MYXllckdyb3VwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvSWNvbi5EZWZhdWx0LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlTWFya2VyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9HZW9KU09OLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9JbWFnZU92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL1ZpZGVvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvU1ZHT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvUG9wdXAuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL1Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL21hcmtlci9EaXZJY29uLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci9tYXJrZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3RpbGUvR3JpZExheWVyLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuZ2V0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL2xheWVyL3ZlY3Rvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuRHJhZy5qcyIsIndlYnBhY2s6Ly9tYXB0eS8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuVGFwLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwid2VicGFjazovL21hcHR5Ly4uL3NyYy9tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFwdHkvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzgzY2IiLCJ3ZWJwYWNrOi8vbWFwdHkvLi9zdHlsZS5jc3M/ZWIyYSIsIndlYnBhY2s6Ly9tYXB0eS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9tYXB0eS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9tYXB0eS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWFwdHkvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9tYXB0eS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL21hcHR5L3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL21hcHR5Ly4vc2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbmV4cG9ydCB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuZXhwb3J0IHZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5leHBvcnQgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbi8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbi8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4vLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHdyYXBwZXJGbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4vLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbi8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgZGlnaXRzKSB7XHJcblx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCAoZGlnaXRzID09PSB1bmRlZmluZWQgPyA2IDogZGlnaXRzKSk7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuZXhwb3J0IHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRVdGlsLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0XHRkZWxldGUgcHJvcHMuc3RhdGljcztcclxuXHR9XHJcblxyXG5cdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuXHRcdFV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBVdGlsLmV4dGVuZChVdGlsLmNyZWF0ZShwcm90by5vcHRpb25zKSwgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRVdGlsLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG5cdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG5cdGluY2x1ZGVzID0gVXRpbC5pc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcblx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcblx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEV2ZW50cyA9IHtcclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblxyXG5cdFx0LyogZ2V0L2luaXQgbGlzdGVuZXJzIGZvciB0eXBlICovXHJcblx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghdHlwZUxpc3RlbmVycykge1xyXG5cdFx0XHR0eXBlTGlzdGVuZXJzID0gW107XHJcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuXHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycy5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcCBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxpc3RlbmVycykge1xyXG5cclxuXHRcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChsLmN0eCAhPT0gY29udGV4dCkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdGlmIChsLmZuID09PSBmbikge1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRcdGwuZm4gPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGFuIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IFV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7XHJcblx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdHRhcmdldDogdGhpcyxcclxuXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5vbmNlKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxyXG5cdFx0cmV0dXJuIHRoaXNcclxuXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5vbih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG5cdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG5cdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5FdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5FdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbkV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbkV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuZXhwb3J0IHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XHJcbiIsImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0VhcnRofSBmcm9tICcuL2Nycy9DUlMuRWFydGgnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcblx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcblx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG5cdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcblx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIFV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIFV0aWwuZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtTcGhlcmljYWwgTGF3IG9mIENvc2luZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9sYXdfb2ZfY29zaW5lcykuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVycy8yYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcblx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZyhhLCBiLCBjKTtcclxufVxyXG4iLCJcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5CYXNlXHJcbiAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvb3JkaW5hdGVfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogZWFydGhSYWRpdXMsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuXHR2YXIgc3RyID0gJycsXG5cdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuXG5cblxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5pbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuZXhwb3J0IHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbmV4cG9ydCB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5leHBvcnQgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5leHBvcnQgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbmV4cG9ydCB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxuZXhwb3J0IHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbmV4cG9ydCB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5leHBvcnQgdmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbmV4cG9ydCB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbmV4cG9ydCB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5leHBvcnQgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuZXhwb3J0IHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuZXhwb3J0IHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbmV4cG9ydCB2YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxuZXhwb3J0IHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbmV4cG9ydCB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbmV4cG9ydCB2YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbmV4cG9ydCB2YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG5leHBvcnQgdmFyIHN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbmV4cG9ydCB2YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5cbnZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG52YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xuXG52YXIgX3BvaW50ZXJzID0ge307XG52YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4vLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4vLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpIHtcblx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbkRvd24gPSBVdGlsLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcblx0XHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fSk7XG5cblx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpIHtcblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgJiYgZS5idXR0b25zID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcbn1cbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XHJcbnZhciBfdG91Y2hlbmQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCc7XHJcbnZhciBfcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0aWYgKCFlLmlzUHJpbWFyeSkgeyByZXR1cm47IH1cclxuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9IC8vIG1vdXNlIGZpcmVzIG5hdGl2ZSBkYmxjbGlja1xyXG5cdFx0fSBlbHNlIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCkgOiBwcm9wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHR0b3VjaC5idXR0b24gPSAwO1xyXG5cdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgb25Ub3VjaEVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcblx0dmFyIHRvdWNoc3RhcnQgPSBvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdCAgICB0b3VjaGVuZCA9IG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdLFxyXG5cdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCB0b3VjaGVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBkYmxjbGljaywgZmFsc2UpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbmV4cG9ydCB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcblx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcblx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQpIHtcclxuXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBVdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIFV0aWwudHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG5cdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcblx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG5cdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG5cdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuXHR9XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KEJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG5leHBvcnQgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG5cdGRvIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcblx0cmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbi8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG5cdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcblx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcblx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuXHR9O1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcbmltcG9ydCB7Z2V0U2NhbGV9IGZyb20gJy4vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYnJvd3NlckZpcmVzTmF0aXZlRGJsQ2xpY2soKSB7XHJcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvcG9pbnRlcmV2ZW50cy9pc3N1ZXMvMTcxXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0cmV0dXJuICEoQnJvd3Nlci5lZGdlIHx8IEJyb3dzZXIuc2FmYXJpKTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBtb3VzZVN1YnN0ID0ge1xyXG5cdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG5cdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcblx0d2hlZWw6ICEoJ29ud2hlZWwnIGluIHdpbmRvdykgJiYgJ21vdXNld2hlZWwnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAoQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG5cdFx0YWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmICFicm93c2VyRmlyZXNOYXRpdmVEYmxDbGljaygpKSB7XHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJyB8fCB0eXBlID09PSAnd2hlZWwnIHx8ICB0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xyXG5cdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9yaWdpbmFsSGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyksXHJcblx0ICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRpZiAoQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmICFicm93c2VyRmlyZXNOYXRpdmVEYmxDbGljaygpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHRza2lwcGVkKGUpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ3doZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcblx0YWRkT25lKGVsLCAnd2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0YWRkT25lKGVsLCAnY2xpY2snLCBmYWtlU3RvcCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcbi8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcbi8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLndpbiAmJiBCcm93c2VyLmNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdEJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuXHR2YXIgZXZlbnRzID0gc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0cmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuZXhwb3J0IHZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb3NBbmltYXRpb259IGZyb20gJy4uL2RvbS9Qb3NBbmltYXRpb24nO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcblx0XHQvLyB0byBhdm9pZCBpbmNvbnNpc3RlbnQgc3RhdGUgaW4gc29tZSBlZGdlIGNhc2VzLlxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG5cdC8vIGBwYWRkaW5nYCwgYHBhZGRpbmdUb3BMZWZ0YCBhbmQgYHBhZGRpbmdUb3BSaWdodGAgb3B0aW9ucyB0byBmaXRcclxuXHQvLyB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLCBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QoY2VudGVyKSxcclxuXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgaGFsZlBpeGVsQm91bmRzID0gcGl4ZWxCb3VuZHMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSk7XHJcblxyXG5cdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGRpZmYgPSBwaXhlbENlbnRlci5zdWJ0cmFjdChwaXhlbFBvaW50KSxcclxuXHRcdFx0ICAgIG5ld0NlbnRlciA9IHRvUG9pbnQocGl4ZWxQb2ludC54ICsgZGlmZi54LCBwaXhlbFBvaW50LnkgKyBkaWZmLnkpO1xyXG5cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueCA8IHBhZGRlZEJvdW5kcy5taW4ueCB8fCBwaXhlbFBvaW50LnggPiBwYWRkZWRCb3VuZHMubWF4LngpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueCA9IHBpeGVsQ2VudGVyLnggLSBkaWZmLng7XHJcblx0XHRcdFx0aWYgKGRpZmYueCA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54ICs9IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54IC09IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ0JSLng7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwaXhlbFBvaW50LnkgPCBwYWRkZWRCb3VuZHMubWluLnkgfHwgcGl4ZWxQb2ludC55ID4gcGFkZGVkQm91bmRzLm1heC55KSB7XHJcblx0XHRcdFx0bmV3Q2VudGVyLnkgPSBwaXhlbENlbnRlci55IC0gZGlmZi55O1xyXG5cdFx0XHRcdGlmIChkaWZmLnkgPiAwKSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSArPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSAtPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdCUi55O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KG5ld0NlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IERvbUV2ZW50Lm9mZiA6IERvbUV2ZW50Lm9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG5cdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcblx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBEb21FdmVudC5za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnIHx8IHR5cGUgPT09ICdrZXl1cCcgfHwgdHlwZSA9PT0gJ2tleWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBVdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgVXRpbC5pbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IERvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG5cdH0sXHJcblxyXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcclxuXHJcblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBVdGlsLnN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxudmFyIEVORCA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxufTtcclxudmFyIE1PVkUgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxufTtcclxuXHJcblxyXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChEb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXIncyBwb3NpdGlvbiwgYm9yZGVyIGFuZCBzY2FsZSBkbyBub3QgY2hhbmdlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRyYWcuXHJcblx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcblx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcblx0XHRvZmZzZXQueCAvPSB0aGlzLl9wYXJlbnRTY2FsZS54O1xyXG5cdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4vLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbi8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbi8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxufVxyXG5cclxuLy8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICovXG5cbmV4cG9ydCB7TG9uTGF0fSBmcm9tICcuL1Byb2plY3Rpb24uTG9uTGF0JztcbmV4cG9ydCB7TWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5NZXJjYXRvcic7XG5leHBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge01lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFUFNHMzM5NSA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHNDMyNiA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxuZXhwb3J0IHZhciBTaW1wbGUgPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHByb2plY3Rpb246IExvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcbmltcG9ydCB7RVBTRzMzOTV9IGZyb20gJy4vQ1JTLkVQU0czMzk1JztcbmltcG9ydCB7RVBTRzM4NTcsIEVQU0c5MDA5MTN9IGZyb20gJy4vQ1JTLkVQU0czODU3JztcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4vQ1JTLkVQU0c0MzI2JztcbmltcG9ydCB7U2ltcGxlfSBmcm9tICcuL0NSUy5TaW1wbGUnO1xuXG5DUlMuRWFydGggPSBFYXJ0aDtcbkNSUy5FUFNHMzM5NSA9IEVQU0czMzk1O1xuQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG5DUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG5DUlMuRVBTRzQzMjYgPSBFUFNHNDMyNjtcbkNSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbmV4cG9ydCB7Q1JTfTtcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5tYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG5leHBvcnQgdmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0Ly9cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShncm91cDogTGF5ZXJHcm91cCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG4iLCJcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCFJY29uRGVmYXVsdC5pbWFnZVBhdGgpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cblx0XHRpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoLmluZGV4T2YoJ3VybCcpICE9PSAwKSB7XG5cdFx0XHRwYXRoID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL151cmxcXChbXCInXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lLCBjYW5jZWxBbmltRnJhbWV9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbmV4cG9ydCB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG5cdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG5cdFx0Ly8gV2hlbiB1c2luZyBFUzYgaW1wb3J0cyBpdCBjb3VsZCBub3QgYmUgc2V0IHdoZW4gYFBvcHVwYCB3YXMgbm90IGltcG9ydGVkIGFzIHdlbGxcblx0XHR0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCAmJiB0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCgpO1xuXG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0XHQuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHRcdC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQgY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcclxuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyRHJhZ30gZnJvbSAnLi9NYXJrZXIuRHJhZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNoYWRvd1BhbmU6IFN0cmluZyA9ICdzaGFkb3dQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG5cdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG5cdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1MCwgNTApXHJcblx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcblx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUwLCA1MF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcblx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuXHRcdGF1dG9QYW5TcGVlZDogMTBcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcblx0Z2V0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcblx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdGlmIChNYXJrZXJEcmFnKSB7XHJcblx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG5cdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IE1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2U7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcbiIsImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0YXJlYSA9IHggPSB5ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2pdO1xuXG5cdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcblx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xuXHRcdFx0YXJlYSArPSBmICogMztcblx0XHR9XG5cblx0XHRpZiAoYXJlYSA9PT0gMCkge1xuXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG5cdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhjZW50ZXIpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gUG9seVV0aWwuY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcblx0fVxuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJ9IGZyb20gJy4vbWFya2VyL01hcmtlcic7XHJcbmltcG9ydCB7Q2lyY2xlfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGUnO1xyXG5pbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlTWFya2VyJztcclxuaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi92ZWN0b3IvUG9seWxpbmUnO1xyXG5pbXBvcnQge1BvbHlnb259IGZyb20gJy4vdmVjdG9yL1BvbHlnb24nO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4vLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHQgICAgbGF5ZXJzID0gW10sXHJcblx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRjYXNlICdQb2ludCc6XHJcblx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdQb2x5Z29uJzpcclxuXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGRlZmF1bHQ6XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG5cdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcblx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4vLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbi8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXRsbmdzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuXHRwcmVjaXNpb24gPSB0eXBlb2YgcHJlY2lzaW9uID09PSAnbnVtYmVyJyA/IHByZWNpc2lvbiA6IDY7XHJcblx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbildO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0VXRpbC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcblx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0cHJvcGVydGllczoge30sXHJcblx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdH07XHJcbn1cclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbi8vIEBzZWN0aW9uIE90aGVyIG1ldGhvZHNcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcblBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIG11bHRpID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG5cdC8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG5cdC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbmV4cG9ydCB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBpbWFnZVVybCA9ICdodHRwOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGltYWdlLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIG92ZXJsYXkgbGF5ZXIuXHJcblx0XHR6SW5kZXg6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgnaW1nJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gVXRpbC5iaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG5cdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuZXhwb3J0IHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICpcclxuICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICogSFRNTDUgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIEJyb3dzZXIgY29tcGF0aWJpbGl0eS0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXRcclxuXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG5cdFx0bXV0ZWQ6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpZC5zdHlsZSwgJ29iamVjdEZpdCcpKSB7XHJcblx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcblx0XHR9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IERvbVV0aWwuY3JlYXRlKCdzb3VyY2UnKTtcclxuXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFNWR092ZXJsYXlcbiAqIEBha2EgTC5TVkdPdmVybGF5XG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gKlxuICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAqXG4gKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdGVsLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5leHBvcnQgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIHBvcHVwLlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAocGFyZW50LCBsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSBwYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIHBhcmVudC5fbGF5ZXJzKSB7XHJcblx0XHRcdFx0bGF5ZXIgPSBwYXJlbnQuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRpZiAobGF5ZXIuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0dGhpcy5fc291cmNlID0gbGF5ZXI7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IERvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3BvcHVwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG4iLCJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuZXhwb3J0IHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgZXZlbnRzLlxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChCcm93c2VyLnRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgc3ViWCwgc3ViWSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGg7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUb29sdGlwKSB7XG5cdFx0XHRVdGlsLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9tYXApIHtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHogPSBOdW1iZXIoeik7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdFV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X29uVXBkYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25SZW1vdmVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoTnVtYmVyKHopKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG5cdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG5cdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIGxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXHRcdHJldHVybiBbbncsIHNlXTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChCcm93c2VyLmFuZHJvaWQgJiYgIUJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICdNYXAgZGF0YSAmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL1wiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycywgPGEgaHJlZj1cImh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8yLjAvXCI+Q0MtQlktU0E8L2E+J30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIFV0aWwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG5cdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IFV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxyXG5cdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWRTdG9jaykge1xyXG5cdFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiZXhwb3J0IHtHcmlkTGF5ZXIsIGdyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNU30gZnJvbSAnLi9UaWxlTGF5ZXIuV01TJztcblRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG50aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuZXhwb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn07XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMSxcblxuXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIGNsaWNrIHRvbGVyYW5jZSByb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXBcblx0XHR0b2xlcmFuY2UgOiAwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0XHR0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGlmICghKGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgIT09ICdwcmVjbGljaycpIHx8ICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlja2VkTGF5ZXIpICB7XG5cdFx0XHREb21FdmVudC5mYWtlU3RvcChlKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2xpY2tlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLCBlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fSwgdGhpcyksIDMyKTtcblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSB0aGlzLl9kcmF3TGFzdDtcblx0XHR0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7XG5cblx0XHRvcmRlci5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSBpZiAocHJldikge1xuXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gbnVsbDtcblxuXHRcdG9yZGVyLm5leHQgPSB0aGlzLl9kcmF3Rmlyc3Q7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gY2FudmFzKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5cbmV4cG9ydCB2YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fVxufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuZXhwb3J0IHZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdERvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge3N0YW1wfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtzdmdDcmVhdGUsIHBvaW50c1RvUGF0aH0gZnJvbSAnLi9TVkcuVXRpbCc7XG5leHBvcnQge3BvaW50c1RvUGF0aH07XG5pbXBvcnQge3ZtbE1peGluLCB2bWxDcmVhdGV9IGZyb20gJy4vU1ZHLlZNTCc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlID0gQnJvd3Nlci52bWwgPyB2bWxDcmVhdGUgOiBzdmdDcmVhdGU7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9c3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy56b29tc3RhcnQgPSB0aGlzLl9vblpvb21TdGFydDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSgnZycpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdH0sXG5cblx0X29uWm9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0Ly8gSW4gdGhpcyBjYXNlLCB0aGUgZWFzaWVzdCB3YXkgdG8gcHJldmVudCB0aGlzIGlzIHJlLWRvIHRoZSByZW5kZXJlclxuXHRcdC8vICAgYm91bmRzIGFuZCBwYWRkaW5nIHdoZW4gdGhlIHpvb21pbmcgc3RhcnRzLlxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Y2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge3N2Z30gZnJvbSAnLi9TVkcnO1xuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJlY3RhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJleHBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmV4cG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBjcmVhdGUsIHBvaW50c1RvUGF0aCwgc3ZnfSBmcm9tICcuL1NWRyc7XG5TVkcuY3JlYXRlID0gY3JlYXRlO1xuU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcbmV4cG9ydCB7U1ZHLCBzdmd9O1xuaW1wb3J0ICcuL1JlbmRlcmVyLmdldFJlbmRlcmVyJztcdC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgbmVlZGVkIGJlY2F1c2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbmV4cG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmV4cG9ydCB7Q2lyY2xlTWFya2VyLCBjaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmV4cG9ydCB7Q2lyY2xlLCBjaXJjbGV9IGZyb20gJy4vQ2lyY2xlJztcbmV4cG9ydCB7UG9seWxpbmUsIHBvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmV4cG9ydCB7UG9seWdvbiwgcG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmV4cG9ydCB7UmVjdGFuZ2xlLCByZWN0YW5nbGV9IGZyb20gJy4vUmVjdGFuZ2xlJztcbiIsImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcbmV4cG9ydCB7U1ZHT3ZlcmxheSwgc3ZnT3ZlcmxheX0gZnJvbSAnLi9TVkdPdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBiZSBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRpbmVydGlhOiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7b24sIG9mZiwgc3RvcH0gZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuZXhwb3J0IHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkluc2lkZUJvdW5kcyhtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2Ugd2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBEb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHREb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbmV4cG9ydCB2YXIgVGFwID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZWRvd24nLCBmaXJzdCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZXVwJywgZmlyc3QpO1xuXG5cdFx0XHQvLyBzaW11bGF0ZSBjbGljayBpZiB0aGUgdG91Y2ggZGlkbid0IG1vdmUgdG9vIG11Y2hcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY2xpY2snLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlbW92ZScsIGZpcnN0KTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwOiBIYW5kbGVyXG4vLyBNb2JpbGUgdG91Y2ggaGFja3MgKHF1aWNrIHRhcCBhbmQgdG91Y2ggaG9sZCkgaGFuZGxlci5cbmlmIChCcm93c2VyLnRvdWNoICYmICghQnJvd3Nlci5wb2ludGVyIHx8IEJyb3dzZXIuc2FmYXJpKSkge1xuXHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgVGFwKTtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IHtCb3hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkJveFpvb20nO1xuTWFwLkJveFpvb20gPSBCb3hab29tO1xuaW1wb3J0IHtEb3VibGVDbGlja1pvb219IGZyb20gJy4vaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tJztcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5pbXBvcnQge0RyYWd9IGZyb20gJy4vaGFuZGxlci9NYXAuRHJhZyc7XG5NYXAuRHJhZyA9IERyYWc7XG5pbXBvcnQge0tleWJvYXJkfSBmcm9tICcuL2hhbmRsZXIvTWFwLktleWJvYXJkJztcbk1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuaW1wb3J0IHtTY3JvbGxXaGVlbFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tJztcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5pbXBvcnQge1RhcH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXAnO1xuTWFwLlRhcCA9IFRhcDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH0iLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7IiwiaW1wb3J0ICcuL3N0eWxlLmNzcyc7XG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcbmltcG9ydCAnbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzJztcbi8qIFRoaXMgY29kZSBpcyBuZWVkZWQgdG8gcHJvcGVybHkgbG9hZCB0aGUgaW1hZ2VzIGluIHRoZSBMZWFmbGV0IENTUyAqL1xuZGVsZXRlIEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5fZ2V0SWNvblVybDtcbkwuSWNvbi5EZWZhdWx0Lm1lcmdlT3B0aW9ucyh7XG4gIGljb25SZXRpbmFVcmw6IHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24tMngucG5nJyksXG4gIGljb25Vcmw6IHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nJyksXG4gIHNoYWRvd1VybDogcmVxdWlyZSgnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZycpLFxufSk7XG5cbigndXNlIHN0cmljdCcpO1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IG1vbnRocyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuXG5jb25zdCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm0nKTtcbmNvbnN0IGNvbnRhaW5lcldvcmtvdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLndvcmtvdXRzJyk7XG5jb25zdCBpbnB1dFR5cGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybV9faW5wdXQtLXR5cGUnKTtcbmNvbnN0IGlucHV0RGlzdGFuY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybV9faW5wdXQtLWRpc3RhbmNlJyk7XG5jb25zdCBpbnB1dER1cmF0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm1fX2lucHV0LS1kdXJhdGlvbicpO1xuY29uc3QgaW5wdXRDYWRlbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm1fX2lucHV0LS1jYWRlbmNlJyk7XG5jb25zdCBpbnB1dEVsZXZhdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3JtX19pbnB1dC0tZWxldmF0aW9uJyk7XG5cbmlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHsgbGF0aXR1ZGUgfSA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICAgIGNvbnN0IHsgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgICBjb25zb2xlLmxvZyhgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL0Ake2xhdGl0dWRlfSwke2xvbmdpdHVkZX1gKTtcbiAgICAgIGNvbnN0IG1hcCA9IEwubWFwKCdtYXAnKS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgMTMpO1xuXG4gICAgICBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICAgIGF0dHJpYnV0aW9uOlxuICAgICAgICAgICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycycsXG4gICAgICB9KS5hZGRUbyhtYXApO1xuXG4gICAgICBMLm1hcmtlcihbMzQuNDM1NDQsIDMyLjg5ODZdKVxuICAgICAgICAuYWRkVG8obWFwKVxuICAgICAgICAuYmluZFBvcHVwKCdBIHByZXR0eSBDU1MzIHBvcHVwLjxicj4gRWFzaWx5IGN1c3RvbWl6YWJsZS4nKVxuICAgICAgICAub3BlblBvcHVwKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBhbGVydCgnbm8gbG9jYXRpb24nKTtcbiAgICB9XG4gICk7XG59XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwiZGVzdCIsImkiLCJqIiwibGVuIiwic3JjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY3JlYXRlIiwiT2JqZWN0IiwiRiIsInByb3RvIiwicHJvdG90eXBlIiwiYmluZCIsImZuIiwib2JqIiwic2xpY2UiLCJBcnJheSIsImFwcGx5IiwiY2FsbCIsImFyZ3MiLCJjb25jYXQiLCJsYXN0SWQiLCJzdGFtcCIsIl9sZWFmbGV0X2lkIiwidGhyb3R0bGUiLCJ0aW1lIiwiY29udGV4dCIsImxvY2siLCJ3cmFwcGVyRm4iLCJsYXRlciIsInNldFRpbWVvdXQiLCJ3cmFwTnVtIiwieCIsInJhbmdlIiwiaW5jbHVkZU1heCIsIm1heCIsIm1pbiIsImQiLCJmYWxzZUZuIiwiZm9ybWF0TnVtIiwibnVtIiwiZGlnaXRzIiwicG93IiwiTWF0aCIsInVuZGVmaW5lZCIsInJvdW5kIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJzcGxpdFdvcmRzIiwic3BsaXQiLCJzZXRPcHRpb25zIiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiZ2V0UGFyYW1TdHJpbmciLCJleGlzdGluZ1VybCIsInVwcGVyY2FzZSIsInBhcmFtcyIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJqb2luIiwidGVtcGxhdGVSZSIsInRlbXBsYXRlIiwiZGF0YSIsImtleSIsInZhbHVlIiwiRXJyb3IiLCJpc0FycmF5IiwidG9TdHJpbmciLCJhcnJheSIsImVsIiwiZW1wdHlJbWFnZVVybCIsImdldFByZWZpeGVkIiwibmFtZSIsIndpbmRvdyIsImxhc3RUaW1lIiwidGltZW91dERlZmVyIiwiRGF0ZSIsInRpbWVUb0NhbGwiLCJyZXF1ZXN0Rm4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxGbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbUZyYW1lIiwiaW1tZWRpYXRlIiwiY2FuY2VsQW5pbUZyYW1lIiwiQ2xhc3MiLCJwcm9wcyIsIk5ld0NsYXNzIiwiaW5pdGlhbGl6ZSIsImNhbGxJbml0SG9va3MiLCJwYXJlbnRQcm90byIsIl9fc3VwZXJfXyIsIlV0aWwuY3JlYXRlIiwiY29uc3RydWN0b3IiLCJzdGF0aWNzIiwiVXRpbC5leHRlbmQiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJpbmNsdWRlIiwibWVyZ2VPcHRpb25zIiwiYWRkSW5pdEhvb2siLCJpbml0IiwiTCIsIk1peGluIiwiVXRpbC5pc0FycmF5IiwiRXZlbnRzIiwiY29uc29sZSIsIndhcm4iLCJzdGFjayIsIm9uIiwidHlwZXMiLCJ0eXBlIiwiX29uIiwiVXRpbC5zcGxpdFdvcmRzIiwib2ZmIiwiX2V2ZW50cyIsIl9vZmYiLCJ0eXBlTGlzdGVuZXJzIiwibmV3TGlzdGVuZXIiLCJjdHgiLCJsaXN0ZW5lcnMiLCJVdGlsLmZhbHNlRm4iLCJsIiwiX2ZpcmluZ0NvdW50Iiwic3BsaWNlIiwiZmlyZSIsInByb3BhZ2F0ZSIsImxpc3RlbnMiLCJldmVudCIsInRhcmdldCIsInNvdXJjZVRhcmdldCIsIl9wcm9wYWdhdGVFdmVudCIsIl9ldmVudFBhcmVudHMiLCJvbmNlIiwiaGFuZGxlciIsIlV0aWwuYmluZCIsImFkZEV2ZW50UGFyZW50IiwiVXRpbC5zdGFtcCIsInJlbW92ZUV2ZW50UGFyZW50IiwiZSIsImxheWVyIiwicHJvcGFnYXRlZEZyb20iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMiLCJhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciIsImZpcmVFdmVudCIsImhhc0V2ZW50TGlzdGVuZXJzIiwiRXZlbnRlZCIsIlBvaW50IiwieSIsInRydW5jIiwidiIsImZsb29yIiwiY2VpbCIsImNsb25lIiwiYWRkIiwicG9pbnQiLCJfYWRkIiwidG9Qb2ludCIsInN1YnRyYWN0IiwiX3N1YnRyYWN0IiwiZGl2aWRlQnkiLCJfZGl2aWRlQnkiLCJtdWx0aXBseUJ5IiwiX211bHRpcGx5QnkiLCJzY2FsZUJ5IiwidW5zY2FsZUJ5IiwiX3JvdW5kIiwiX2Zsb29yIiwiX2NlaWwiLCJfdHJ1bmMiLCJkaXN0YW5jZVRvIiwic3FydCIsImVxdWFscyIsImNvbnRhaW5zIiwiYWJzIiwiQm91bmRzIiwiYSIsImIiLCJwb2ludHMiLCJnZXRDZW50ZXIiLCJnZXRCb3R0b21MZWZ0IiwiZ2V0VG9wUmlnaHQiLCJnZXRUb3BMZWZ0IiwiZ2V0Qm90dG9tUmlnaHQiLCJnZXRTaXplIiwidG9Cb3VuZHMiLCJpbnRlcnNlY3RzIiwiYm91bmRzIiwibWluMiIsIm1heDIiLCJ4SW50ZXJzZWN0cyIsInlJbnRlcnNlY3RzIiwib3ZlcmxhcHMiLCJ4T3ZlcmxhcHMiLCJ5T3ZlcmxhcHMiLCJpc1ZhbGlkIiwiTGF0TG5nQm91bmRzIiwiY29ybmVyMSIsImNvcm5lcjIiLCJsYXRsbmdzIiwic3ciLCJfc291dGhXZXN0IiwibmUiLCJfbm9ydGhFYXN0Iiwic3cyIiwibmUyIiwiTGF0TG5nIiwidG9MYXRMbmciLCJ0b0xhdExuZ0JvdW5kcyIsImxhdCIsImxuZyIsInBhZCIsImJ1ZmZlclJhdGlvIiwiaGVpZ2h0QnVmZmVyIiwid2lkdGhCdWZmZXIiLCJnZXRTb3V0aFdlc3QiLCJnZXROb3J0aEVhc3QiLCJnZXROb3J0aFdlc3QiLCJnZXROb3J0aCIsImdldFdlc3QiLCJnZXRTb3V0aEVhc3QiLCJnZXRTb3V0aCIsImdldEVhc3QiLCJsYXRJbnRlcnNlY3RzIiwibG5nSW50ZXJzZWN0cyIsImxhdE92ZXJsYXBzIiwibG5nT3ZlcmxhcHMiLCJ0b0JCb3hTdHJpbmciLCJtYXhNYXJnaW4iLCJhbHQiLCJpc05hTiIsIm1hcmdpbiIsInByZWNpc2lvbiIsIlV0aWwuZm9ybWF0TnVtIiwib3RoZXIiLCJFYXJ0aCIsImRpc3RhbmNlIiwid3JhcCIsIndyYXBMYXRMbmciLCJzaXplSW5NZXRlcnMiLCJsYXRBY2N1cmFjeSIsImxuZ0FjY3VyYWN5IiwiY29zIiwiUEkiLCJjIiwibG9uIiwiQ1JTIiwibGF0TG5nVG9Qb2ludCIsImxhdGxuZyIsInpvb20iLCJwcm9qZWN0ZWRQb2ludCIsInByb2plY3Rpb24iLCJwcm9qZWN0Iiwic2NhbGUiLCJ0cmFuc2Zvcm1hdGlvbiIsIl90cmFuc2Zvcm0iLCJwb2ludFRvTGF0TG5nIiwidW50cmFuc2Zvcm1lZFBvaW50IiwidW50cmFuc2Zvcm0iLCJ1bnByb2plY3QiLCJsb2ciLCJMTjIiLCJnZXRQcm9qZWN0ZWRCb3VuZHMiLCJpbmZpbml0ZSIsInMiLCJ0cmFuc2Zvcm0iLCJ3cmFwTG5nIiwiVXRpbC53cmFwTnVtIiwid3JhcExhdCIsIndyYXBMYXRMbmdCb3VuZHMiLCJjZW50ZXIiLCJuZXdDZW50ZXIiLCJsYXRTaGlmdCIsImxuZ1NoaWZ0IiwibmV3U3ciLCJuZXdOZSIsIlIiLCJsYXRsbmcxIiwibGF0bG5nMiIsInJhZCIsImxhdDEiLCJsYXQyIiwic2luRExhdCIsInNpbiIsInNpbkRMb24iLCJhdGFuMiIsImVhcnRoUmFkaXVzIiwiU3BoZXJpY2FsTWVyY2F0b3IiLCJNQVhfTEFUSVRVREUiLCJhdGFuIiwiZXhwIiwiVHJhbnNmb3JtYXRpb24iLCJfYSIsIl9iIiwiX2MiLCJfZCIsInRvVHJhbnNmb3JtYXRpb24iLCJFUFNHMzg1NyIsImNvZGUiLCJFUFNHOTAwOTEzIiwic3ZnQ3JlYXRlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJwb2ludHNUb1BhdGgiLCJyaW5ncyIsImNsb3NlZCIsImxlbjIiLCJwIiwiQnJvd3Nlci5zdmciLCJzdHlsZSIsImRvY3VtZW50RWxlbWVudCIsImllIiwiaWVsdDkiLCJlZGdlIiwibmF2aWdhdG9yIiwid2Via2l0IiwidXNlckFnZW50Q29udGFpbnMiLCJhbmRyb2lkIiwiYW5kcm9pZDIzIiwid2Via2l0VmVyIiwicGFyc2VJbnQiLCJleGVjIiwidXNlckFnZW50IiwiYW5kcm9pZFN0b2NrIiwib3BlcmEiLCJjaHJvbWUiLCJnZWNrbyIsInNhZmFyaSIsInBoYW50b20iLCJvcGVyYTEyIiwid2luIiwicGxhdGZvcm0iLCJpZTNkIiwid2Via2l0M2QiLCJXZWJLaXRDU1NNYXRyaXgiLCJnZWNrbzNkIiwiYW55M2QiLCJMX0RJU0FCTEVfM0QiLCJtb2JpbGUiLCJvcmllbnRhdGlvbiIsIm1vYmlsZVdlYmtpdCIsIm1vYmlsZVdlYmtpdDNkIiwibXNQb2ludGVyIiwiUG9pbnRlckV2ZW50IiwiTVNQb2ludGVyRXZlbnQiLCJwb2ludGVyIiwidG91Y2giLCJMX05PX1RPVUNIIiwiRG9jdW1lbnRUb3VjaCIsIm1vYmlsZU9wZXJhIiwibW9iaWxlR2Vja28iLCJyZXRpbmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwicGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZU9wdGlvbiIsIm9wdHMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImNhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0Iiwic3ZnIiwiY3JlYXRlU1ZHUmVjdCIsInZtbCIsImRpdiIsImlubmVySFRNTCIsInNoYXBlIiwiZmlyc3RDaGlsZCIsImJlaGF2aW9yIiwiYWRqIiwidG9Mb3dlckNhc2UiLCJQT0lOVEVSX0RPV04iLCJCcm93c2VyLm1zUG9pbnRlciIsIlBPSU5URVJfTU9WRSIsIlBPSU5URVJfVVAiLCJQT0lOVEVSX0NBTkNFTCIsIl9wb2ludGVycyIsIl9wb2ludGVyRG9jTGlzdGVuZXIiLCJhZGRQb2ludGVyTGlzdGVuZXIiLCJfYWRkUG9pbnRlclN0YXJ0IiwiX2FkZFBvaW50ZXJNb3ZlIiwiX2FkZFBvaW50ZXJFbmQiLCJyZW1vdmVQb2ludGVyTGlzdGVuZXIiLCJvbkRvd24iLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsInBvaW50ZXJUeXBlIiwiRG9tRXZlbnQucHJldmVudERlZmF1bHQiLCJfaGFuZGxlUG9pbnRlciIsIl9nbG9iYWxQb2ludGVyRG93biIsIl9nbG9iYWxQb2ludGVyTW92ZSIsIl9nbG9iYWxQb2ludGVyVXAiLCJwb2ludGVySWQiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJvbk1vdmUiLCJNU1BPSU5URVJfVFlQRV9NT1VTRSIsImJ1dHRvbnMiLCJvblVwIiwiX3RvdWNoc3RhcnQiLCJCcm93c2VyLnBvaW50ZXIiLCJfdG91Y2hlbmQiLCJfcHJlIiwiYWRkRG91YmxlVGFwTGlzdGVuZXIiLCJsYXN0IiwiZG91YmxlVGFwIiwiZGVsYXkiLCJvblRvdWNoU3RhcnQiLCJpc1ByaW1hcnkiLCJub3ciLCJkZWx0YSIsIm9uVG91Y2hFbmQiLCJjYW5jZWxCdWJibGUiLCJuZXdUb3VjaCIsInByb3AiLCJidXR0b24iLCJCcm93c2VyLnBhc3NpdmVFdmVudHMiLCJwYXNzaXZlIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJ0b3VjaHN0YXJ0IiwidG91Y2hlbmQiLCJkYmxjbGljayIsIlRSQU5TRk9STSIsInRlc3RQcm9wIiwiVFJBTlNJVElPTiIsIlRSQU5TSVRJT05fRU5EIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRhZ05hbWUiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInJlbW92ZSIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVtcHR5IiwidG9Gcm9udCIsImxhc3RDaGlsZCIsInRvQmFjayIsImluc2VydEJlZm9yZSIsImhhc0NsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0Q2xhc3MiLCJSZWdFeHAiLCJ0ZXN0IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwic2V0Q2xhc3MiLCJyZW1vdmVDbGFzcyIsIlV0aWwudHJpbSIsImJhc2VWYWwiLCJjb3JyZXNwb25kaW5nRWxlbWVudCIsInNldE9wYWNpdHkiLCJvcGFjaXR5IiwiX3NldE9wYWNpdHlJRSIsImZpbHRlciIsImZpbHRlck5hbWUiLCJmaWx0ZXJzIiwiaXRlbSIsIkVuYWJsZWQiLCJPcGFjaXR5Iiwic2V0VHJhbnNmb3JtIiwib2Zmc2V0IiwicG9zIiwiQnJvd3Nlci5pZTNkIiwic2V0UG9zaXRpb24iLCJfbGVhZmxldF9wb3MiLCJCcm93c2VyLmFueTNkIiwibGVmdCIsInRvcCIsImdldFBvc2l0aW9uIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiX3VzZXJTZWxlY3QiLCJEb21FdmVudC5vbiIsIkRvbUV2ZW50Lm9mZiIsInVzZXJTZWxlY3RQcm9wZXJ0eSIsImRpc2FibGVJbWFnZURyYWciLCJlbmFibGVJbWFnZURyYWciLCJfb3V0bGluZUVsZW1lbnQiLCJfb3V0bGluZVN0eWxlIiwicHJldmVudE91dGxpbmUiLCJlbGVtZW50IiwidGFiSW5kZXgiLCJyZXN0b3JlT3V0bGluZSIsIm91dGxpbmUiLCJnZXRTaXplZFBhcmVudE5vZGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImJvZHkiLCJnZXRTY2FsZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kaW5nQ2xpZW50UmVjdCIsImFkZE9uZSIsImV2ZW50c0tleSIsInJlbW92ZU9uZSIsImJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5zYWZhcmkiLCJtb3VzZVN1YnN0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJ3aGVlbCIsIm9yaWdpbmFsSGFuZGxlciIsIkJyb3dzZXIudG91Y2giLCJpc0V4dGVybmFsVGFyZ2V0IiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdpbmFsRXZlbnQiLCJfc3RvcHBlZCIsInNraXBwZWQiLCJkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsImZha2VTdG9wIiwicHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsInN0b3AiLCJnZXRNb3VzZVBvc2l0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwid2hlZWxQeEZhY3RvciIsIkJyb3dzZXIud2luIiwiQnJvd3Nlci5jaHJvbWUiLCJCcm93c2VyLmdlY2tvIiwiZ2V0V2hlZWxEZWx0YSIsIndoZWVsRGVsdGFZIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwiZGVsdGFaIiwid2hlZWxEZWx0YSIsImRldGFpbCIsInNraXBFdmVudHMiLCJldmVudHMiLCJyZWxhdGVkIiwicmVsYXRlZFRhcmdldCIsImVyciIsIlBvc0FuaW1hdGlvbiIsInJ1biIsIm5ld1BvcyIsImR1cmF0aW9uIiwiZWFzZUxpbmVhcml0eSIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9zdGFydFBvcyIsIkRvbVV0aWwuZ2V0UG9zaXRpb24iLCJfb2Zmc2V0IiwiX3N0YXJ0VGltZSIsIl9hbmltYXRlIiwiX3N0ZXAiLCJfY29tcGxldGUiLCJfYW5pbUlkIiwiVXRpbC5yZXF1ZXN0QW5pbUZyYW1lIiwiZWxhcHNlZCIsIl9ydW5GcmFtZSIsIl9lYXNlT3V0IiwicHJvZ3Jlc3MiLCJEb21VdGlsLnNldFBvc2l0aW9uIiwiVXRpbC5jYW5jZWxBbmltRnJhbWUiLCJ0IiwiTWFwIiwiY3JzIiwibWluWm9vbSIsIm1heFpvb20iLCJsYXllcnMiLCJtYXhCb3VuZHMiLCJyZW5kZXJlciIsInpvb21BbmltYXRpb24iLCJ6b29tQW5pbWF0aW9uVGhyZXNob2xkIiwiZmFkZUFuaW1hdGlvbiIsIm1hcmtlclpvb21BbmltYXRpb24iLCJ0cmFuc2Zvcm0zRExpbWl0Iiwiem9vbVNuYXAiLCJ6b29tRGVsdGEiLCJ0cmFja1Jlc2l6ZSIsIlV0aWwuc2V0T3B0aW9ucyIsIl9oYW5kbGVycyIsIl9sYXllcnMiLCJfem9vbUJvdW5kTGF5ZXJzIiwiX3NpemVDaGFuZ2VkIiwiX2luaXRDb250YWluZXIiLCJfaW5pdExheW91dCIsIl9vblJlc2l6ZSIsIl9pbml0RXZlbnRzIiwic2V0TWF4Qm91bmRzIiwiX3pvb20iLCJfbGltaXRab29tIiwic2V0VmlldyIsInJlc2V0IiwiX3pvb21BbmltYXRlZCIsIkRvbVV0aWwuVFJBTlNJVElPTiIsIkJyb3dzZXIubW9iaWxlT3BlcmEiLCJfY3JlYXRlQW5pbVByb3h5IiwiX3Byb3h5IiwiRG9tVXRpbC5UUkFOU0lUSU9OX0VORCIsIl9jYXRjaFRyYW5zaXRpb25FbmQiLCJfYWRkTGF5ZXJzIiwiX2xpbWl0Q2VudGVyIiwiX3N0b3AiLCJfbG9hZGVkIiwiYW5pbWF0ZSIsInBhbiIsIm1vdmVkIiwiX3RyeUFuaW1hdGVkWm9vbSIsIl90cnlBbmltYXRlZFBhbiIsIl9zaXplVGltZXIiLCJfcmVzZXRWaWV3Iiwic2V0Wm9vbSIsInpvb21JbiIsInpvb21PdXQiLCJzZXRab29tQXJvdW5kIiwiZ2V0Wm9vbVNjYWxlIiwidmlld0hhbGYiLCJjb250YWluZXJQb2ludCIsImxhdExuZ1RvQ29udGFpbmVyUG9pbnQiLCJjZW50ZXJPZmZzZXQiLCJjb250YWluZXJQb2ludFRvTGF0TG5nIiwiX2dldEJvdW5kc0NlbnRlclpvb20iLCJnZXRCb3VuZHMiLCJwYWRkaW5nVEwiLCJwYWRkaW5nVG9wTGVmdCIsInBhZGRpbmciLCJwYWRkaW5nQlIiLCJwYWRkaW5nQm90dG9tUmlnaHQiLCJnZXRCb3VuZHNab29tIiwiSW5maW5pdHkiLCJwYWRkaW5nT2Zmc2V0Iiwic3dQb2ludCIsIm5lUG9pbnQiLCJmaXRCb3VuZHMiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJnZXRab29tIiwiX3BhbkFuaW0iLCJfb25QYW5UcmFuc2l0aW9uU3RlcCIsIl9vblBhblRyYW5zaXRpb25FbmQiLCJub01vdmVTdGFydCIsIkRvbVV0aWwuYWRkQ2xhc3MiLCJfbWFwUGFuZSIsIl9nZXRNYXBQYW5lUG9zIiwiX3Jhd1BhbkJ5IiwiZmx5VG8iLCJ0YXJnZXRDZW50ZXIiLCJ0YXJnZXRab29tIiwiZnJvbSIsInRvIiwic2l6ZSIsInN0YXJ0Wm9vbSIsIncwIiwidzEiLCJ1MSIsInJobyIsInJobzIiLCJyIiwiczEiLCJzMiIsInQxIiwiYjEiLCJzcSIsInNpbmgiLCJuIiwiY29zaCIsInRhbmgiLCJyMCIsInciLCJ1IiwiZWFzZU91dCIsInN0YXJ0IiwiUyIsImZyYW1lIiwiX2ZseVRvRnJhbWUiLCJfbW92ZSIsImdldFNjYWxlWm9vbSIsIl9tb3ZlRW5kIiwiX21vdmVTdGFydCIsImZseVRvQm91bmRzIiwiX3Bhbkluc2lkZU1heEJvdW5kcyIsInNldE1pblpvb20iLCJvbGRab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJwYW5JbnNpZGUiLCJwaXhlbENlbnRlciIsInBpeGVsUG9pbnQiLCJwaXhlbEJvdW5kcyIsImdldFBpeGVsQm91bmRzIiwiaGFsZlBpeGVsQm91bmRzIiwicGFkZGVkQm91bmRzIiwiZGlmZiIsImludmFsaWRhdGVTaXplIiwib2xkU2l6ZSIsIl9sYXN0Q2VudGVyIiwibmV3U2l6ZSIsIm9sZENlbnRlciIsImRlYm91bmNlTW92ZWVuZCIsImxvY2F0ZSIsIl9sb2NhdGVPcHRpb25zIiwidGltZW91dCIsIndhdGNoIiwiX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IiLCJtZXNzYWdlIiwib25SZXNwb25zZSIsIl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlIiwib25FcnJvciIsIl9sb2NhdGlvbldhdGNoSWQiLCJnZW9sb2NhdGlvbiIsIndhdGNoUG9zaXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJzdG9wTG9jYXRlIiwiY2xlYXJXYXRjaCIsImVycm9yIiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJhY2N1cmFjeSIsInRpbWVzdGFtcCIsImFkZEhhbmRsZXIiLCJIYW5kbGVyQ2xhc3MiLCJlbmFibGUiLCJfY29udGFpbmVySWQiLCJfY29udGFpbmVyIiwiRG9tVXRpbC5yZW1vdmUiLCJfY2xlYXJDb250cm9sUG9zIiwiX3Jlc2l6ZVJlcXVlc3QiLCJfY2xlYXJIYW5kbGVycyIsIl9wYW5lcyIsIl9yZW5kZXJlciIsImNyZWF0ZVBhbmUiLCJwYW5lIiwiRG9tVXRpbC5jcmVhdGUiLCJfY2hlY2tJZkxvYWRlZCIsIl9tb3ZlZCIsImxheWVyUG9pbnRUb0xhdExuZyIsIl9nZXRDZW50ZXJMYXllclBvaW50IiwiZ2V0TWluWm9vbSIsIl9sYXllcnNNaW5ab29tIiwiZ2V0TWF4Wm9vbSIsIl9sYXllcnNNYXhab29tIiwiaW5zaWRlIiwibnciLCJzZSIsImJvdW5kc1NpemUiLCJzbmFwIiwic2NhbGV4Iiwic2NhbGV5IiwiX3NpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInRvcExlZnRQb2ludCIsIl9nZXRUb3BMZWZ0UG9pbnQiLCJnZXRQaXhlbE9yaWdpbiIsIl9waXhlbE9yaWdpbiIsImdldFBpeGVsV29ybGRCb3VuZHMiLCJnZXRQYW5lIiwiZ2V0UGFuZXMiLCJnZXRDb250YWluZXIiLCJ0b1pvb20iLCJmcm9tWm9vbSIsImxhdExuZ1RvTGF5ZXJQb2ludCIsImNvbnRhaW5lclBvaW50VG9MYXllclBvaW50IiwibGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQiLCJsYXllclBvaW50IiwibW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQiLCJEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uIiwibW91c2VFdmVudFRvTGF5ZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xhdExuZyIsIkRvbVV0aWwuZ2V0IiwiX29uU2Nyb2xsIiwiX2ZhZGVBbmltYXRlZCIsIkJyb3dzZXIucmV0aW5hIiwiQnJvd3Nlci5pZWx0OSIsInBvc2l0aW9uIiwiRG9tVXRpbC5nZXRTdHlsZSIsIl9pbml0UGFuZXMiLCJfaW5pdENvbnRyb2xQb3MiLCJwYW5lcyIsIl9wYW5lUmVuZGVyZXJzIiwibWFya2VyUGFuZSIsInNoYWRvd1BhbmUiLCJsb2FkaW5nIiwiem9vbUNoYW5nZWQiLCJfZ2V0TmV3UGl4ZWxPcmlnaW4iLCJwaW5jaCIsIl9nZXRab29tU3BhbiIsIl90YXJnZXRzIiwib25PZmYiLCJfaGFuZGxlRE9NRXZlbnQiLCJfb25Nb3ZlRW5kIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIl9maW5kRXZlbnRUYXJnZXRzIiwidGFyZ2V0cyIsImlzSG92ZXIiLCJzcmNFbGVtZW50IiwiZHJhZ2dpbmciLCJfc2ltdWxhdGVkIiwiX2RyYWdnYWJsZU1vdmVkIiwiRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldCIsIkRvbUV2ZW50LnNraXBwZWQiLCJEb21VdGlsLnByZXZlbnRPdXRsaW5lIiwiX2ZpcmVET01FdmVudCIsIl9tb3VzZUV2ZW50cyIsInN5bnRoIiwiaXNNYXJrZXIiLCJnZXRMYXRMbmciLCJfcmFkaXVzIiwiYnViYmxpbmdNb3VzZUV2ZW50cyIsIlV0aWwuaW5kZXhPZiIsImVuYWJsZWQiLCJib3hab29tIiwiZGlzYWJsZSIsIndoZW5SZWFkeSIsImNhbGxiYWNrIiwicGl4ZWxPcmlnaW4iLCJfbGF0TG5nVG9OZXdMYXllclBvaW50IiwidG9wTGVmdCIsIl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzIiwibGF0TG5nQm91bmRzIiwiX2dldENlbnRlck9mZnNldCIsImNlbnRlclBvaW50Iiwidmlld0JvdW5kcyIsIl9nZXRCb3VuZHNPZmZzZXQiLCJfbGltaXRPZmZzZXQiLCJuZXdCb3VuZHMiLCJweEJvdW5kcyIsInByb2plY3RlZE1heEJvdW5kcyIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImR4IiwiX3JlYm91bmQiLCJkeSIsInJpZ2h0IiwiRG9tVXRpbC5yZW1vdmVDbGFzcyIsInByb3h5IiwibWFwUGFuZSIsIkRvbVV0aWwuVFJBTlNGT1JNIiwiRG9tVXRpbC5zZXRUcmFuc2Zvcm0iLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwiX2FuaW1Nb3ZlRW5kIiwiX2Rlc3Ryb3lBbmltUHJveHkiLCJ6IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJjcmVhdGVNYXAiLCJDb250cm9sIiwibWFwIiwiX21hcCIsInJlbW92ZUNvbnRyb2wiLCJhZGRDb250cm9sIiwiYWRkVG8iLCJvbkFkZCIsImNvcm5lciIsIl9jb250cm9sQ29ybmVycyIsIm9uUmVtb3ZlIiwiX3JlZm9jdXNPbk1hcCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZm9jdXMiLCJjb250cm9sIiwiY29ybmVycyIsIl9jb250cm9sQ29udGFpbmVyIiwiY3JlYXRlQ29ybmVyIiwidlNpZGUiLCJoU2lkZSIsIkxheWVycyIsImNvbGxhcHNlZCIsImF1dG9aSW5kZXgiLCJoaWRlU2luZ2xlQmFzZSIsInNvcnRMYXllcnMiLCJzb3J0RnVuY3Rpb24iLCJsYXllckEiLCJsYXllckIiLCJuYW1lQSIsIm5hbWVCIiwiYmFzZUxheWVycyIsIm92ZXJsYXlzIiwiX2xheWVyQ29udHJvbElucHV0cyIsIl9sYXN0WkluZGV4IiwiX2hhbmRsaW5nQ2xpY2siLCJfYWRkTGF5ZXIiLCJfdXBkYXRlIiwiX2NoZWNrRGlzYWJsZWRMYXllcnMiLCJfb25MYXllckNoYW5nZSIsIl9leHBhbmRJZk5vdENvbGxhcHNlZCIsImFkZEJhc2VMYXllciIsImFkZE92ZXJsYXkiLCJyZW1vdmVMYXllciIsIl9nZXRMYXllciIsImV4cGFuZCIsIl9zZWN0aW9uIiwiYWNjZXB0YWJsZUhlaWdodCIsIm9mZnNldFRvcCIsImNvbGxhcHNlIiwic2V0QXR0cmlidXRlIiwiRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24iLCJEb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJzZWN0aW9uIiwiQnJvd3Nlci5hbmRyb2lkIiwibGluayIsIl9sYXllcnNMaW5rIiwiaHJlZiIsInRpdGxlIiwiRG9tRXZlbnQuc3RvcCIsIl9iYXNlTGF5ZXJzTGlzdCIsIl9zZXBhcmF0b3IiLCJfb3ZlcmxheXNMaXN0Iiwib3ZlcmxheSIsInNvcnQiLCJzZXRaSW5kZXgiLCJEb21VdGlsLmVtcHR5IiwiYmFzZUxheWVyc1ByZXNlbnQiLCJvdmVybGF5c1ByZXNlbnQiLCJiYXNlTGF5ZXJzQ291bnQiLCJfYWRkSXRlbSIsImRpc3BsYXkiLCJfY3JlYXRlUmFkaW9FbGVtZW50IiwiY2hlY2tlZCIsInJhZGlvSHRtbCIsInJhZGlvRnJhZ21lbnQiLCJsYWJlbCIsImhhc0xheWVyIiwiaW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsImxheWVySWQiLCJfb25JbnB1dENsaWNrIiwiaG9sZGVyIiwiaW5wdXRzIiwiYWRkZWRMYXllcnMiLCJyZW1vdmVkTGF5ZXJzIiwiYWRkTGF5ZXIiLCJkaXNhYmxlZCIsIl9leHBhbmQiLCJfY29sbGFwc2UiLCJab29tIiwiem9vbUluVGV4dCIsInpvb21JblRpdGxlIiwiem9vbU91dFRleHQiLCJ6b29tT3V0VGl0bGUiLCJ6b29tTmFtZSIsIl96b29tSW5CdXR0b24iLCJfY3JlYXRlQnV0dG9uIiwiX3pvb21JbiIsIl96b29tT3V0QnV0dG9uIiwiX3pvb21PdXQiLCJfdXBkYXRlRGlzYWJsZWQiLCJfZGlzYWJsZWQiLCJzaGlmdEtleSIsImh0bWwiLCJ6b29tQ29udHJvbCIsIlNjYWxlIiwibWF4V2lkdGgiLCJtZXRyaWMiLCJpbXBlcmlhbCIsIl9hZGRTY2FsZXMiLCJ1cGRhdGVXaGVuSWRsZSIsIl9tU2NhbGUiLCJfaVNjYWxlIiwibWF4TWV0ZXJzIiwiX3VwZGF0ZVNjYWxlcyIsIl91cGRhdGVNZXRyaWMiLCJfdXBkYXRlSW1wZXJpYWwiLCJtZXRlcnMiLCJfZ2V0Um91bmROdW0iLCJfdXBkYXRlU2NhbGUiLCJtYXhGZWV0IiwibWF4TWlsZXMiLCJtaWxlcyIsImZlZXQiLCJ0ZXh0IiwicmF0aW8iLCJwb3cxMCIsIkF0dHJpYnV0aW9uIiwicHJlZml4IiwiX2F0dHJpYnV0aW9ucyIsImF0dHJpYnV0aW9uQ29udHJvbCIsImdldEF0dHJpYnV0aW9uIiwiYWRkQXR0cmlidXRpb24iLCJzZXRQcmVmaXgiLCJyZW1vdmVBdHRyaWJ1dGlvbiIsImF0dHJpYnMiLCJwcmVmaXhBbmRBdHRyaWJzIiwiYXR0cmlidXRpb24iLCJIYW5kbGVyIiwiX2VuYWJsZWQiLCJhZGRIb29rcyIsInJlbW92ZUhvb2tzIiwiU1RBUlQiLCJFTkQiLCJtb3VzZWRvd24iLCJwb2ludGVyZG93biIsIk1TUG9pbnRlckRvd24iLCJNT1ZFIiwiRHJhZ2dhYmxlIiwiY2xpY2tUb2xlcmFuY2UiLCJkcmFnU3RhcnRUYXJnZXQiLCJfZWxlbWVudCIsIl9kcmFnU3RhcnRUYXJnZXQiLCJfcHJldmVudE91dGxpbmUiLCJfb25Eb3duIiwiX2RyYWdnaW5nIiwiZmluaXNoRHJhZyIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJ3aGljaCIsIkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyIsIkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJfbW92aW5nIiwiZmlyc3QiLCJzaXplZFBhcmVudCIsIkRvbVV0aWwuZ2V0U2l6ZWRQYXJlbnROb2RlIiwiX3N0YXJ0UG9pbnQiLCJfcGFyZW50U2NhbGUiLCJEb21VdGlsLmdldFNjYWxlIiwiX29uTW92ZSIsIl9vblVwIiwiX2xhc3RUYXJnZXQiLCJTVkdFbGVtZW50SW5zdGFuY2UiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIl9uZXdQb3MiLCJfYW5pbVJlcXVlc3QiLCJfbGFzdEV2ZW50IiwiX3VwZGF0ZVBvc2l0aW9uIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJzaW1wbGlmeSIsInRvbGVyYW5jZSIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsInAxIiwicDIiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJBcnJheUNvbnN0cnVjdG9yIiwiVWludDhBcnJheSIsIm1hcmtlcnMiLCJfc2ltcGxpZnlEUFN0ZXAiLCJuZXdQb2ludHMiLCJtYXhTcURpc3QiLCJpbmRleCIsInNxRGlzdCIsInJlZHVjZWRQb2ludHMiLCJwcmV2IiwiX3NxRGlzdCIsIl9sYXN0Q29kZSIsImNsaXBTZWdtZW50IiwidXNlTGFzdENvZGUiLCJjb2RlQSIsIl9nZXRCaXRDb2RlIiwiY29kZUIiLCJjb2RlT3V0IiwibmV3Q29kZSIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwiZG90IiwiaXNGbGF0IiwiX2ZsYXQiLCJjbGlwUG9seWdvbiIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsImsiLCJfY29kZSIsIkxpbmVVdGlsLl9nZXRCaXRDb2RlIiwiTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24iLCJMb25MYXQiLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJFUFNHMzM5NSIsIkVQU0c0MzI2IiwiU2ltcGxlIiwiTGF5ZXIiLCJyZW1vdmVGcm9tIiwiX21hcFRvQWRkIiwiYWRkSW50ZXJhY3RpdmVUYXJnZXQiLCJ0YXJnZXRFbCIsInJlbW92ZUludGVyYWN0aXZlVGFyZ2V0IiwiX2xheWVyQWRkIiwiZ2V0RXZlbnRzIiwiYmVmb3JlQWRkIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImludm9rZSIsIm1ldGhvZE5hbWUiLCJnZXRMYXllciIsImdldExheWVycyIsInpJbmRleCIsImxheWVyR3JvdXAiLCJGZWF0dXJlR3JvdXAiLCJzZXRTdHlsZSIsImJyaW5nVG9Gcm9udCIsImJyaW5nVG9CYWNrIiwiZmVhdHVyZUdyb3VwIiwiSWNvbiIsInBvcHVwQW5jaG9yIiwidG9vbHRpcEFuY2hvciIsImNyZWF0ZUljb24iLCJvbGRJY29uIiwiX2NyZWF0ZUljb24iLCJjcmVhdGVTaGFkb3ciLCJfZ2V0SWNvblVybCIsImltZyIsIl9jcmVhdGVJbWciLCJfc2V0SWNvblN0eWxlcyIsInNpemVPcHRpb24iLCJhbmNob3IiLCJzaGFkb3dBbmNob3IiLCJpY29uQW5jaG9yIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImljb24iLCJJY29uRGVmYXVsdCIsImljb25VcmwiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiaWNvblNpemUiLCJzaGFkb3dTaXplIiwiaW1hZ2VQYXRoIiwiX2RldGVjdEljb25QYXRoIiwicGF0aCIsIk1hcmtlckRyYWciLCJtYXJrZXIiLCJfbWFya2VyIiwiX2ljb24iLCJfZHJhZ2dhYmxlIiwiZHJhZ3N0YXJ0IiwiX29uRHJhZ1N0YXJ0IiwicHJlZHJhZyIsIl9vblByZURyYWciLCJkcmFnIiwiX29uRHJhZyIsImRyYWdlbmQiLCJfb25EcmFnRW5kIiwiX2FkanVzdFBhbiIsInNwZWVkIiwiYXV0b1BhblNwZWVkIiwiYXV0b1BhblBhZGRpbmciLCJpY29uUG9zIiwib3JpZ2luIiwicGFuQm91bmRzIiwibW92ZW1lbnQiLCJfcGFuUmVxdWVzdCIsIl9vbGRMYXRMbmciLCJjbG9zZVBvcHVwIiwiYXV0b1BhbiIsInNoYWRvdyIsIl9zaGFkb3ciLCJfbGF0bG5nIiwib2xkTGF0TG5nIiwiTWFya2VyIiwiaW50ZXJhY3RpdmUiLCJrZXlib2FyZCIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsImRyYWdnYWJsZSIsImxhdExuZyIsIl9pbml0SWNvbiIsInVwZGF0ZSIsIl9yZW1vdmVJY29uIiwiX3JlbW92ZVNoYWRvdyIsInZpZXdyZXNldCIsInNldExhdExuZyIsInNldFpJbmRleE9mZnNldCIsImdldEljb24iLCJzZXRJY29uIiwiX3BvcHVwIiwiYmluZFBvcHVwIiwiZ2V0RWxlbWVudCIsIl9zZXRQb3MiLCJjbGFzc1RvQWRkIiwiYWRkSWNvbiIsIm1vdXNlb3ZlciIsIl9icmluZ1RvRnJvbnQiLCJtb3VzZW91dCIsIl9yZXNldFpJbmRleCIsIm5ld1NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiRG9tVXRpbC5zZXRPcGFjaXR5IiwiX2dldFBvcHVwQW5jaG9yIiwiX2dldFRvb2x0aXBBbmNob3IiLCJQYXRoIiwic3Ryb2tlIiwiY29sb3IiLCJ3ZWlnaHQiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJkYXNoQXJyYXkiLCJkYXNoT2Zmc2V0IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZmlsbFJ1bGUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl91cGRhdGVCb3VuZHMiLCJfYnJpbmdUb0JhY2siLCJfcGF0aCIsIl9wcm9qZWN0IiwiX2NsaWNrVG9sZXJhbmNlIiwiQ2lyY2xlTWFya2VyIiwicmFkaXVzIiwic2V0UmFkaXVzIiwiZ2V0UmFkaXVzIiwiX3BvaW50IiwicjIiLCJfcmFkaXVzWSIsIl9weEJvdW5kcyIsIl91cGRhdGVDaXJjbGUiLCJfZW1wdHkiLCJfYm91bmRzIiwiX2NvbnRhaW5zUG9pbnQiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGUiLCJsZWdhY3lPcHRpb25zIiwiX21SYWRpdXMiLCJoYWxmIiwibGF0UiIsImJvdHRvbSIsImxuZ1IiLCJhY29zIiwiY2lyY2xlIiwiUG9seWxpbmUiLCJzbW9vdGhGYWN0b3IiLCJub0NsaXAiLCJfc2V0TGF0TG5ncyIsImdldExhdExuZ3MiLCJfbGF0bG5ncyIsInNldExhdExuZ3MiLCJpc0VtcHR5IiwiY2xvc2VzdExheWVyUG9pbnQiLCJtaW5EaXN0YW5jZSIsIm1pblBvaW50IiwiY2xvc2VzdCIsIkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCIsImpMZW4iLCJfcGFydHMiLCJoYWxmRGlzdCIsInNlZ0Rpc3QiLCJkaXN0IiwiX3JpbmdzIiwiYWRkTGF0TG5nIiwiX2RlZmF1bHRTaGFwZSIsIl9jb252ZXJ0TGF0TG5ncyIsIkxpbmVVdGlsLmlzRmxhdCIsInJlc3VsdCIsImZsYXQiLCJfcHJvamVjdExhdGxuZ3MiLCJfcmF3UHhCb3VuZHMiLCJwcm9qZWN0ZWRCb3VuZHMiLCJyaW5nIiwiX2NsaXBQb2ludHMiLCJwYXJ0cyIsInNlZ21lbnQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIl9zaW1wbGlmeVBvaW50cyIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiX3VwZGF0ZVBvbHkiLCJwYXJ0IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsInBvbHlsaW5lIiwiTGluZVV0aWwuX2ZsYXQiLCJQb2x5Z29uIiwiZiIsImFyZWEiLCJwb3AiLCJjbGlwcGVkIiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJwb2x5Z29uIiwiR2VvSlNPTiIsImdlb2pzb24iLCJhZGREYXRhIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwiZ2VvbWV0cmllcyIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeVRvTGF5ZXIiLCJhc0ZlYXR1cmUiLCJkZWZhdWx0T3B0aW9ucyIsInJlc2V0U3R5bGUiLCJvbkVhY2hGZWF0dXJlIiwiX3NldExheWVyU3R5bGUiLCJwb2ludFRvTGF5ZXIiLCJfY29vcmRzVG9MYXRMbmciLCJjb29yZHNUb0xhdExuZyIsIl9wb2ludFRvTGF5ZXIiLCJjb29yZHNUb0xhdExuZ3MiLCJwcm9wZXJ0aWVzIiwicG9pbnRUb0xheWVyRm4iLCJtYXJrZXJzSW5oZXJpdE9wdGlvbnMiLCJsZXZlbHNEZWVwIiwibGF0TG5nVG9Db29yZHMiLCJsYXRMbmdzVG9Db29yZHMiLCJnZXRGZWF0dXJlIiwibmV3R2VvbWV0cnkiLCJQb2ludFRvR2VvSlNPTiIsInRvR2VvSlNPTiIsIm11bHRpIiwiaG9sZXMiLCJ0b011bHRpUG9pbnQiLCJpc0dlb21ldHJ5Q29sbGVjdGlvbiIsImpzb25zIiwianNvbiIsImdlb0pTT04iLCJnZW9Kc29uIiwiSW1hZ2VPdmVybGF5IiwiY3Jvc3NPcmlnaW4iLCJlcnJvck92ZXJsYXlVcmwiLCJ1cmwiLCJfdXJsIiwiX2ltYWdlIiwiX2luaXRJbWFnZSIsInN0eWxlT3B0cyIsIkRvbVV0aWwudG9Gcm9udCIsIkRvbVV0aWwudG9CYWNrIiwic2V0VXJsIiwic2V0Qm91bmRzIiwiem9vbWFuaW0iLCJ3YXNFbGVtZW50U3VwcGxpZWQiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIlZpZGVvT3ZlcmxheSIsImF1dG9wbGF5IiwibG9vcCIsImtlZXBBc3BlY3RSYXRpbyIsIm11dGVkIiwidmlkIiwib25sb2FkZWRkYXRhIiwic291cmNlRWxlbWVudHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNvdXJjZXMiLCJzb3VyY2UiLCJ2aWRlb092ZXJsYXkiLCJ2aWRlbyIsIlNWR092ZXJsYXkiLCJzdmdPdmVybGF5IiwiRGl2T3ZlcmxheSIsIl9zb3VyY2UiLCJfcmVtb3ZlVGltZW91dCIsImdldENvbnRlbnQiLCJfY29udGVudCIsInNldENvbnRlbnQiLCJjb250ZW50IiwidmlzaWJpbGl0eSIsIl91cGRhdGVDb250ZW50IiwiX3VwZGF0ZUxheW91dCIsImlzT3BlbiIsIl9wcmVwYXJlT3BlbiIsIm5vZGUiLCJfY29udGVudE5vZGUiLCJoYXNDaGlsZE5vZGVzIiwiX2dldEFuY2hvciIsIl9jb250YWluZXJCb3R0b20iLCJfY29udGFpbmVyTGVmdCIsIl9jb250YWluZXJXaWR0aCIsIlBvcHVwIiwibWluV2lkdGgiLCJtYXhIZWlnaHQiLCJhdXRvUGFuUGFkZGluZ1RvcExlZnQiLCJhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0Iiwia2VlcEluVmlldyIsImNsb3NlQnV0dG9uIiwiYXV0b0Nsb3NlIiwiY2xvc2VPbkVzY2FwZUtleSIsIm9wZW5PbiIsIm9wZW5Qb3B1cCIsInBvcHVwIiwiRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uIiwiY2xvc2VPbkNsaWNrIiwiY2xvc2VQb3B1cE9uQ2xpY2siLCJwcmVjbGljayIsIl9jbG9zZSIsIm1vdmVlbmQiLCJ3cmFwcGVyIiwiX3dyYXBwZXIiLCJfdGlwQ29udGFpbmVyIiwiX3RpcCIsIl9jbG9zZUJ1dHRvbiIsIl9vbkNsb3NlQnV0dG9uQ2xpY2siLCJ3aGl0ZVNwYWNlIiwic2Nyb2xsZWRDbGFzcyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiY2xpY2siLCJfb3BlblBvcHVwIiwia2V5cHJlc3MiLCJfb25LZXlQcmVzcyIsIm1vdmUiLCJfbW92ZVBvcHVwIiwidW5iaW5kUG9wdXAiLCJ0b2dnbGVQb3B1cCIsImlzUG9wdXBPcGVuIiwic2V0UG9wdXBDb250ZW50IiwiZ2V0UG9wdXAiLCJrZXlDb2RlIiwiVG9vbHRpcCIsImRpcmVjdGlvbiIsInBlcm1hbmVudCIsInN0aWNreSIsInRvb2x0aXAiLCJjbG9zZVRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJzdWJYIiwic3ViWSIsInRvb2x0aXBQb2ludCIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJvcGVuVG9vbHRpcCIsImJpbmRUb29sdGlwIiwiX3Rvb2x0aXAiLCJfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMiLCJ1bmJpbmRUb29sdGlwIiwiX3Rvb2x0aXBIYW5kbGVyc0FkZGVkIiwiX21vdmVUb29sdGlwIiwiX29wZW5Ub29sdGlwIiwibW91c2Vtb3ZlIiwidG9nZ2xlVG9vbHRpcCIsImlzVG9vbHRpcE9wZW4iLCJzZXRUb29sdGlwQ29udGVudCIsImdldFRvb2x0aXAiLCJEaXZJY29uIiwiYmdQb3MiLCJFbGVtZW50IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiZGl2SWNvbiIsIkRlZmF1bHQiLCJHcmlkTGF5ZXIiLCJ0aWxlU2l6ZSIsIkJyb3dzZXIubW9iaWxlIiwidXBkYXRlV2hlblpvb21pbmciLCJ1cGRhdGVJbnRlcnZhbCIsIm1heE5hdGl2ZVpvb20iLCJtaW5OYXRpdmVab29tIiwibm9XcmFwIiwia2VlcEJ1ZmZlciIsIl9sZXZlbHMiLCJfdGlsZXMiLCJfcmVtb3ZlQWxsVGlsZXMiLCJfdGlsZVpvb20iLCJfc2V0QXV0b1pJbmRleCIsImlzTG9hZGluZyIsIl9sb2FkaW5nIiwidmlld3ByZXJlc2V0IiwiX2ludmFsaWRhdGVBbGwiLCJVdGlsLnRocm90dGxlIiwiY3JlYXRlVGlsZSIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImNoaWxkcmVuIiwiZWRnZVpJbmRleCIsImlzRmluaXRlIiwibmV4dEZyYW1lIiwid2lsbFBydW5lIiwidGlsZSIsImN1cnJlbnQiLCJsb2FkZWQiLCJmYWRlIiwiYWN0aXZlIiwiX29uT3BhcXVlVGlsZSIsIl9ub1BydW5lIiwiX3BydW5lVGlsZXMiLCJfZmFkZUZyYW1lIiwiX3VwZGF0ZUxldmVscyIsIk51bWJlciIsIl9vblVwZGF0ZUxldmVsIiwiX3JlbW92ZVRpbGVzQXRab29tIiwiX29uUmVtb3ZlTGV2ZWwiLCJsZXZlbCIsIl9zZXRab29tVHJhbnNmb3JtIiwiX29uQ3JlYXRlTGV2ZWwiLCJfbGV2ZWwiLCJyZXRhaW4iLCJfcmV0YWluUGFyZW50IiwiX3JldGFpbkNoaWxkcmVuIiwiX3JlbW92ZVRpbGUiLCJ4MiIsInkyIiwiejIiLCJjb29yZHMyIiwiX3RpbGVDb29yZHNUb0tleSIsImFuaW1hdGluZyIsIl9zZXRWaWV3IiwiX2NsYW1wWm9vbSIsIm5vUHJ1bmUiLCJ0aWxlWm9vbSIsInRpbGVab29tQ2hhbmdlZCIsIl9hYm9ydExvYWRpbmciLCJfcmVzZXRHcmlkIiwiX3NldFpvb21UcmFuc2Zvcm1zIiwidHJhbnNsYXRlIiwiX3RpbGVTaXplIiwiX2dsb2JhbFRpbGVSYW5nZSIsIl9weEJvdW5kc1RvVGlsZVJhbmdlIiwiX3dyYXBYIiwiX3dyYXBZIiwiX2dldFRpbGVkUGl4ZWxCb3VuZHMiLCJtYXBab29tIiwiaGFsZlNpemUiLCJ0aWxlUmFuZ2UiLCJ0aWxlQ2VudGVyIiwicXVldWUiLCJub1BydW5lUmFuZ2UiLCJfaXNWYWxpZFRpbGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJfYWRkVGlsZSIsInRpbGVCb3VuZHMiLCJfdGlsZUNvb3Jkc1RvQm91bmRzIiwiX2tleVRvQm91bmRzIiwiX2tleVRvVGlsZUNvb3JkcyIsIl90aWxlQ29vcmRzVG9Od1NlIiwibndQb2ludCIsInNlUG9pbnQiLCJicCIsIl9pbml0VGlsZSIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJncmlkTGF5ZXIiLCJUaWxlTGF5ZXIiLCJzdWJkb21haW5zIiwiZXJyb3JUaWxlVXJsIiwiem9vbU9mZnNldCIsInRtcyIsInpvb21SZXZlcnNlIiwiZGV0ZWN0UmV0aW5hIiwiX29uVGlsZVJlbW92ZSIsIm5vUmVkcmF3IiwiZG9uZSIsIl90aWxlT25Mb2FkIiwiX3RpbGVPbkVycm9yIiwiZ2V0VGlsZVVybCIsIl9nZXRTdWJkb21haW4iLCJfZ2V0Wm9vbUZvclVybCIsImludmVydGVkWSIsIlV0aWwudGVtcGxhdGUiLCJnZXRBdHRyaWJ1dGUiLCJ0aWxlUG9pbnQiLCJjb21wbGV0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwidGlsZUxheWVyIiwiVGlsZUxheWVyV01TIiwiZGVmYXVsdFdtc1BhcmFtcyIsInNlcnZpY2UiLCJyZXF1ZXN0Iiwic3R5bGVzIiwiZm9ybWF0IiwidHJhbnNwYXJlbnQiLCJ2ZXJzaW9uIiwid21zUGFyYW1zIiwicmVhbFJldGluYSIsIl9jcnMiLCJfd21zVmVyc2lvbiIsInBhcnNlRmxvYXQiLCJwcm9qZWN0aW9uS2V5IiwiYmJveCIsInNldFBhcmFtcyIsInRpbGVMYXllcldNUyIsIldNUyIsIndtcyIsIlJlbmRlcmVyIiwiX3VwZGF0ZVBhdGhzIiwiX2Rlc3Ryb3lDb250YWluZXIiLCJfb25ab29tIiwiem9vbWVuZCIsIl9vblpvb21FbmQiLCJfb25BbmltWm9vbSIsImV2IiwiX3VwZGF0ZVRyYW5zZm9ybSIsImN1cnJlbnRDZW50ZXJQb2ludCIsIl9jZW50ZXIiLCJkZXN0Q2VudGVyUG9pbnQiLCJ0b3BMZWZ0T2Zmc2V0IiwiQ2FudmFzIiwiX29uVmlld1ByZVJlc2V0IiwiX3Bvc3Rwb25lVXBkYXRlUGF0aHMiLCJfZHJhdyIsIl9vbk1vdXNlTW92ZSIsIl9vbkNsaWNrIiwiX2hhbmRsZU1vdXNlT3V0IiwiX2N0eCIsIl9yZWRyYXdSZXF1ZXN0IiwiX3JlZHJhd0JvdW5kcyIsIl9yZWRyYXciLCJtIiwiX3VwZGF0ZURhc2hBcnJheSIsIm9yZGVyIiwiX29yZGVyIiwiX2RyYXdMYXN0IiwibmV4dCIsIl9kcmF3Rmlyc3QiLCJfcmVxdWVzdFJlZHJhdyIsIl9leHRlbmRSZWRyYXdCb3VuZHMiLCJkYXNoVmFsdWUiLCJfZGFzaEFycmF5IiwiX2NsZWFyIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInJlc3RvcmUiLCJiZWdpblBhdGgiLCJjbGlwIiwiX2RyYXdpbmciLCJjbG9zZVBhdGgiLCJfZmlsbFN0cm9rZSIsImFyYyIsImdsb2JhbEFscGhhIiwiZmlsbFN0eWxlIiwic2V0TGluZURhc2giLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsImNsaWNrZWRMYXllciIsIkRvbUV2ZW50LmZha2VTdG9wIiwiX2ZpcmVFdmVudCIsIm1vdmluZyIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsIl9tb3VzZUhvdmVyVGhyb3R0bGVkIiwiY2FuZGlkYXRlSG92ZXJlZExheWVyIiwiQnJvd3Nlci5jYW52YXMiLCJ2bWxDcmVhdGUiLCJuYW1lc3BhY2VzIiwidm1sTWl4aW4iLCJjb29yZHNpemUiLCJfc3Ryb2tlIiwiX2ZpbGwiLCJzdHJva2VkIiwiZmlsbGVkIiwiZGFzaFN0eWxlIiwiZW5kY2FwIiwiam9pbnN0eWxlIiwiX3NldFBhdGgiLCJCcm93c2VyLnZtbCIsIlNWRyIsInpvb21zdGFydCIsIl9vblpvb21TdGFydCIsIl9yb290R3JvdXAiLCJfc3ZnU2l6ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIl9nZXRQYW5lUmVuZGVyZXIiLCJfY3JlYXRlUmVuZGVyZXIiLCJwcmVmZXJDYW52YXMiLCJSZWN0YW5nbGUiLCJfYm91bmRzVG9MYXRMbmdzIiwicmVjdGFuZ2xlIiwiQm94Wm9vbSIsIl9wYW5lIiwib3ZlcmxheVBhbmUiLCJfcmVzZXRTdGF0ZVRpbWVvdXQiLCJfZGVzdHJveSIsIl9vbk1vdXNlRG93biIsIl9yZXNldFN0YXRlIiwiX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlIiwiY29udGV4dG1lbnUiLCJtb3VzZXVwIiwiX29uTW91c2VVcCIsImtleWRvd24iLCJfb25LZXlEb3duIiwiX2JveCIsIl9maW5pc2giLCJib3hab29tQm91bmRzIiwiZG91YmxlQ2xpY2tab29tIiwiRG91YmxlQ2xpY2tab29tIiwiX29uRG91YmxlQ2xpY2siLCJpbmVydGlhIiwiaW5lcnRpYURlY2VsZXJhdGlvbiIsImluZXJ0aWFNYXhTcGVlZCIsIndvcmxkQ29weUp1bXAiLCJtYXhCb3VuZHNWaXNjb3NpdHkiLCJEcmFnIiwiX29uUHJlRHJhZ0xpbWl0IiwiX29uUHJlRHJhZ1dyYXAiLCJfcG9zaXRpb25zIiwiX3RpbWVzIiwiX29mZnNldExpbWl0IiwiX3Zpc2Nvc2l0eSIsIl9sYXN0VGltZSIsIl9sYXN0UG9zIiwiX2Fic1BvcyIsIl9wcnVuZVBvc2l0aW9ucyIsInNoaWZ0IiwicHhDZW50ZXIiLCJweFdvcmxkQ2VudGVyIiwiX2luaXRpYWxXb3JsZE9mZnNldCIsIl93b3JsZFdpZHRoIiwiX3Zpc2NvdXNMaW1pdCIsInRocmVzaG9sZCIsImxpbWl0Iiwid29ybGRXaWR0aCIsImhhbGZXaWR0aCIsIm5ld1gxIiwibmV3WDIiLCJuZXdYIiwibm9JbmVydGlhIiwiZWFzZSIsInNwZWVkVmVjdG9yIiwibGltaXRlZFNwZWVkIiwibGltaXRlZFNwZWVkVmVjdG9yIiwiZGVjZWxlcmF0aW9uRHVyYXRpb24iLCJrZXlib2FyZFBhbkRlbHRhIiwiS2V5Ym9hcmQiLCJrZXlDb2RlcyIsImRvd24iLCJ1cCIsIl9zZXRQYW5EZWx0YSIsIl9zZXRab29tRGVsdGEiLCJfb25Gb2N1cyIsImJsdXIiLCJfb25CbHVyIiwiX2FkZEhvb2tzIiwiX3JlbW92ZUhvb2tzIiwiX2ZvY3VzZWQiLCJkb2NFbCIsInNjcm9sbFRvIiwicGFuRGVsdGEiLCJrZXlzIiwiX3BhbktleXMiLCJjb2RlcyIsIl96b29tS2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2Nyb2xsV2hlZWxab29tIiwid2hlZWxEZWJvdW5jZVRpbWUiLCJ3aGVlbFB4UGVyWm9vbUxldmVsIiwiU2Nyb2xsV2hlZWxab29tIiwiX29uV2hlZWxTY3JvbGwiLCJfZGVsdGEiLCJEb21FdmVudC5nZXRXaGVlbERlbHRhIiwiZGVib3VuY2UiLCJfbGFzdE1vdXNlUG9zIiwiX3RpbWVyIiwiX3BlcmZvcm1ab29tIiwiZDIiLCJkMyIsImQ0IiwidGFwIiwidGFwVG9sZXJhbmNlIiwiVGFwIiwiX2ZpcmVDbGljayIsIl9ob2xkVGltZW91dCIsIl9pc1RhcFZhbGlkIiwiX3NpbXVsYXRlRXZlbnQiLCJ0b3VjaG1vdmUiLCJzaW11bGF0ZWRFdmVudCIsImNyZWF0ZUV2ZW50IiwiX3NpbXVsYXRlZENsaWNrIiwiaW5pdE1vdXNlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiVG91Y2hab29tIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwibW92ZUZuIiwicmVxdWlyZSIsIm1vbnRocyIsImZvcm0iLCJxdWVyeVNlbGVjdG9yIiwiY29udGFpbmVyV29ya291dHMiLCJpbnB1dFR5cGUiLCJpbnB1dERpc3RhbmNlIiwiaW5wdXREdXJhdGlvbiIsImlucHV0Q2FkZW5jZSIsImlucHV0RWxldmF0aW9uIiwiYWxlcnQiXSwic291cmNlUm9vdCI6IiJ9